00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/8/2014 7:01:00 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :Group 6 68k Decompiler
00000000                             3  * Written by :Zeke Snider and Joseph Sturtevan
00000000                             4  * Date       :12/7/2014
00000000                             5  * Description:Decompiler for CSS 422 Hardware
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  * Put program code here
00001000  43F9 00002388             10              LEA     greeting0,A1    *Loads greeting into A1
00001006  103C 000D                 11              MOVE.B  #13,D0          *Sets up trap
0000100A  4E4F                      12              TRAP    #15
0000100C  43F9 000023C9             13  enterStart  LEA     greeting1,A1    *Loads prompt into A1
00001012  103C 000E                 14              MOVE.B  #14,D0          *Sets up trap
00001016  4E4F                      15              TRAP    #15
00001018  43F9 0000A000             16              LEA     OUTPUT_START,A1 *Puts input into OUTPUT_START location
0000101E  103C 0002                 17              MOVE.B  #2,D0           *Sets up trap to accept input of starting address
00001022  4E4F                      18              TRAP    #15
00001024  6100 075E                 19              BSR     strToHex        *Converts the input to HEX
00001028  2A41                      20              MOVE.L  D1,A5           *Load start address
0000102A  43F9 000023EB             21              LEA     greeting2,A1    *Loads prompt into A1
00001030  103C 000E                 22              MOVE.B  #14,D0          *Sets up trap
00001034  4E4F                      23              TRAP    #15
00001036  43F9 0000A000             24              LEA     OUTPUT_START,A1 *Puts input into OUTPUT_START location
0000103C  103C 0002                 25              MOVE.B  #2,D0           *Sets up trap to accept input of endinging address
00001040  4E4F                      26              TRAP    #15
00001042  6100 0740                 27              BSR     strToHex        *Converts the input to HEX
00001046  2C41                      28              MOVE.L  D1,A6           *Load ending address
00001048  BDCD                      29              CMP.L   A5,A6           *Checks to make sure A6 is after A5
0000104A  6F00 0872                 30              BLE     invalidAddress  *Makes you resubmit addresses if input is invalid
0000104E  1F3C 0000                 31              MOVE.B  #0,-(sp)        *Moves initial line counter onto stack
00001052                            32          
00001052  4280                      33  loop        CLR.L   D0              *Gives fresh D0
00001054  101F                      34              MOVE.B  (sp)+,D0        *Moves line counter into D0 to check
00001056  6100 0876                 35              BSR     linecounter     *Checks line count to see if we need to pause
0000105A  1F00                      36              MOVE.B  D0,-(sp)        *Moves line counter back to stack
0000105C  3015                      37              MOVE.W  (A5),D0         *Gets the data of where the pointer is at
0000105E  41F9 0000A000             38              LEA     OUTPUT_START,A0 *Sets up output for EA
00001064  6100 000C                 39              BSR     getOP           *Gets the data at add
00001068  544D                      40              ADDQ.W  #byte,A5        *Incrementing the pointer one word
0000106A  BACE                      41              CMPA.W  A6,A5           *Seeing if we're at end of the search area
0000106C  6E00 1312                 42              BGT     end_search      *go to end if we leave search area
00001070  60E0                      43              BRA     loop            *else go back to the beginning of the loop
00001072                            44              
00001072  3400                      45  getOP       MOVE.W  D0,D2           *Moves data to D2 to use
00001074  6000 0086                 46              BRA     compare_NOP     *compares the NOP op code
00001078  6000 02A4                 47  endNOP      BRA     compare_RTS     *Compares the RTS op code
0000107C                            48  endRTS
0000107C  6100 09A4                 49              BSR     maskMulDivL     *Masks to compare to MULS.L and DIVS.L
00001080  6000 01B8                 50              BRA     compare_MULSL   *Compares the MULS.L op code
00001084  6000 01C0                 51  endMULSL    BRA     compare_DIVSL   *Compares the DIVS.L op code
00001088                            52  endDIVSL
00001088  6100 0990                 53              BSR     mask15to6       *Masks to compare BCLR
0000108C  6000 0240                 54              BRA     compare_BCLRI   *Compare to BCLR with an immidiate
00001090  6000 0280                 55  endBCLRI    BRA     compare_JSR     *Compare to JSR
00001094                            56  endJSR
00001094  6100 097C                 57              BSR     mask15to7       *Masks to compare to MoveM
00001098  6000 010C                 58              BRA     compare_MOVEM   *Compares to MoveM
0000109C                            59  endMOVEM
0000109C  6100 0964                 60              BSR     mask15to8       *Masks to the first byte
000010A0  6000 0066                 61              BRA     compare_ORI     *Compares the ORI op codes
000010A4  6000 01E0                 62  endORI      BRA     compare_CMPI    *Compares the CMPI op code
000010A8  6000 023C                 63  endCMPI     BRA     compare_Bcc     *Compares the Bcc op codes
000010AC  6000 027C                 64  endBcc      BRA     compare_NEG     *Compares the NEG op code
000010B0                            65  endNEG
000010B0  6100 0948                 66              BSR     compMask        *Masks D2 to make comparisons easier
000010B4  6000 0090                 67              BRA     compare_EOR     *Compares the EOR op codes
000010B8  6000 0058                 68  endEOR      BRA     compare_OR      *Compares the OR op codes
000010BC  6000 00A4                 69  endOR       BRA     compare_ADD     *Compares the ADD op codes
000010C0  6000 00F8                 70  endADD      BRA     compare_MOVEA   *Compares the MOVEA op codes
000010C4  6000 0124                 71  endMOVEA    BRA     compare_SUB     *Compares the SUB op codes
000010C8  6000 0154                 72  endSUB      BRA     compare_SUBQ    *Compares the SUBQ op codes
000010CC  6000 0184                 73  endSUBQ     BRA     compare_MULSW   *Compares the MULS.W op code
000010D0  6000 018C                 74  endMULSW    BRA     compare_DIVSW   *Compares the DIVS.W op code
000010D4  6000 0194                 75  endDIVSW    BRA     compare_CMP     *Compares the CMP op codes
000010D8  6000 0200                 76  endCMP      BRA     compare_BCLR    *Compares the BCLR without immidate op code
000010DC  6000 0258                 77  endBCLR     BRA     compare_LEA     *Compares the LEA op code
000010E0                            78  endLEA
000010E0  6100 0928                 79              BSR     mask15to12      *Masks D2 to first 4 bits
000010E4  6000 00E8                 80              BRA     compare_MOVE    *Compares the MOVE op codes
000010E8  6000 01A8                 81  endMOVE     BRA     compare_shift   *Compares LSL,LSR, ASL, and ASR
000010EC                            82  endshift
000010EC                            83                                      *if we get here, the operation is unknown
000010EC  3400                      84              MOVE.W  D0,D2           *Restores D2 to default
000010EE  6100 0942                 85              BSR     outaddress      *Data unknown, just print the address
000010F2  6100 095A                 86              BSR     isData          *And then the data
000010F6  6100 1272                 87  endOP       BSR     IO_PRINT_OUTPUT *Prints EA output
000010FA  4E75                      88              RTS                     *Returns to caller
000010FC                            89  
000010FC                            90  *Comparison subroutines, broken up by Operation
000010FC                            91  compare_NOP
000010FC  B47C 4E71                 92              CMP.W   #nop_code,D2    *Compares to NOP
00001100  6700 0240                 93              BEQ     isNOP           *Skips the return if it is NOP
00001104  6000 FF72                 94              BRA     endNOP
00001108                            95  
00001108                            96  compare_ORI
00001108  B47C 0000                 97              CMP.W   #ori_code,D2    *Compares to ORI
0000110C  6700 0272                 98              BEQ     isORI
00001110  6092                      99              BRA     endORI
00001112                           100              
00001112                           101  compare_OR
00001112  B47C 8000                102              CMP.W   #orbDn_code,D2  *Compares to ORI.B -> Dn
00001116  6700 0292                103              BEQ     isOR
0000111A  B47C 8040                104              CMP.W   #orwDn_code,D2  *Compares to ORI.W -> Dn
0000111E  6700 028A                105              BEQ     isOR
00001122  B47C 8080                106              CMP.W   #orlDn_code,D2  *Compares to ORI.L -> Dn
00001126  6700 0282                107              BEQ     isOR
0000112A  B47C 8100                108              CMP.W   #orbEA_code,D2  *Compares to ORI.B -> EA
0000112E  6700 027A                109              BEQ     isOR
00001132  B47C 8140                110              CMP.W   #orwEA_code,D2  *Compares to ORI.W -> EA
00001136  6700 0272                111              BEQ     isOR
0000113A  B47C 8180                112              CMP.W   #orlEA_code,D2  *Compares to ORI.L -> EA
0000113E  6700 026A                113              BEQ     isOR
00001142  6000 FF78                114              BRA     endOR
00001146                           115              
00001146                           116  compare_EOR
00001146  B47C B100                117              CMP.W   #eorb_code,D2   *Compares to EOR.B
0000114A  6700 020A                118              BEQ     isEOR
0000114E  B47C B140                119              CMP.W   #eorw_code,D2   *Compares to EOR.W
00001152  6700 0202                120              BEQ     isEOR
00001156  B47C B180                121              CMP.W   #eorl_code,D2   *Compares to EOR.L
0000115A  6700 01FA                122              BEQ     isEOR
0000115E  6000 FF58                123              BRA     endEOR
00001162                           124              
00001162                           125  compare_ADD
00001162  B47C D000                126              CMP.W   #addbDn_code,D2 *Compares to ADD.B -> Dn
00001166  6700 0268                127              BEQ     isADD
0000116A  B47C D040                128              CMP.W   #addwDn_code,D2 *Compares to ADD.W -> Dn
0000116E  6700 0260                129              BEQ     isADD
00001172  B47C D080                130              CMP.W   #addlDn_code,D2 *Compares to ADD.L -> Dn
00001176  6700 0258                131              BEQ     isADD
0000117A  B47C D100                132              CMP.W   #addbEA_code,D2 *Compares to ADD.B -> EA
0000117E  6700 0250                133              BEQ     isADD
00001182  B47C D140                134              CMP.W   #addwEA_code,D2 *Compares to ADD.W -> EA
00001186  6700 0248                135              BEQ     isADD
0000118A  B47C D180                136              CMP.W   #addlEA_code,D2 *Compares to ADD.L -> EA
0000118E  6700 0240                137              BEQ     isADD
00001192  B47C D0C0                138              CMP.W   #addaw_code,D2  *Compares to ADDA.W
00001196  6700 0262                139              BEQ     isADDA
0000119A  B47C D1C0                140              CMP.W   #addal_code,D2  *Compares to ADDA.L
0000119E  6700 025A                141              BEQ     isADDA
000011A2  6000 FF1C                142              BRA     endADD
000011A6                           143  
000011A6                           144  compare_MOVEM
000011A6  B47C 4880                145              CMP.W   #movemr2m_code,D2 *Compares to MOVEM Register to memory
000011AA  6700 027C                146              BEQ     isMOVEM
000011AE  B47C 4C80                147              CMP.W   #movemm2r_code,D2 *Compares to MOVEM memory to register
000011B2  6700 0274                148              BEQ     isMOVEM
000011B6  6000 FEE4                149              BRA     endMOVEM
000011BA                           150  
000011BA                           151  compare_MOVEA
000011BA  B47C 3040                152              CMP.W   #moveaw_code,D2 *Compares to MOVEA word operation
000011BE  6700 027C                153              BEQ     isMOVEA
000011C2  B47C 2040                154              CMP.W   #moveal_code,D2 *Compares to MOVEA long operation
000011C6  6700 0274                155              BEQ     isMOVEA
000011CA  6000 FEF8                156              BRA     endMOVEA
000011CE                           157  
000011CE                           158  compare_MOVE
000011CE  B47C 1000                159              CMP.W   #moveb_code,D2  *Compares to MOVE byte operation
000011D2  6700 029A                160              BEQ     isMOVE
000011D6  B47C 3000                161              CMP.W   #movew_code,D2  *Compares to MOVE word operation
000011DA  6700 0292                162              BEQ     isMOVE
000011DE  B47C 2000                163              CMP.W   #movel_code,D2  *Compares to MOVE long operation
000011E2  6700 028A                164              BEQ     isMOVE
000011E6  6000 FF00                165              BRA     endMOVE
000011EA                           166  
000011EA                           167  compare_SUB
000011EA  B47C 9000                168              CMP.W   #subbDn_code,D2 *Compares to SUB.B -> Dn
000011EE  6700 02AC                169              BEQ     isSUB
000011F2  B47C 9040                170              CMP.W   #subwDn_code,D2 *Compares to SUB.W -> Dn
000011F6  6700 02A4                171              BEQ     isSUB
000011FA  B47C 9080                172              CMP.W   #sublDn_code,D2 *Compares to SUB.L -> Dn
000011FE  6700 029C                173              BEQ     isSUB
00001202  B47C 9100                174              CMP.W   #subbEA_code,D2 *Compares to SUB.B -> EA
00001206  6700 0294                175              BEQ     isSUB
0000120A  B47C 9140                176              CMP.W   #subwEA_code,D2 *Compares to SUB.W -> EA
0000120E  6700 028C                177              BEQ     isSUB
00001212  B47C 9180                178              CMP.W   #sublEA_code,D2 *Compares to SUB.L -> EA
00001216  6700 0284                179              BEQ     isSUB
0000121A  6000 FEAC                180              BRA     endSUB
0000121E                           181  
0000121E                           182  compare_SUBQ
0000121E  B47C 5100                183              CMP.W   #subqb_code,D2   *Compares to SUBQ.B
00001222  6700 02A2                184              BEQ     isSUBQ
00001226  B47C 5140                185              CMP.W   #subqw_code,D2   *Compares to SUBQ.W
0000122A  6700 029A                186              BEQ     isSUBQ
0000122E  B47C 5180                187              CMP.W   #subql_code,D2   *Compares to SUBQ.L
00001232  6700 0292                188              BEQ     isSUBQ
00001236  6000 FE94                189              BRA     endSUBQ
0000123A                           190  
0000123A                           191  compare_MULSL
0000123A  B47C 0800                192              CMP.W   #mulsl_code,D2  *Compares to MULS.L
0000123E  6700 02B4                193              BEQ     isMULS
00001242  6000 FE40                194              BRA     endMULSL
00001246                           195  
00001246                           196  compare_DIVSL
00001246  B47C 0840                197              CMP.W   #divsl_code,D2  *Compares to DIVS.L
0000124A  6700 02C8                198              BEQ     isDIVS
0000124E  6000 FE38                199              BRA     endDIVSL
00001252                           200   
00001252                           201  compare_MULSW
00001252  B47C C1C0                202              CMP.W   #mulsw_code,D2  *Compares to MULS.W
00001256  6700 029C                203              BEQ     isMULS
0000125A  6000 FE74                204              BRA     endMULSW
0000125E                           205  
0000125E                           206  compare_DIVSW
0000125E  B47C 81C0                207              CMP.W   #divsw_code,D2  *Compares to DIVS.W
00001262  6700 02B0                208              BEQ     isDIVS
00001266  6000 FE6C                209              BRA     endDIVSW
0000126A                           210  
0000126A                           211  compare_CMP
0000126A  B47C B000                212              CMP.W   #cmpb_code,D2   *Compares to CMP.B
0000126E  6700 02C4                213              BEQ     isCMP
00001272  B47C B040                214              CMP.W   #cmpw_code,D2   *Compares to CMP.W
00001276  6700 02BC                215              BEQ     isCMP
0000127A  B47C B080                216              CMP.W   #cmpl_code,D2   *Compares to CMP.L
0000127E  6700 02B4                217              BEQ     isCMP
00001282  6000 FE54                218              BRA     endCMP
00001286                           219  
00001286                           220  compare_CMPI
00001286  B47C 0C00                221              CMP.W   #cmpi_code,D2   *Compares to CMPI
0000128A  6700 02D2                222              BEQ     isCMPI
0000128E  6000 FE18                223              BRA     endCMPI
00001292                           224  
00001292                           225  compare_shift
00001292  6100 0796                226              BSR     maskShift        *Masks to shift type and direction
00001296  B47C E008                227              CMP.W   #lsr_code,D2    *Compares to LSR
0000129A  6700 02F0                228              BEQ     isLSR
0000129E  B47C E108                229              CMP.W   #lsl_code,D2    *Compares to LSL
000012A2  6700 0312                230              BEQ     isLSL
000012A6  B47C E000                231              CMP.W   #asr_code,D2    *Compares to ASR
000012AA  6700 0334                232              BEQ     isASR
000012AE  B47C E100                233              CMP.W   #asl_code,D2    *Compares to ASL
000012B2  6700 0356                234              BEQ     isASL
000012B6  B47C E018                235              CMP.W   #ror_code,D2    *Compares to ROR
000012BA  6700 0378                236              BEQ     isROR
000012BE  B47C E118                237              CMP.W   #rol_code,D2    *Compares to ROL
000012C2  6700 039A                238              BEQ     isROL
000012C6  6100 0742                239              BSR     mask15to12      *Returns the 15to12 mask
000012CA  6000 FE20                240              BRA     endshift
000012CE                           241  
000012CE                           242  compare_BCLRI
000012CE  B47C 0880                243              CMP.W   #bclri_code,D2  *Compares to BCLR with an immidiate
000012D2  6700 03B4                244              BEQ     isBCLR
000012D6  6000 FDB8                245              BRA     endBCLRI
000012DA                           246  
000012DA                           247  compare_BCLR
000012DA  B47C 0180                248              CMP.W   #bclr_code,D2   *Compares to BCLR
000012DE  6700 03A8                249              BEQ     isBCLR
000012E2  6000 FDF8                250              BRA     endBCLR
000012E6                           251  
000012E6                           252  compare_Bcc
000012E6  B47C 6500                253              CMP.W   #bcs_code,D2    *Compares to BCS
000012EA  6700 03B8                254              BEQ     isBCS
000012EE  B47C 6C00                255              CMP.W   #bge_code,D2    *Compares to BGE
000012F2  6700 03C8                256              BEQ     isBGE
000012F6  B47C 6D00                257              CMP.W   #blt_code,D2    *Compares to BLT
000012FA  6700 03D8                258              BEQ     isBLT
000012FE  B47C 6800                259              CMP.W   #bvc_code,D2    *Compares to BVC
00001302  6700 03E8                260              BEQ     isBVC
00001306  B47C 6000                261              CMP.W   #bra_code,D2    *Compares to BRA
0000130A  6700 03F8                262              BEQ     isBRA
0000130E  6000 FD9C                263              BRA     endBcc
00001312                           264  
00001312                           265  compare_JSR
00001312  B47C 4E80                266              CMP.W   #jsr_code,D2    *Compares to JSR
00001316  6700 0404                267              BEQ     isJSR
0000131A  6000 FD78                268              BRA     endJSR
0000131E                           269  
0000131E                           270  compare_RTS
0000131E  B47C 4E75                271              CMP.W   #rts_code,D2    *Compares to RTS
00001322  6700 0410                272              BEQ     isRTS
00001326  6000 FD54                273              BRA     endRTS
0000132A                           274  
0000132A                           275  compare_NEG
0000132A  B47C 4400                276              CMP.W   #neg_code,D2    *Compares to NEG
0000132E  6700 041C                277              BEQ     isNEG
00001332  6000 FD7C                278              BRA     endNEG
00001336                           279  
00001336                           280  compare_LEA
00001336  B47C 41C0                281              CMP.W   #lea_code,D2    *Compares to LEA
0000133A  6700 042C                282              BEQ     isLEA
0000133E  6000 FDA0                283              BRA     endLEA
00001342                           284  
00001342                           285  *If compare is successful, we go to one of the isX
00001342  6100 06EE                286  isNOP       BSR     outaddress      *prints current address
00001346  43F9 00002439            287              LEA     NOPstring,A1    *Loads NOPstring for printing
0000134C  103C 000D                288              MOVE.B  #13,D0          *Sets up trap
00001350  4E4F                     289              TRAP    #15
00001352  6000 FDA2                290              BRA     endOP            
00001356  6100 06DA                291  isEOR       BSR     outaddress      *prints current address
0000135A  6100 1184                292              BSR     BitMask6to8     *Masking size bits
0000135E  1607                     293              MOVE.B  D7,D3           *Moving result to D3
00001360  10FC 0045                294              MOVE.B  #'E',(A0)+
00001364  10FC 004F                295              MOVE.B  #'O',(A0)+
00001368  10FC 0052                296              MOVE.B  #'R',(A0)+
0000136C  10FC 002E                297              MOVE.B  #'.',(A0)+
00001370  6100 0582                298              BSR     checkSize       *Finding size, outputting it, and storing it
00001374  10FC 0020                299              MOVE.B  #' ',(A0)+
00001378  6100 0858                300              BSR     EA_EOR
0000137C  6000 FD78                301              BRA     endOP            
00001380  6100 06B0                302  isORI       BSR     outaddress      *prints current address
00001384  6100 1168                303              BSR     BitMask6to7     *Masking size bits
00001388  1607                     304              MOVE.B  D7,D3           *Moving result to D3
0000138A  10FC 004F                305              MOVE.B  #'O',(A0)+
0000138E  10FC 0052                306              MOVE.B  #'R',(A0)+
00001392  10FC 0049                307              MOVE.B  #'I',(A0)+
00001396  10FC 002E                308              MOVE.B  #'.',(A0)+
0000139A  6100 0558                309              BSR     checkSize       *Finding size, outputting it, and storing it
0000139E  10FC 0020                310              MOVE.B  #' ',(A0)+
000013A2  6100 08F6                311              BSR     EA_ORI
000013A6  6000 FD4E                312              BRA     endOP
000013AA  6100 0686                313  isOR        BSR     outaddress      *prints current address
000013AE  6100 1130                314              BSR     BitMask6to8     *Masking size bits
000013B2  1607                     315              MOVE.B  D7,D3           *Moving result to D3
000013B4  10FC 004F                316              MOVE.B  #'O',(A0)+
000013B8  10FC 0052                317              MOVE.B  #'R',(A0)+
000013BC  10FC 002E                318              MOVE.B  #'.',(A0)+
000013C0  6100 0532                319              BSR     checkSize       *Finding size, outputting it, and storing it
000013C4  10FC 0020                320              MOVE.B  #' ',(A0)+
000013C8  6100 085A                321              BSR     EA_OR
000013CC  6000 FD28                322              BRA     endOP
000013D0  6100 0660                323  isADD       BSR     outaddress      *prints current address
000013D4  6100 110A                324              BSR     BitMask6to8     *Masking size bits
000013D8  1607                     325              MOVE.B  D7,D3           *Moving result to D3
000013DA  10FC 0041                326              MOVE.B  #'A',(A0)+
000013DE  10FC 0044                327              MOVE.B  #'D',(A0)+
000013E2  10FC 0044                328              MOVE.B  #'D',(A0)+
000013E6  10FC 002E                329              MOVE.B  #'.',(A0)+
000013EA  6100 0508                330              BSR     checkSize       *Finding size, outputting it, and storing it
000013EE  10FC 0020                331              MOVE.B  #' ',(A0)+
000013F2  6100 0A02                332              BSR     EA_ADD
000013F6  6000 FCFE                333              BRA     endOP
000013FA  6100 0636                334  isADDA      BSR     outaddress      *prints current address
000013FE  6100 10E0                335              BSR     BitMask6to8     *Masking size bits
00001402  3607                     336              MOVE.W  D7,D3           *Moving result to D3
00001404  10FC 0041                337              MOVE.B  #'A',(A0)+
00001408  10FC 0044                338              MOVE.B  #'D',(A0)+
0000140C  10FC 0044                339              MOVE.B  #'D',(A0)+
00001410  10FC 0041                340              MOVE.B  #'A',(A0)+
00001414  10FC 002E                341              MOVE.B  #'.',(A0)+
00001418  6100 04DA                342              BSR     checkSize       *Finding size, outputting it, and storing it
0000141C  10FC 0020                343              MOVE.B  #' ',(A0)+
00001420  6100 07DE                344              BSR     EA_ADDA
00001424  6000 FCD0                345              BRA     endOP
00001428  6100 0608                346  isMOVEM     BSR     outaddress      *prints current address
0000142C  43F9 00002451            347              LEA     MOVEMstring,A1  *Loads MOVEMstring for printing
00001432  103C 000D                348              MOVE.B  #13,D0          *Sets up trap
00001436  4E4F                     349              TRAP    #15
00001438  6000 FCBC                350              BRA     endOP
0000143C  6100 05F4                351  isMOVEA     BSR     outaddress      *prints current address
00001440  6100 10E0                352              BSR     BitMask12to13   *Masking size bits
00001444  3607                     353              MOVE.W  D7,D3           *Moving result to D3
00001446  10FC 004D                354              MOVE.B  #'M',(A0)+
0000144A  10FC 004F                355              MOVE.B  #'O',(A0)+
0000144E  10FC 0056                356              MOVE.B  #'V',(A0)+
00001452  10FC 0045                357              MOVE.B  #'E',(A0)+
00001456  10FC 0041                358              MOVE.B  #'A',(A0)+
0000145A  10FC 002E                359              MOVE.B  #'.',(A0)+
0000145E  6100 0494                360              BSR     checkSize       *Finding size, outputting it, and storing it
00001462  10FC 0020                361              MOVE.B  #' ',(A0)+
00001466  6100 0A5E                362              BSR     EA_MOVEA
0000146A  6000 FC8A                363              BRA     endOP
0000146E  6100 05C2                364  isMOVE      BSR     outaddress      *prints current address
00001472  6100 10AE                365              BSR     BitMask12to13   *Masking size bits
00001476  3607                     366              MOVE.W  D7,D3           *Moving result to D3
00001478  10FC 004D                367              MOVE.B  #'M',(A0)+
0000147C  10FC 004F                368              MOVE.B  #'O',(A0)+
00001480  10FC 0056                369              MOVE.B  #'V',(A0)+
00001484  10FC 0045                370              MOVE.B  #'E',(A0)+
00001488  10FC 002E                371              MOVE.B  #'.',(A0)+
0000148C  6100 0466                372              BSR     checkSize       *Finding size, outputting it, and storing it
00001490  10FC 0020                373              MOVE.B  #' ',(A0)+
00001494  6100 09FE                374              BSR     EA_MOVE
00001498  6000 FC5C                375              BRA     endOP
0000149C  6100 0594                376  isSUB       BSR     outaddress      *prints current address
000014A0  6100 103E                377              BSR     BitMask6to8     *Masking size bits
000014A4  1607                     378              MOVE.B  D7,D3           *Moving result to D3
000014A6  10FC 0053                379              MOVE.B  #'S',(A0)+
000014AA  10FC 0055                380              MOVE.B  #'U',(A0)+
000014AE  10FC 0042                381              MOVE.B  #'B',(A0)+
000014B2  10FC 002E                382              MOVE.B  #'.',(A0)+
000014B6  6100 043C                383              BSR     checkSize       *Finding size, outputting it, and storing it
000014BA  10FC 0020                384              MOVE.B  #' ',(A0)+
000014BE  6100 08B2                385              BSR     EA_SUB
000014C2  6000 FC32                386              BRA     endOP
000014C6  6100 056A                387  isSUBQ      BSR     outaddress      *prints current address
000014CA  6100 1022                388              BSR     BitMask6to7     *Masking size bits
000014CE  1607                     389              MOVE.B  D7,D3           *Moving result to D3
000014D0  10FC 0053                390              MOVE.B  #'S',(A0)+
000014D4  10FC 0055                391              MOVE.B  #'U',(A0)+
000014D8  10FC 0042                392              MOVE.B  #'B',(A0)+
000014DC  10FC 0051                393              MOVE.B  #'Q',(A0)+
000014E0  10FC 002E                394              MOVE.B  #'.',(A0)+
000014E4  6100 040E                395              BSR     checkSize       *Finding size, outputting it, and storing it
000014E8  10FC 0020                396              MOVE.B  #' ',(A0)+
000014EC  6100 0970                397              BSR     EA_SUBQ
000014F0  6000 FC04                398              BRA     endOP
000014F4  6100 053C                399  isMULS      BSR     outaddress      *prints current address
000014F8  10FC 004D                400              MOVE.B  #'M',(A0)+
000014FC  10FC 0055                401              MOVE.B  #'U',(A0)+
00001500  10FC 004C                402              MOVE.B  #'L',(A0)+
00001504  10FC 0053                403              MOVE.B  #'S',(A0)+
00001508  10FC 0020                404              MOVE.B  #' ',(A0)+
0000150C  6100 0A28                405              BSR     EA_MULS
00001510  6000 FBE4                406              BRA     endOP
00001514  6100 051C                407  isDIVS      BSR     outaddress      *prints current address
00001518  10FC 0044                408              MOVE.B  #'D',(A0)+
0000151C  10FC 0049                409              MOVE.B  #'I',(A0)+
00001520  10FC 0056                410              MOVE.B  #'V',(A0)+
00001524  10FC 0053                411              MOVE.B  #'S',(A0)+
00001528  10FC 0020                412              MOVE.B  #' ',(A0)+
0000152C  6100 0A34                413              BSR     EA_DIVS
00001530  6000 FBC4                414              BRA     endOP
00001534  6100 04FC                415  isCMP       BSR     outaddress      *prints current address
00001538  6100 0FA6                416              BSR     BitMask6to8     *Masking size bits
0000153C  3607                     417              MOVE.W  D7,D3           *Moving result to D3
0000153E  10FC 0043                418              MOVE.B  #'C',(A0)+
00001542  10FC 004D                419              MOVE.B  #'M',(A0)+
00001546  10FC 0050                420              MOVE.B  #'P',(A0)+
0000154A  10FC 002E                421              MOVE.B  #'.',(A0)+
0000154E  6100 03A4                422              BSR     checkSize      *Finding size, outputting it, and storing it
00001552  10FC 0020                423              MOVE.B  #' ',(A0)+
00001556  6100 0992                424              BSR     EA_CMP
0000155A  6000 FB9A                425              BRA     endOP
0000155E  6100 04D2                426  isCMPI      BSR     outaddress      *prints current address
00001562  6100 0F8A                427              BSR     BitMask6to7     *Masking size bits
00001566  3607                     428              MOVE.W  D7,D3           *Moving result to D3
00001568  10FC 0043                429              MOVE.B  #'C',(A0)+
0000156C  10FC 004D                430              MOVE.B  #'M',(A0)+
00001570  10FC 0050                431              MOVE.B  #'P',(A0)+
00001574  10FC 0049                432              MOVE.B  #'I',(A0)+
00001578  10FC 002E                433              MOVE.B  #'.',(A0)+
0000157C  6100 0376                434              BSR     checkSize       *Finding size, outputting it, and storing it
00001580  10FC 0020                435              MOVE.B  #' ',(A0)+
00001584  6100 0988                436              BSR     EA_CMPI
00001588  6000 FB6C                437              BRA     endOP
0000158C  6100 04A4                438  isLSR       BSR     outaddress      *prints current address
00001590  6100 0F5C                439              BSR     BitMask6to7     *Masking size bits
00001594  3607                     440              MOVE.W  D7,D3           *Moving result to D3
00001596  10FC 004C                441              MOVE.B  #'L',(A0)+
0000159A  10FC 0053                442              MOVE.B  #'S',(A0)+
0000159E  10FC 0052                443              MOVE.B  #'R',(A0)+
000015A2  10FC 002E                444              MOVE.B  #'.',(A0)+
000015A6  6100 034C                445              BSR     checkSize       *Finding size, outputting it, and storing it            
000015AA  10FC 0020                446              MOVE.B  #' ',(A0)+
000015AE  6100 09DE                447              BSR     EA_LS_REGISTER
000015B2  6000 FB42                448              BRA     endOP
000015B6  6100 047A                449  isLSL       BSR     outaddress      *prints current address
000015BA  6100 0F32                450              BSR     BitMask6to7     *Masking size bits
000015BE  3607                     451              MOVE.W  D7,D3           *Moving result to D3
000015C0  10FC 004C                452              MOVE.B  #'L',(A0)+
000015C4  10FC 0053                453              MOVE.B  #'S',(A0)+
000015C8  10FC 004C                454              MOVE.B  #'L',(A0)+
000015CC  10FC 002E                455              MOVE.B  #'.',(A0)+
000015D0  6100 0322                456              BSR     checkSize       *Finding size, outputting it, and storing it
000015D4  10FC 0020                457              MOVE.B  #' ',(A0)+
000015D8  6100 09B4                458              BSR     EA_LS_REGISTER
000015DC  6000 FB18                459              BRA     endOP
000015E0  6100 0450                460  isASR       BSR     outaddress      *prints current address
000015E4  6100 0F08                461              BSR     BitMask6to7     *Masking size bits
000015E8  3607                     462              MOVE.W  D7,D3           *Moving result to D3
000015EA  10FC 0041                463              MOVE.B  #'A',(A0)+
000015EE  10FC 0053                464              MOVE.B  #'S',(A0)+
000015F2  10FC 0052                465              MOVE.B  #'R',(A0)+
000015F6  10FC 002E                466              MOVE.B  #'.',(A0)+
000015FA  6100 02F8                467              BSR     checkSize       *Finding size, outputting it, and storing it
000015FE  10FC 0020                468              MOVE.B  #' ',(A0)+
00001602  6100 09FC                469              BSR     EA_AS_REGISTER
00001606  6000 FAEE                470              BRA     endOP 
0000160A  6100 0426                471  isASL       BSR     outaddress      *prints current address
0000160E  6100 0EDE                472              BSR     BitMask6to7     *Masking size bits
00001612  3607                     473              MOVE.W  D7,D3           *Moving result to D3
00001614  10FC 0041                474              MOVE.B  #'A',(A0)+
00001618  10FC 0053                475              MOVE.B  #'S',(A0)+
0000161C  10FC 004C                476              MOVE.B  #'L',(A0)+
00001620  10FC 002E                477              MOVE.B  #'.',(A0)+
00001624  6100 02CE                478              BSR     checkSize       *Finding size, outputting it, and storing it
00001628  10FC 0020                479              MOVE.B  #' ',(A0)+
0000162C  6100 09D2                480              BSR     EA_AS_REGISTER
00001630  6000 FAC4                481              BRA     endOP
00001634  6100 03FC                482  isROR       BSR     outaddress      *prints current address
00001638  6100 0EB4                483              BSR     BitMask6to7     *Masking size bits
0000163C  3607                     484              MOVE.W  D7,D3           *Moving result to D3
0000163E  10FC 0052                485              MOVE.B  #'R',(A0)+
00001642  10FC 004F                486              MOVE.B  #'O',(A0)+
00001646  10FC 0052                487              MOVE.B  #'R',(A0)+
0000164A  10FC 002E                488              MOVE.B  #'.',(A0)+
0000164E  6100 02A4                489              BSR     checkSize       *Finding size, outputting it, and storing it
00001652  10FC 0020                490              MOVE.B  #' ',(A0)+
00001656  6100 0A16                491              BSR     EA_RO_REGISTER
0000165A  6000 FA9A                492              BRA     endOP
0000165E  6100 03D2                493  isROL       BSR     outaddress      *prints current address
00001662  6100 0E8A                494              BSR     BitMask6to7     *Masking size bits
00001666  3607                     495              MOVE.W  D7,D3           *Moving result to D3
00001668  10FC 0052                496              MOVE.B  #'R',(A0)+
0000166C  10FC 004F                497              MOVE.B  #'O',(A0)+
00001670  10FC 004C                498              MOVE.B  #'L',(A0)+
00001674  10FC 002E                499              MOVE.B  #'.',(A0)+
00001678  6100 027A                500              BSR     checkSize       *Finding size, outputting it, and storing it
0000167C  10FC 0020                501              MOVE.B  #' ',(A0)+
00001680  6100 09EC                502              BSR     EA_RO_REGISTER
00001684  6000 FA70                503              BRA     endOP
00001688  6100 03A8                504  isBCLR      BSR     outaddress      *prints current address
0000168C  10FC 0042                505              MOVE.B  #'B',(A0)+
00001690  10FC 0043                506              MOVE.B  #'C',(A0)+
00001694  10FC 004C                507              MOVE.B  #'L',(A0)+
00001698  10FC 0052                508              MOVE.B  #'R',(A0)+
0000169C  10FC 0020                509              MOVE.B  #' ',(A0)+
000016A0  6000 FA54                510              BRA     endOP
000016A4  6100 038C                511  isBCS       BSR     outaddress      *prints current address
000016A8  10FC 0042                512              MOVE.B  #'B',(A0)+
000016AC  10FC 0043                513              MOVE.B  #'C',(A0)+
000016B0  10FC 0053                514              MOVE.B  #'S',(A0)+
000016B4  10FC 0020                515              MOVE.B  #' ',(A0)+
000016B8  6000 FA3C                516              BRA     endOP
000016BC  6100 0374                517  isBGE       BSR     outaddress      *prints current address
000016C0  10FC 0042                518              MOVE.B  #'B',(A0)+
000016C4  10FC 0047                519              MOVE.B  #'G',(A0)+
000016C8  10FC 0045                520              MOVE.B  #'E',(A0)+
000016CC  10FC 0020                521              MOVE.B  #' ',(A0)+
000016D0  6000 FA24                522              BRA     endOP
000016D4  6100 035C                523  isBLT       BSR     outaddress      *prints current address
000016D8  10FC 0042                524              MOVE.B  #'B',(A0)+
000016DC  10FC 004C                525              MOVE.B  #'L',(A0)+
000016E0  10FC 0054                526              MOVE.B  #'T',(A0)+
000016E4  10FC 0020                527              MOVE.B  #' ',(A0)+
000016E8  6000 FA0C                528              BRA     endOP
000016EC  6100 0344                529  isBVC       BSR     outaddress      *prints current address
000016F0  10FC 0042                530              MOVE.B  #'B',(A0)+
000016F4  10FC 0056                531              MOVE.B  #'V',(A0)+
000016F8  10FC 0043                532              MOVE.B  #'C',(A0)+
000016FC  10FC 0020                533              MOVE.B  #' ',(A0)+
00001700  6000 F9F4                534              BRA     endOP
00001704  6100 032C                535  isBRA       BSR     outaddress      *prints current address
00001708  10FC 0042                536              MOVE.B  #'B',(A0)+
0000170C  10FC 0052                537              MOVE.B  #'R',(A0)+
00001710  10FC 0041                538              MOVE.B  #'A',(A0)+
00001714  10FC 0020                539              MOVE.B  #' ',(A0)+
00001718  6000 F9DC                540              BRA     endOP
0000171C  6100 0314                541  isJSR       BSR     outaddress      *prints current address
00001720  10FC 004A                542              MOVE.B  #'J',(A0)+
00001724  10FC 0053                543              MOVE.B  #'S',(A0)+
00001728  10FC 0052                544              MOVE.B  #'R',(A0)+
0000172C  10FC 0020                545              MOVE.B  #' ',(A0)+
00001730  6000 F9C4                546              BRA     endOP
00001734  6100 02FC                547  isRTS       BSR     outaddress      *prints current address
00001738  10FC 0052                548              MOVE.B  #'R',(A0)+
0000173C  10FC 0054                549              MOVE.B  #'T',(A0)+
00001740  10FC 0053                550              MOVE.B  #'S',(A0)+
00001744  10FC 0020                551              MOVE.B  #' ',(A0)+
00001748  6000 F9AC                552              BRA     endOP
0000174C                           553  isNEG       
0000174C  6100 02E4                554              BSR     outaddress      *prints current address
00001750  10FC 004E                555              MOVE.B  #'N',(A0)+
00001754  10FC 0045                556              MOVE.B  #'E',(A0)+
00001758  10FC 0047                557              MOVE.B  #'G',(A0)+
0000175C  10FC 0020                558              MOVE.B  #' ',(A0)+
00001760  6100 044C                559              BSR     EA_NEG
00001764  6000 F990                560              BRA     endOP
00001768                           561  
00001768                           562  isLEA 
00001768  6100 02C8                563              BSR     outaddress      *prints current address
0000176C  10FC 004C                564              MOVE.B  #'L', (A0)+
00001770  10FC 0045                565              MOVE.B  #'E', (A0)+
00001774  10FC 0041                566              MOVE.B  #'A', (A0)+
00001778  10FC 0020                567              MOVE.B  #' ', (A0)+
0000177C  544D                     568              ADDQ    #byte,A5
0000177E  544D                     569              ADDQ    #byte,A5         *increments our program counter twice, LEA incomplete
00001780  6000 F974                570              BRA     endOP
00001784                           571  
00001784                           572  *Converts string user input at A1 to HEX
00001784                           573  *D1 is length of string, D2 is completed HEX, which will be returned to caller in D1
00001784                           574  strToHex
00001784  B23C 0000                575              CMP.B   #0,D1           *Compares length of string to 0
00001788  6F00 00BC                576              BLE     endStrToHex     *Go to return line if string is less than 0
0000178C  E94A                     577              LSL     #4,D2
0000178E  5341                     578              SUB     #1,D1           *Decrements D1
00001790                           579  strToHexLoop 
00001790  1619                     580              MOVE.B  (A1)+,D3        *Uses D3 as temp variable
00001792  B63C 0030                581              CMP.B   #48,D3          *Checks if 0
00001796  6700 00B6                582              BEQ     is0
0000179A  B63C 0031                583              CMP.B   #49,D3          *Checks if 1
0000179E  6700 00B6                584              BEQ     is1
000017A2  B63C 0032                585              CMP.B   #50,D3          *Checks if 2
000017A6  6700 00B4                586              BEQ     is2
000017AA  B63C 0033                587              CMP.B   #51,D3          *Checks if 3
000017AE  6700 00B2                588              BEQ     is3
000017B2  B63C 0034                589              CMP.B   #52,D3          *Checks if 4
000017B6  6700 00B0                590              BEQ     is4
000017BA  B63C 0035                591              CMP.B   #53,D3          *Checks if 5
000017BE  6700 00AE                592              BEQ     is5
000017C2  B63C 0036                593              CMP.B   #54,D3          *Checks if 6
000017C6  6700 00AC                594              BEQ     is6
000017CA  B63C 0037                595              CMP.B   #55,D3          *Checks if 7
000017CE  6700 00AA                596              BEQ     is7
000017D2  B63C 0038                597              CMP.B   #56,D3          *Checks if 8
000017D6  6700 00A8                598              BEQ     is8
000017DA  B63C 0039                599              CMP.B   #57,D3          *Checks if 9
000017DE  6700 00A6                600              BEQ     is9
000017E2  B63C 0041                601              CMP.B   #65,D3          *Checks if A
000017E6  6700 00A6                602              BEQ     isA
000017EA  B63C 0061                603              CMP.B   #97,D3          *Checks if a
000017EE  6700 009E                604              BEQ     isA
000017F2  B63C 0042                605              CMP.B   #66,D3          *Checks if B
000017F6  6700 009E                606              BEQ     isB
000017FA  B63C 0062                607              CMP.B   #98,D3          *Checks if b
000017FE  6700 0096                608              BEQ     isB
00001802  B63C 0043                609              CMP.B   #67,D3          *Checks if C
00001806  6700 0096                610              BEQ     isC
0000180A  B63C 0063                611              CMP.B   #99,D3          *Checks if c
0000180E  6700 008E                612              BEQ     isC
00001812  B63C 0044                613              CMP.B   #68,D3          *Checks if D
00001816  6700 008E                614              BEQ     isD
0000181A  B63C 0064                615              CMP.B   #100,D3         *Checks if d
0000181E  6700 0086                616              BEQ     isD
00001822  B63C 0045                617              CMP.B   #69,D3          *Checks if E
00001826  6700 0086                618              BEQ     isE
0000182A  B63C 0065                619              CMP.B   #101,D3         *Checks if e
0000182E  6700 007E                620              BEQ     isE
00001832  B63C 0046                621              CMP.B   #70,D3          *Checks if F
00001836  6700 007E                622              BEQ     isF
0000183A  B63C 0066                623              CMP.B   #102,D3         *Checks if f
0000183E  6700 0076                624              BEQ     isF
00001842  6000 007A                625              BRA     invalidAddress  *Invalid address entered
00001846  2202                     626  endStrToHex MOVE.L  D2,D1           *Moves D2 to D1 for returning
00001848  4282                     627              CLR.L   D2
0000184A  4283                     628              CLR.L   D3              *Clears D2 and D3
0000184C  4E75                     629              RTS
0000184E                           630  
0000184E  0602 0000                631  is0         ADD.B   #$0,D2
00001852  6000 FF30                632              BRA     strToHex
00001856  5202                     633  is1         ADD.B   #$1,D2
00001858  6000 FF2A                634              BRA     strToHex
0000185C  5402                     635  is2         ADD.B   #$2,D2
0000185E  6000 FF24                636              BRA     strToHex
00001862  5602                     637  is3         ADD.B   #$3,D2
00001864  6000 FF1E                638              BRA     strToHex
00001868  5802                     639  is4         ADD.B   #$4,D2
0000186A  6000 FF18                640              BRA     strToHex
0000186E  5A02                     641  is5         ADD.B   #$5,D2
00001870  6000 FF12                642              BRA     strToHex
00001874  5C02                     643  is6         ADD.B   #$6,D2
00001876  6000 FF0C                644              BRA     strToHex
0000187A  5E02                     645  is7         ADD.B   #$7,D2
0000187C  6000 FF06                646              BRA     strToHex
00001880  5002                     647  is8         ADD.B   #$8,D2
00001882  6000 FF00                648              BRA     strToHex
00001886  0602 0009                649  is9         ADD.B   #$9,D2
0000188A  6000 FEF8                650              BRA     strToHex
0000188E  0602 000A                651  isA         ADD.B   #$A,D2
00001892  6000 FEF0                652              BRA     strToHex
00001896  0602 000B                653  isB         ADD.B   #$B,D2
0000189A  6000 FEE8                654              BRA     strToHex
0000189E  0602 000C                655  isC         ADD.B   #$C,D2
000018A2  6000 FEE0                656              BRA     strToHex
000018A6  0602 000D                657  isD         ADD.B   #$D,D2
000018AA  6000 FED8                658              BRA     strToHex
000018AE  0602 000E                659  isE         ADD.B   #$E,D2
000018B2  6000 FED0                660              BRA     strToHex
000018B6  0602 000F                661  isF         ADD.B   #$F,D2
000018BA  6000 FEC8                662              BRA     strToHex
000018BE                           663  
000018BE                           664  invalidAddress
000018BE  43F9 0000240C            665              LEA     invalidStr,A1   *Loads string
000018C4  103C 000D                666              MOVE.B  #13,D0          *Sets up trap
000018C8  4E4F                     667              TRAP    #15
000018CA  6000 F740                668              BRA     enterStart
000018CE                           669  
000018CE                           670  *Keeps track of the number of lines on the page
000018CE                           671  lineCounter
000018CE  0C40 0014                672              CMPI.W  #pageLength,D0  *Compares count to pageLength
000018D2  6E00 0006                673              BGT     pauseProgram    *Pause program
000018D6  5240                     674              ADDQ    #1,D0           *If not at pageLength, increment counter
000018D8                           675  pauseReturn 
000018D8  4E75                     676              RTS
000018DA                           677  pauseProgram
000018DA  43F9 0000241A            678              LEA     enterToContinue,A1  *Loads message into A1
000018E0  103C 000E                679              MOVE.B  #14,D0              *Prints message
000018E4  4E4F                     680              TRAP    #15
000018E6  103C 0004                681              MOVE.B  #4,D0
000018EA  4E4F                     682              TRAP    #15                 *Pauses by waiting for integer input
000018EC  4281                     683              CLR.L   D1                  *Clears input, because we don't really care about it
000018EE  103C 0000                684              MOVE.B  #0,D0               *resets line counter to 0
000018F2  60E4                     685              BRA     pauseReturn
000018F4                           686  *Input: size bits on D3
000018F4                           687  *Prints size to stack
000018F4                           688  *Returns size (1=byte, 2=word, 3=long) on D4
000018F4                           689  *Returns mode (1=source, 2=destination) on D5
000018F4                           690  checkSize
000018F4  B67C 0000                691              CMP.W   #%000,D3        *Compares size bits and calls proper function
000018F8  6700 005C                692              BEQ     Size000
000018FC                           693  
000018FC  B67C 0000                694              CMP.W   #%00,D3        *Compares size bits and calls proper function
00001900  6700 0062                695              BEQ     Size00
00001904                           696  
00001904  B67C 0001                697              CMP.W   #%01,D3        *Compares size bits and calls proper function
00001908  6700 0068                698              BEQ     Size01    
0000190C                           699  
0000190C  B67C 0002                700              CMP.W   #%10,D3        *Compares size bits and calls proper function
00001910  6700 006E                701              BEQ     Size10    
00001914                           702  
00001914  B67C 0003                703              CMP.W   #%11,D3        *Compares size bits and calls proper function
00001918  6700 0074                704              BEQ     Size11       
0000191C                           705  
0000191C  B67C 0001                706              CMP.W   #%001,D3
00001920  6700 007A                707              BEQ     Size001
00001924                           708  
00001924  B67C 0002                709              CMP.W   #%010,D3
00001928  6700 0080                710              BEQ     Size010
0000192C                           711  
0000192C  B67C 0004                712              CMP.W   #%100,D3
00001930  6700 0086                713              BEQ     Size100
00001934                           714  
00001934  B67C 0005                715              CMP.W   #%101,D3
00001938  6700 008C                716              BEQ     Size101
0000193C                           717  
0000193C  B67C 0006                718              CMP.W   #%110,D3
00001940  6700 0092                719              BEQ     Size110
00001944                           720  
00001944  B67C 0003                721              CMP.W   #%011,D3
00001948  6700 0098                722              BEQ     Size011
0000194C                           723  
0000194C  B67C 0007                724              CMP.W   #%111,D3
00001950  6700 009C                725              BEQ     Size111
00001954                           726  
00001954  4E75                     727              RTS
00001956                           728  
00001956                           729  
00001956  10FC 0042                730  Size000     MOVE.B  #'B',(A0)+      *prints size to stack and moves return data to D4,D5   
0000195A  183C 0001                731              MOVE.B  #1,D4
0000195E  1A3C 0001                732              MOVE.B  #1,D5
00001962  4E75                     733              RTS
00001964                           734  
00001964  10FC 0042                735  Size00      MOVE.B  #'B',(A0)+   
00001968  183C 0001                736              MOVE.B  #1,D4
0000196C  1A3C 0001                737              MOVE.B  #1,D5
00001970  4E75                     738              RTS
00001972                           739  
00001972  10FC 0057                740  Size01      MOVE.B  #'W',(A0)+   
00001976  183C 0002                741              MOVE.B  #2,D4
0000197A  1A3C 0001                742              MOVE.B  #1,D5
0000197E  4E75                     743              RTS
00001980                           744  
00001980  10FC 004C                745  Size10      MOVE.B  #'L',(A0)+   
00001984  183C 0003                746              MOVE.B  #3,D4
00001988  1A3C 0001                747              MOVE.B  #1,D5
0000198C  4E75                     748              RTS
0000198E                           749  
0000198E  10FC 0057                750  Size11      MOVE.B  #'W',(A0)+   
00001992  183C 0002                751              MOVE.B  #2,D4
00001996  1A3C 0001                752              MOVE.B  #1,D5
0000199A  4E75                     753              RTS
0000199C                           754  
0000199C                           755  
0000199C  10FC 0057                756  Size001     MOVE.B  #'W',(A0)+
000019A0  183C 0002                757              MOVE.B  #2,D4
000019A4  1A3C 0001                758              MOVE.B  #1,D5
000019A8  4E75                     759              RTS
000019AA                           760  
000019AA  10FC 004C                761  Size010     MOVE.B  #'L',(A0)+
000019AE  183C 0003                762              MOVE.B  #3,D4
000019B2  1A3C 0001                763              MOVE.B  #1,D5
000019B6  4E75                     764              RTS
000019B8                           765  
000019B8  10FC 0042                766  Size100     MOVE.B  #'B',(A0)+
000019BC  183C 0001                767              MOVE.B  #1,D4
000019C0  1A3C 0002                768              MOVE.B  #2,D5
000019C4  4E75                     769              RTS
000019C6                           770  
000019C6  10FC 0057                771  Size101     MOVE.B  #'W',(A0)+
000019CA  183C 0002                772              MOVE.B  #2,D4
000019CE  1A3C 0002                773              MOVE.B  #2,D5
000019D2  4E75                     774              RTS
000019D4                           775  
000019D4  10FC 004C                776  Size110     MOVE.B  #'L',(A0)+
000019D8  183C 0003                777              MOVE.B  #3,D4
000019DC  1A3C 0002                778              MOVE.B  #2,D5
000019E0  4E75                     779              RTS
000019E2                           780  
000019E2  10FC 0057                781  Size011     MOVE.B  #'W',(A0)+
000019E6  183C 0002                782              MOVE.B  #2,D4
000019EA  1A3C 0001                783              MOVE.B  #1,D5
000019EE                           784  
000019EE  10FC 0057                785  Size111     MOVE.B  #'W',(A0)+
000019F2  183C 0003                786              MOVE.B  #3,D4
000019F6  1A3C 0001                787              MOVE.B  #1,D5
000019FA                           788  
000019FA                           789  *Masks to make comparisons easier
000019FA  3400                     790  compMask    MOVE.W  D0,D2           *Gets fresh copy of D0
000019FC  0242 F1C0                791              ANDI.W  #opMask,D2      *Masks D2 for rest of comparisons
00001A00  4E75                     792              RTS
00001A02  3400                     793  mask15to8   MOVE.W  D0,D2               *Gets fresh copy of D0
00001A04  0242 FF00                794              ANDI.W  #BitMask15to8,D2    *Masks D2 for the first byte
00001A08  4E75                     795              RTS
00001A0A  3400                     796  mask15to12  MOVE.W  D0,D2               *Gets fresh copy of D0
00001A0C  0242 F000                797              ANDI.W  #BitMask15to12,D2   *Masks first bit
00001A10  4E75                     798              RTS
00001A12  3400                     799  mask15to7   MOVE.W  D0,D2               *Gets fresh copy of D0
00001A14  0242 FF80                800              ANDI.W  #BitMask15to7,D2    *Masks D2
00001A18  4E75                     801              RTS
00001A1A  3400                     802  mask15to6   MOVE.W  D0,D2               *Gets fresh copy of D0
00001A1C  0242 FFC0                803              ANDI.W  #BitMask15to6,D2    *Masks D2
00001A20  4E75                     804              RTS
00001A22  3400                     805  maskMulDivl MOVE.W  D0,D2               *Gets fresh copy of D0
00001A24  0242 8BC0                806              ANDI.W  #BitMaskMulDivl,D2  *Masks D2
00001A28  4E75                     807              RTS
00001A2A  3400                     808  maskShift   MOVE.W  D0,D2               *Gets a fresh copy of D0
00001A2C  0242 F118                809              ANDI.W  #BitMaskShifts,D2   *Masks D2
00001A30  4E75                     810              RTS
00001A32                           811              
00001A32                           812  *prints address
00001A32  3F00                     813  outaddress  MOVE.W  D0,-(sp)        *Saves D0
00001A34  3F02                     814              MOVE.W  D2,-(sp)        *Saves D2
00001A36  340D                     815              MOVE.W  A5,D2           *Moves current address to D2
00001A38  6100 0032                816              BSR     n2ascii         *prints current address
00001A3C  341F                     817              MOVE.W  (sp)+,D2        *Loads D2
00001A3E  1239 00002384            818              MOVE.B  space,D1        *Loads ascii space in D1
00001A44  103C 0006                819              MOVE.B  #6,D0           *Sets up trap
00001A48  4E4F                     820              TRAP    #15
00001A4A  301F                     821              MOVE.W  (sp)+,D0        *Loads D0
00001A4C  4E75                     822              RTS
00001A4E                           823              
00001A4E                           824  *prints word 'DATA '            
00001A4E  43F9 00002433            825  isData      LEA     datastring,A1   *Loads datastring for printing
00001A54  103C 000E                826              MOVE.B  #14,D0          *Sets up Trap
00001A58  4E4F                     827              TRAP    #15
00001A5A                           828  *prints the data
00001A5A  6100 0010                829              BSR     n2ascii         *Prints out the data
00001A5E  43F9 00002385            830              LEA     newline,A1      *Sets up trap for new line
00001A64  103C 000E                831              MOVE.B  #14,D0
00001A68  4E4F                     832              TRAP    #15
00001A6A  4E75                     833              RTS
00001A6C                           834  **************************************************
00001A6C                           835  *Takes the word hex in D2 and prints it to screen*
00001A6C                           836  **************************************************
00001A6C                           837  
00001A6C  183C 000C                838  n2ascii     MOVE.B  #12,D4          *Sets up D4 as counter.
00001A70  3602                     839  n2ascii2    MOVE.W  D2,D3           *Moves to D3 to work on there 
00001A72  E86B                     840              LSR.W   D4,D3           
00001A74  0243 000F                841              ANDI.W  #$000F,D3       *Masks to check last nibble
00001A78  B63C 0000                842              CMP.B   #$0,D3          *Chekcs if D3 is equal to 0
00001A7C  6700 0086                843              BEQ     print0
00001A80  B63C 0001                844              CMP.B   #$1,D3          *Chekcs if D3 is equal to 1
00001A84  6700 0088                845              BEQ     print1
00001A88  B63C 0002                846              CMP.B   #$2,D3          *Chekcs if D3 is equal to 2
00001A8C  6700 008A                847              BEQ     print2
00001A90  B63C 0003                848              CMP.B   #$3,D3          *Chekcs if D3 is equal to 3
00001A94  6700 008C                849              BEQ     print3
00001A98  B63C 0004                850              CMP.B   #$4,D3          *Chekcs if D3 is equal to 4
00001A9C  6700 008E                851              BEQ     print4
00001AA0  B63C 0005                852              CMP.B   #$5,D3          *Chekcs if D3 is equal to 5
00001AA4  6700 0090                853              BEQ     print5
00001AA8  B63C 0006                854              CMP.B   #$6,D3          *Chekcs if D3 is equal to 6
00001AAC  6700 0092                855              BEQ     print6
00001AB0  B63C 0007                856              CMP.B   #$7,D3          *Chekcs if D3 is equal to 7
00001AB4  6700 0094                857              BEQ     print7
00001AB8  B63C 0008                858              CMP.B   #$8,D3          *Chekcs if D3 is equal to 8
00001ABC  6700 0096                859              BEQ     print8
00001AC0  B63C 0009                860              CMP.B   #$9,D3          *Chekcs if D3 is equal to 9
00001AC4  6700 0098                861              BEQ     print9
00001AC8  B63C 000A                862              CMP.B   #$A,D3          *Chekcs if D3 is equal to A
00001ACC  6700 009A                863              BEQ     printA
00001AD0  B63C 000B                864              CMP.B   #$B,D3          *Chekcs if D3 is equal to B
00001AD4  6700 009C                865              BEQ     printB
00001AD8  B63C 000C                866              CMP.B   #$C,D3          *Chekcs if D3 is equal to C
00001ADC  6700 009E                867              BEQ     printC
00001AE0  B63C 000D                868              CMP.B   #$D,D3          *Chekcs if D3 is equal to D
00001AE4  6700 00A0                869              BEQ     printD
00001AE8  B63C 000E                870              CMP.B   #$E,D3          *Chekcs if D3 is equal to E
00001AEC  6700 00A2                871              BEQ     printE
00001AF0  B63C 000F                872              CMP.B   #$F,D3          *Checks if D3 is equal to F
00001AF4  6700 00A4                873              BEQ     printF
00001AF8  5904                     874  n2acheck    SUB.B   #4,D4           *Decrements our counter
00001AFA  B83C 0000                875              CMP.B   #0,D4           *Checks if counter reached 0
00001AFE  6C00 FF70                876              BGE     n2ascii2        *Returns to top of loop to continue        
00001B02  4E75                     877              RTS                     *Else return to caller
00001B04                           878  
00001B04  4281                     879  print0      CLR.L   D1              *Clears D1
00001B06  123C 0030                880              MOVE.B  #$30,D1         *Sets D1 as ascii 0
00001B0A  6000 0098                881              BRA     printchar       *prints the character
00001B0E  4281                     882  print1      CLR.L   D1              *Clears D1
00001B10  123C 0031                883              MOVE.B  #$31,D1         *Sets D1 as ascii 1
00001B14  6000 008E                884              BRA     printchar       *prints the character
00001B18  4281                     885  print2      CLR.L   D1              *Clears D1
00001B1A  123C 0032                886              MOVE.B  #$32,D1         *Sets D1 as ascii 2
00001B1E  6000 0084                887              BRA     printchar       *prints the character
00001B22  4281                     888  print3      CLR.L   D1              *Clears D1
00001B24  123C 0033                889              MOVE.B  #$33,D1         *Sets D1 as ascii 3
00001B28  6000 007A                890              BRA     printchar       *prints the character
00001B2C  4281                     891  print4      CLR.L   D1              *Clears D1
00001B2E  123C 0034                892              MOVE.B  #$34,D1         *Sets D1 as ascii 4
00001B32  6000 0070                893              BRA     printchar       *prints the character
00001B36  4281                     894  print5      CLR.L   D1              *Clears D1
00001B38  123C 0035                895              MOVE.B  #$35,D1         *Sets D1 as ascii 5
00001B3C  6000 0066                896              BRA     printchar       *prints the character
00001B40  4281                     897  print6      CLR.L   D1              *Clears D1
00001B42  123C 0036                898              MOVE.B  #$36,D1         *Sets D1 as ascii 6
00001B46  6000 005C                899              BRA     printchar       *prints the character
00001B4A  4281                     900  print7      CLR.L   D1              *Clears D1
00001B4C  123C 0037                901              MOVE.B  #$37,D1         *Sets D1 as ascii 7
00001B50  6000 0052                902              BRA     printchar       *prints the character
00001B54  4281                     903  print8      CLR.L   D1              *Clears D1
00001B56  123C 0038                904              MOVE.B  #$38,D1         *Sets D1 as ascii 8
00001B5A  6000 0048                905              BRA     printchar       *prints the character
00001B5E  4281                     906  print9      CLR.L   D1              *Clears D1
00001B60  123C 0039                907              MOVE.B  #$39,D1         *Sets D1 as ascii 9
00001B64  6000 003E                908              BRA     printchar       *prints the character
00001B68  4281                     909  printA      CLR.L   D1              *Clears D1
00001B6A  123C 0041                910              MOVE.B  #$41,D1         *Sets D1 as ascii A
00001B6E  6000 0034                911              BRA     printchar       *prints the character
00001B72  4281                     912  printB      CLR.L   D1              *Clears D1
00001B74  123C 0042                913              MOVE.B  #$42,D1         *Sets D1 as ascii B
00001B78  6000 002A                914              BRA     printchar       *prints the character
00001B7C  4281                     915  printC      CLR.L   D1              *Clears D1
00001B7E  123C 0043                916              MOVE.B  #$43,D1         *Sets D1 as ascii C
00001B82  6000 0020                917              BRA     printchar       *prints the character
00001B86  4281                     918  printD      CLR.L   D1              *Clears D1
00001B88  123C 0044                919              MOVE.B  #$44,D1         *Sets D1 as ascii D
00001B8C  6000 0016                920              BRA     printchar       *prints the character
00001B90  4281                     921  printE      CLR.L   D1              *Clears D1
00001B92  123C 0045                922              MOVE.B  #$45,D1         *Sets D1 as ascii E
00001B96  6000 000C                923              BRA     printchar       *prints the character         
00001B9A  4281                     924  printF      CLR.L   D1              *Clears D1
00001B9C  123C 0046                925              MOVE.B  #$46,D1         *Sets D1 as ascii F
00001BA0  6000 0002                926              BRA     printchar       *prints the character
00001BA4  103C 0006                927  printchar   MOVE.B  #6,D0           *Sets up Trap
00001BA8  4E4F                     928              TRAP    #15
00001BAA  6000 FF4C                929              BRA     n2acheck        *returns to n2ascii
00001BAE                           930  
00001BAE                           931  *EA FUNCTIONS:
00001BAE                           932  *D0 is assumed to be input line
00001BAE                           933  *Using D2 to store Addressing Mode
00001BAE                           934  *Using D3 to store Register
00001BAE                           935  *Using D7 to store return values
00001BAE                           936  
00001BAE                           937  *Input: D0 (Input Line)
00001BAE                           938  EA_NEG                              ;Parsing EA for NEG function
00001BAE                           939  
00001BAE  6100 094C                940        BSR         BitMask3to5       ;isolating destination address mode
00001BB2  2407                     941        MOVE.L      D7,D2             ;moving return value to D2
00001BB4                           942  
00001BB4  6100 0952                943        BSR         BitMask0to2       ;isloating destination address register
00001BB8  2607                     944        MOVE.L      D7,D3             ;Moving return value to D3
00001BBA                           945  
00001BBA  B4BC 00000001            946        CMP.L       #%001,D2           ;Address register direct is not a valid input for NEG
00001BC0  6700 07BE                947        BEQ         ERROR
00001BC4                           948  
00001BC4  B47C 0007                949        CMP.W       #%111,D2          ;Immediate Data is not a valid EA mode
00001BC8  6700 0796                950        BEQ         EA_BlOCK_IMMEDIATE
00001BCC                           951  
00001BCC  6100 050E                952        BSR         EA_PARSE_MODE     ;Calling parse mode function to write data to the stack
00001BD0                           953  
00001BD0  4E75                     954        RTS                           ;Returning to source
00001BD2                           955  
00001BD2                           956  *Input: D0 (Input Line)
00001BD2                           957  EA_EOR                              ;Parsing EA for EOR function
00001BD2  6100 08FC                958        BSR         BitMask9to11      ;isolating source register
00001BD6  2607                     959        MOVE.L      D7,D3             ;moving result to D3
00001BD8  6100 054E                960        BSR         EA_PARSE_Dn       ;printing data register to A0 stack
00001BDC                           961  
00001BDC  10F8 002C                962        MOVE.B      ',',(A0)+         ;pushing ", " to the stack.
00001BE0  10F8 0020                963        MOVE.B      ' ',(A0)+
00001BE4                           964  
00001BE4  6100 0916                965        BSR         BitMask3to5       ;isolating destination address mode
00001BE8  2407                     966        MOVE.L      D7,D2             ;moving return value to D2
00001BEA                           967  
00001BEA  6100 091C                968        BSR         BitMask0to2       ;isloating destination address register
00001BEE  2607                     969        MOVE.L      D7,D3             ;Moving return value to D3
00001BF0                           970  
00001BF0  B4BC 00000001            971        CMP.L       #%001,D2          ;Address register direct is not a valid input for EOR
00001BF6  6700 0788                972        BEQ         ERROR
00001BFA                           973  
00001BFA  6100 04E0                974        BSR         EA_PARSE_MODE     ;Calling parse mode function to write data to the stack
00001BFE                           975  
00001BFE  4E75                     976        RTS                           ;Returning to source
00001C00                           977  
00001C00                           978  *Input: D0 (Input Line)
00001C00                           979  EA_ADDA                              ;Parsing EA for ADDA function
00001C00                           980  
00001C00                           981  
00001C00  6100 08FA                982        BSR         BitMask3to5       ;isolating destination address mode
00001C04  2407                     983        MOVE.L      D7,D2             ;moving return value to D2
00001C06                           984  
00001C06  6100 0900                985        BSR         BitMask0to2       ;isloating destination address register
00001C0A  2607                     986        MOVE.L      D7,D3             ;Moving return value to D3
00001C0C                           987  
00001C0C  6100 04CE                988        BSR         EA_PARSE_MODE     ;Calling parse mode function to write data to the stack
00001C10                           989  
00001C10  10F8 002C                990        MOVE.B      ',',(A0)+         ;pushing ", " to the stack.
00001C14  10F8 0020                991        MOVE.B      ' ',(A0)+
00001C18                           992  
00001C18  6100 08B6                993        BSR         BitMask9to11      ;isolating source register
00001C1C  2607                     994        MOVE.L      D7,D3             ;moving result to D3
00001C1E  6100 0514                995        BSR         EA_PARSE_An       ;printing data register to A0 stack
00001C22                           996  
00001C22  4E75                     997        RTS                           ;Returning to source
00001C24                           998  
00001C24                           999  
00001C24                          1000  *Input: D0 (input Line)
00001C24                          1001  *Input: D5 (OPMOde type (1 or 2))
00001C24                          1002  EA_OR                               ;Parsing EA for OR function
00001C24  1205                    1003        MOVE.B      D5,D1             ;moving input opmode type to D1
00001C26  4285                    1004        CLR.L       D5                ;clearing D5
00001C28                          1005  
00001C28  6100 08B6               1006        BSR         BitMask6to8       ;isolating register number
00001C2C  2A07                    1007        MOVE.L      D7,D5             ;moving return value to D5
00001C2E                          1008  
00001C2E  6100 08CC               1009        BSR         BitMask3to5       ;isolating destination address mode
00001C32  2407                    1010        MOVE.L      D7,D2             ;moving return value to D2
00001C34                          1011  
00001C34  6100 08D2               1012        BSR         BitMask0to2       ;isloating destination address register
00001C38  2607                    1013        MOVE.L      D7,D3             ;Moving return value to D3
00001C3A                          1014  
00001C3A  B23C 0001               1015        CMP.B       #1,D1             ;if the OPMode is type 1, the EA is the source
00001C3E  6700 0010               1016        BEQ         EA_OR_SOURCE      
00001C42                          1017  
00001C42  B23C 0002               1018        CMP.B       #2,D1             ;if the OPMode is type 2, the EA is the destination
00001C46  6700 0008               1019        BEQ         EA_OR_SOURCE
00001C4A                          1020  
00001C4A  10FC 0000               1021        MOVE.B      #0,(A0)+          ;Terminating character
00001C4E                          1022  
00001C4E  4E75                    1023        RTS                           ;Returning to source
00001C50                          1024  
00001C50                          1025  *Called if the EA address field is a source operand
00001C50                          1026  EA_OR_SOURCE
00001C50  B4BC 00000001           1027        CMP.L       #%001,D2           ;Address register direct is not a valid input for EA Source
00001C56  6700 0728               1028        BEQ         ERROR
00001C5A                          1029  
00001C5A  6100 0480               1030        BSR         EA_PARSE_MODE     ;outputing the source EA
00001C5E                          1031  
00001C5E  10FC 002C               1032        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001C62  10FC 0020               1033        MOVE.B      #' ',(A0)+
00001C66                          1034  
00001C66  2605                    1035        MOVE.L      D5,D3             ;Moving register number to D3
00001C68  6100 04BE               1036        BSR         EA_PARSE_Dn       ;Outputting register
00001C6C                          1037  
00001C6C  4E75                    1038        RTS
00001C6E                          1039  
00001C6E                          1040  *Called if the EA address field is a destinaton operand
00001C6E                          1041  EA_OR_DESTINATION
00001C6E  B4BC 00000000           1042        CMP.L       #%000,D2           ;Data register direct is not a valid input for EA Source
00001C74  6700 070A               1043        BEQ         ERROR
00001C78                          1044  
00001C78  B4BC 00000001           1045        CMP.L       #%001,D2           ;Address register direct is not a valid input for EA Source
00001C7E  6700 0700               1046        BEQ         ERROR
00001C82                          1047  
00001C82  2C03                    1048        MOVE.L      D3,D6             ;backing up EA register to D6
00001C84  2605                    1049        MOVE.L      D5,D3             ;Moving register number to D3
00001C86  6100 04A0               1050        BSR         EA_PARSE_Dn       ;Outputting register
00001C8A                          1051  
00001C8A  10FC 002C               1052        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001C8E  10FC 0020               1053        MOVE.B      #' ',(A0)+
00001C92                          1054  
00001C92  2606                    1055        MOVE.L      D6,D3             ;Moving EA register back
00001C94  6100 0446               1056        BSR         EA_PARSE_MODE     ;outputing the destination EA
00001C98                          1057  
00001C98                          1058  
00001C98  4E75                    1059        RTS
00001C9A                          1060  
00001C9A                          1061  
00001C9A                          1062  *Input: D0 (Input Line)
00001C9A                          1063  *Input: D1 (immediate data source)
00001C9A                          1064  EA_ORI                              ;Parsing EA for ORI function
00001C9A                          1065  
00001C9A  6100 04E8               1066        BSR         EA_PARSE_IMMEDIATE_DATA  ;displays immediate data
00001C9E                          1067  
00001C9E  10FC 002C               1068        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001CA2  10FC 0020               1069        MOVE.B      #' ',(A0)+
00001CA6                          1070  
00001CA6  6100 0854               1071        BSR         BitMask3to5       ;isolating destination address mode
00001CAA  2407                    1072        MOVE.L      D7,D2             ;moving return value to D2
00001CAC                          1073  
00001CAC  6100 085A               1074        BSR         BitMask0to2       ;isloating destination address register
00001CB0  2607                    1075        MOVE.L      D7,D3             ;Moving return value to D3
00001CB2                          1076  
00001CB2  6100 04D0               1077        BSR         EA_PARSE_IMMEDIATE_DATA  ;parsing immediate data
00001CB6                          1078  
00001CB6  10FC 002C               1079        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001CBA  10FC 0020               1080        MOVE.B      #' ',(A0)+
00001CBE                          1081  
00001CBE  B4BC 00000001           1082        CMP.L       #%001,D2           ;Address register direct is not a valid input for ORI
00001CC4  6700 06BA               1083        BEQ         ERROR
00001CC8                          1084  
00001CC8  B47C 0007               1085        CMP.W       #%111,D2          ;Immediate Data is not a valid EA mode
00001CCC  6700 0692               1086        BEQ         EA_BlOCK_IMMEDIATE
00001CD0                          1087  
00001CD0  6100 040A               1088        BSR         EA_PARSE_MODE     ;Calling parse mode function to write data to the stack
00001CD4                          1089  
00001CD4  4E75                    1090        RTS                           ;Returning to source
00001CD6                          1091  
00001CD6                          1092  
00001CD6                          1093  *Input: D0 (input Line)
00001CD6                          1094  *Input: D5 (OPMOde type (1 or 2))
00001CD6                          1095  EA_AND                              ;Parsing EA for AND function
00001CD6  1205                    1096        MOVE.B      D5,D1             ;moving input opmode type to D1
00001CD8  4285                    1097        CLR.L       D5                ;clearing D5
00001CDA                          1098  
00001CDA  6100 07F4               1099        BSR         BitMask9to11      ;isolating register number
00001CDE  2A07                    1100        MOVE.L      D7,D5             ;moving return value to D5
00001CE0                          1101  
00001CE0  6100 081A               1102        BSR         BitMask3to5       ;isolating destination address mode
00001CE4  2407                    1103        MOVE.L      D7,D2             ;moving return value to D2
00001CE6                          1104  
00001CE6  6100 0820               1105        BSR         BitMask0to2       ;isloating destination address register
00001CEA  2607                    1106        MOVE.L      D7,D3             ;Moving return value to D3
00001CEC                          1107  
00001CEC  B23C 0001               1108        CMP.B       #1,D1             ;if the OPMode is type 1, the EA is the source
00001CF0  6700 000C               1109        BEQ         EA_AND_SOURCE      
00001CF4                          1110  
00001CF4  B23C 0002               1111        CMP.B       #2,D1             ;if the OPMode is type 2, the EA is the destination
00001CF8  6700 0004               1112        BEQ         EA_AND_SOURCE
00001CFC                          1113  
00001CFC  4E75                    1114        RTS                           ;Returning to source
00001CFE                          1115  
00001CFE                          1116  *Called if the EA address field is a source operand
00001CFE                          1117  EA_AND_SOURCE
00001CFE                          1118  
00001CFE  B4BC 00000001           1119        CMP.L       #%001,D2           ;Address register direct is not a valid input for EA source
00001D04  6700 067A               1120        BEQ         ERROR
00001D08                          1121  
00001D08  6100 03D2               1122        BSR         EA_PARSE_MODE     ;outputing the source EA
00001D0C                          1123  
00001D0C  10FC 002C               1124        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001D10  10FC 0020               1125        MOVE.B      #' ',(A0)+
00001D14                          1126  
00001D14  2605                    1127        MOVE.L      D5,D3             ;Moving register number to D3
00001D16  6100 0410               1128        BSR         EA_PARSE_Dn       ;Outputting register
00001D1A                          1129  
00001D1A  4E75                    1130        RTS
00001D1C                          1131  
00001D1C                          1132  *Called if the EA address field is a destinaton operand
00001D1C                          1133  EA_AND_DESTINATION
00001D1C  B4BC 00000000           1134        CMP.L       #%000,D2           ;Data register direct is not a valid input for EA destinaton
00001D22  6700 065C               1135        BEQ         ERROR
00001D26                          1136  
00001D26  B4BC 00000001           1137        CMP.L       #%001,D2           ;Address register direct is not a valid input for EA destinaton
00001D2C  6700 0652               1138        BEQ         ERROR
00001D30                          1139  
00001D30  2C03                    1140        MOVE.L      D3,D6             ;backing up EA register to D6
00001D32  2E05                    1141        MOVE.L      D5,D7             ;Moving register number to D3
00001D34  6100 03F2               1142        BSR         EA_PARSE_Dn       ;Outputting register
00001D38                          1143  
00001D38  10FC 002C               1144        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001D3C  10FC 0020               1145        MOVE.B      #' ',(A0)+
00001D40                          1146  
00001D40  2E06                    1147        MOVE.L      D6,D7             ;Moving EA register back
00001D42  6100 0398               1148        BSR         EA_PARSE_MODE     ;outputing the destination EA
00001D46                          1149  
00001D46                          1150  
00001D46  4E75                    1151        RTS
00001D48                          1152  
00001D48                          1153  EA_ANDI                             ;Parsing EA for ANDI function
00001D48                          1154  
00001D48  6100 07B2               1155        BSR         BitMask3to5       ;isolating destination address mode
00001D4C  2407                    1156        MOVE.L      D7,D2             ;moving return value to D2
00001D4E                          1157  
00001D4E  6100 07B8               1158        BSR         BitMask0to2       ;isloating destination address register
00001D52  2607                    1159        MOVE.L      D7,D3             ;Moving return value to D3
00001D54                          1160  
00001D54  6100 042E               1161        BSR         EA_PARSE_IMMEDIATE_DATA          
00001D58                          1162  
00001D58  10FC 002C               1163        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001D5C  10FC 0020               1164        MOVE.B      #' ',(A0)+
00001D60                          1165  
00001D60  B4BC 00000001           1166        CMP.L       #%001,D2           ;Address register direct is not a valid input for EA destinaton
00001D66  6700 0618               1167        BEQ         ERROR
00001D6A                          1168  
00001D6A  2E05                    1169        MOVE.L      D5,D7
00001D6C  6100 036E               1170        BSR         EA_PARSE_MODE       ;outputting Address register destination
00001D70                          1171  
00001D70  4E75                    1172        RTS                           ;Returning to source
00001D72                          1173  
00001D72                          1174  *Input: D0 (input Line)
00001D72                          1175  *Input: D5 (OPMOde type (1 or 2))
00001D72                          1176  *Input: D4 (Size (1,2, or 3))
00001D72                          1177  EA_SUB                              ;Parsing EA for AND function
00001D72  1205                    1178        MOVE.B      D5,D1             ;moving input opmode type to D1
00001D74  4285                    1179        CLR.L       D5                ;clearing D5
00001D76                          1180  
00001D76  1404                    1181        MOVE.B      D4,D2             ;moving input opmode type to D2
00001D78  4284                    1182        CLR.L       D4                ;clearing D4
00001D7A                          1183  
00001D7A  2802                    1184        MOVE.L      D2,D4             ;moving isbyte variable to D4
00001D7C                          1185  
00001D7C  6100 0752               1186        BSR         BitMask9to11      ;isolating register number
00001D80  2A07                    1187        MOVE.L      D7,D5             ;moving return value to D5
00001D82                          1188  
00001D82  6100 0778               1189        BSR         BitMask3to5       ;isolating destination address mode
00001D86  2407                    1190        MOVE.L      D7,D2             ;moving return value to D2
00001D88                          1191  
00001D88  6100 077E               1192        BSR         BitMask0to2       ;isloating destination address register
00001D8C  2607                    1193        MOVE.L      D7,D3             ;Moving return value to D3
00001D8E                          1194  
00001D8E  B23C 0001               1195        CMP.B       #1,D1             ;if the OPMode is type 1, the EA is the source
00001D92  6700 FF6A               1196        BEQ         EA_AND_SOURCE      
00001D96                          1197  
00001D96  B23C 0002               1198        CMP.B       #2,D1             ;if the OPMode is type 2, the EA is the destination
00001D9A  6700 FF62               1199        BEQ         EA_AND_SOURCE
00001D9E                          1200  
00001D9E  4E75                    1201        RTS                           ;Returning to source
00001DA0                          1202  
00001DA0                          1203  *Called if the EA address field is a source operand
00001DA0                          1204  EA_SUB_SOURCE
00001DA0                          1205  
00001DA0  B4BC 00000000           1206        CMP.L       #%000,D2           ;Address register direct is not a valid input for EA source if byte operation
00001DA6  6700 0016               1207        BEQ         EA_SUB_BYTE_CHECK  ;checking if it is a byte operation. if it is, branch to error
00001DAA                          1208  
00001DAA  6100 0330               1209        BSR         EA_PARSE_MODE     ;outputing the source EA
00001DAE                          1210  
00001DAE  10FC 002C               1211        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001DB2  10FC 0020               1212        MOVE.B      #' ',(A0)+
00001DB6                          1213  
00001DB6  2605                    1214        MOVE.L      D5,D3             ;Moving register number to D3
00001DB8  6100 036E               1215        BSR         EA_PARSE_Dn       ;Outputting register
00001DBC                          1216  
00001DBC  4E75                    1217        RTS
00001DBE                          1218  
00001DBE                          1219  EA_SUB_BYTE_CHECK
00001DBE  B8BC 00000001           1220        CMP.L       #1,D4             ;if it is a byte-operation
00001DC4  6700 05BA               1221        BEQ         ERROR
00001DC8  4E75                    1222        RTS
00001DCA                          1223  
00001DCA                          1224  
00001DCA                          1225  *Called if the EA address field is a destinaton operand
00001DCA                          1226  EA_SUB_DESTINATION
00001DCA  B4BC 00000000           1227        CMP.L       #%000,D2           ;Data register direct is not a valid input for EA destinaton
00001DD0  6700 05AE               1228        BEQ         ERROR
00001DD4                          1229  
00001DD4  B4BC 00000001           1230        CMP.L       #%001,D2           ;Address register direct is not a valid input for EA destinaton
00001DDA  6700 05A4               1231        BEQ         ERROR
00001DDE                          1232  
00001DDE  2803                    1233        MOVE.L      D3,D4             ;backing up EA register to D4
00001DE0  2605                    1234        MOVE.L      D5,D3             ;Moving register number to D3
00001DE2  6100 0344               1235        BSR         EA_PARSE_Dn       ;Outputting register
00001DE6                          1236  
00001DE6  10FC 002C               1237        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001DEA  10FC 0020               1238        MOVE.B      #' ',(A0)+
00001DEE                          1239  
00001DEE  2604                    1240        MOVE.L      D4,D3             ;Moving EA register back
00001DF0  6100 02EA               1241        BSR         EA_PARSE_MODE     ;outputing the destination EA
00001DF4                          1242  
00001DF4                          1243  
00001DF4  4E75                    1244        RTS
00001DF6                          1245  
00001DF6                          1246  *Input: D0 (input Line)
00001DF6                          1247  *Input: D5 (OPMOde type (1 or 2))
00001DF6                          1248  EA_ADD                              ;Parsing EA for ADD function
00001DF6  1205                    1249        MOVE.B      D5,D1             ;moving input opmode type to D1
00001DF8  4285                    1250        CLR.L       D5                ;clearing D5
00001DFA                          1251  
00001DFA  6100 06D4               1252        BSR         BitMask9to11      ;isolating register number
00001DFE  2A07                    1253        MOVE.L      D7,D5             ;moving return value to D5
00001E00                          1254  
00001E00  6100 06FA               1255        BSR         BitMask3to5       ;isolating EA address mode
00001E04  2407                    1256        MOVE.L      D7,D2             ;moving return value to D2
00001E06                          1257  
00001E06  6100 0700               1258        BSR         BitMask0to2       ;isloating EA address register
00001E0A  2607                    1259        MOVE.L      D7,D3             ;Moving return value to D3
00001E0C                          1260  
00001E0C  B23C 0001               1261        CMP.B       #1,D1             ;if the OPMode is type 1, the EA is the source
00001E10  6700 000C               1262        BEQ         EA_ADD_SOURCE      
00001E14                          1263  
00001E14  B23C 0002               1264        CMP.B       #2,D1             ;if the OPMode is type 2, the EA is the destination
00001E18  6700 0004               1265        BEQ         EA_ADD_SOURCE
00001E1C                          1266  
00001E1C  4E75                    1267        RTS                           ;Returning to source
00001E1E                          1268  
00001E1E                          1269  *Called if the EA address field is a source operand
00001E1E                          1270  EA_ADD_SOURCE
00001E1E                          1271  
00001E1E  6100 02BC               1272        BSR         EA_PARSE_MODE     ;outputing the source EA
00001E22                          1273  
00001E22  10FC 002C               1274        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001E26  10FC 0020               1275        MOVE.B      #' ',(A0)+
00001E2A                          1276  
00001E2A  2605                    1277        MOVE.L      D5,D3             ;Moving register number to D3
00001E2C  6100 02FA               1278        BSR         EA_PARSE_Dn       ;Outputting register
00001E30                          1279  
00001E30  4E75                    1280        RTS
00001E32                          1281  
00001E32                          1282  *Called if the EA address field is a destinaton operand
00001E32                          1283  EA_ADD_DESTINATION
00001E32  B4BC 00000000           1284        CMP.L       #%000,D2           ;Data register direct is not a valid input for EA destinaton
00001E38  6700 0546               1285        BEQ         ERROR
00001E3C                          1286  
00001E3C  B4BC 00000001           1287        CMP.L       #%001,D2           ;Address register direct is not a valid input for EA destinaton
00001E42  6700 053C               1288        BEQ         ERROR
00001E46                          1289  
00001E46  2803                    1290        MOVE.L      D3,D4             ;backing up EA address register
00001E48                          1291  
00001E48  2605                    1292        MOVE.L      D5,D3             ;Moving register to D3
00001E4A  6100 02DC               1293        BSR         EA_PARSE_Dn       ;Outputting register
00001E4E                          1294  
00001E4E  10FC 002C               1295        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001E52  10FC 0020               1296        MOVE.B      #' ',(A0)+
00001E56                          1297  
00001E56  2604                    1298        MOVE.L      D4,D3             ;moving address register back
00001E58                          1299  
00001E58  6100 0282               1300        BSR         EA_PARSE_MODE     ;outputing the destination EA
00001E5C  4E75                    1301        RTS
00001E5E                          1302  
00001E5E                          1303  *Input: D0 (input Line)
00001E5E                          1304  *Input: D1 (Isbyte (0 or 1))
00001E5E                          1305  EA_SUBQ                             ;Parsing EA for SUBQ function
00001E5E                          1306  
00001E5E  6100 069C               1307        BSR         BitMask3to5       ;isolating destination address mode
00001E62  2407                    1308        MOVE.L      D7,D2             ;moving return value to D2
00001E64                          1309  
00001E64  6100 06A2               1310        BSR         BitMask0to2       ;isloating destination address register
00001E68  2607                    1311        MOVE.L      D7,D3             ;Moving return value to D3
00001E6A                          1312  
00001E6A  6100 0318               1313        BSR         EA_PARSE_IMMEDIATE_DATA          
00001E6E                          1314  
00001E6E  10FC 002C               1315        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001E72  10FC 0020               1316        MOVE.B      #' ',(A0)+
00001E76                          1317  
00001E76  B2BC 00000001           1318        CMP.L       #1,D1              ;Address register direct is not a valid input for EA destinaton
00001E7C  6700 000A               1319        BEQ         EA_SUBQ_BYTE_CHECK ;checking if it's a byte operation. if it is, branch to error.
00001E80                          1320        
00001E80  2E05                    1321        MOVE.L      D5,D7
00001E82  6100 0258               1322        BSR         EA_PARSE_MODE       ;outputting Address register destination
00001E86                          1323  
00001E86  4E75                    1324        RTS                           ;Returning to source
00001E88                          1325  
00001E88                          1326  EA_SUBQ_BYTE_CHECK
00001E88  B4BC 00000001           1327        CMP.L       #%001,D2          ;if it is a byte-operation
00001E8E  6700 04F0               1328        BEQ         ERROR
00001E92  4E75                    1329        RTS
00001E94                          1330  
00001E94                          1331  *Input: D0 (input Line)
00001E94                          1332  EA_MOVE                             ;Parsing EA for MOVE function
00001E94                          1333  
00001E94  6100 0666               1334        BSR         BitMask3to5       ;isolating source address mode
00001E98  2407                    1335        MOVE.L      D7,D2             ;moving return value to D2
00001E9A                          1336  
00001E9A  6100 066C               1337        BSR         BitMask0to2       ;isloating source address register
00001E9E  2607                    1338        MOVE.L      D7,D3             ;Moving return value to D3
00001EA0                          1339  
00001EA0  6100 023A               1340        BSR         EA_PARSE_MODE     ;parsing mode and register for the source   
00001EA4                          1341  
00001EA4  10FC 002C               1342        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001EA8  10FC 0020               1343        MOVE.B      #' ',(A0)+
00001EAC                          1344  
00001EAC  6100 0632               1345        BSR         BitMask6to8       ;isolating destination address mode
00001EB0  2407                    1346        MOVE.L      D7,D2             ;moving return value to D2
00001EB2                          1347  
00001EB2  6100 061C               1348        BSR         BitMask9to11       ;isloating destination address register
00001EB6  2607                    1349        MOVE.L      D7,D3             ;Moving return value to D3
00001EB8                          1350  
00001EB8  B47C 0001               1351        CMP.W       #%001,D2           ;Address register direct is not a valid destination mode
00001EBC  6700 04C2               1352        BEQ         ERROR
00001EC0                          1353  
00001EC0  6100 021A               1354        BSR         EA_PARSE_MODE     ;parsing mode and register for the destination     
00001EC4                          1355  
00001EC4  4E75                    1356        RTS                           ;Returning to source
00001EC6                          1357  
00001EC6                          1358  *Input: D0 (input Line)
00001EC6                          1359  EA_MOVEA                            ;Parsing EA for MOVEA function
00001EC6                          1360  
00001EC6  6100 0634               1361        BSR         BitMask3to5       ;isolating source address mode
00001ECA  2407                    1362        MOVE.L      D7,D2             ;moving return value to D2
00001ECC                          1363  
00001ECC  6100 063A               1364        BSR         BitMask0to2       ;isloating source address register
00001ED0  2607                    1365        MOVE.L      D7,D3             ;Moving return value to D3
00001ED2                          1366  
00001ED2  6100 0208               1367        BSR         EA_PARSE_MODE     ;parsing mode and register for the source   
00001ED6                          1368  
00001ED6  10FC 002C               1369        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001EDA  10FC 0020               1370        MOVE.B      #' ',(A0)+
00001EDE                          1371  
00001EDE  6100 05F0               1372        BSR         BitMask9to11      ;isloating destination address register
00001EE2                          1373  
00001EE2  2607                    1374        MOVE.L      D7,D3             ;Moving return value to D3
00001EE4  6100 024E               1375        BSR         EA_PARSE_An       ;parsing address register direct for the destination     
00001EE8                          1376  
00001EE8  4E75                    1377        RTS                           ;Returning to source
00001EEA                          1378  
00001EEA                          1379  *Input: D0 (input Line)
00001EEA                          1380  EA_CMP                             ;Parsing EA for CMP function
00001EEA                          1381  
00001EEA  6100 0610               1382        BSR         BitMask3to5       ;isolating source address mode
00001EEE  2407                    1383        MOVE.L      D7,D2             ;moving return value to D2
00001EF0                          1384  
00001EF0  6100 0616               1385        BSR         BitMask0to2       ;isloating source address register
00001EF4  2607                    1386        MOVE.L      D7,D3             ;Moving return value to D3
00001EF6                          1387  
00001EF6  6100 01E4               1388        BSR         EA_PARSE_MODE     ;parsing mode and register for the source   
00001EFA                          1389  
00001EFA  10FC 002C               1390        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001EFE  10FC 0020               1391        MOVE.B      #' ',(A0)+
00001F02                          1392  
00001F02  6100 05CC               1393        BSR         BitMask9to11      ;isloating destination address register
00001F06                          1394  
00001F06  2607                    1395        MOVE.L      D7,D3             ;Moving return value to D3
00001F08  6100 021E               1396        BSR         EA_PARSE_Dn       ;parsing data register direct for the destination     
00001F0C                          1397  
00001F0C  4E75                    1398        RTS                           ;Returning to source
00001F0E                          1399  
00001F0E                          1400  
00001F0E                          1401  EA_CMPI                             ;Parsing EA for CMPI function
00001F0E                          1402  
00001F0E  6100 05EC               1403        BSR         BitMask3to5       ;isolating destination address mode
00001F12  2407                    1404        MOVE.L      D7,D2             ;moving return value to D2
00001F14                          1405  
00001F14  6100 05F2               1406        BSR         BitMask0to2       ;isloating destination address register
00001F18  2607                    1407        MOVE.L      D7,D3             ;Moving return value to D3
00001F1A                          1408  
00001F1A  6100 0268               1409        BSR         EA_PARSE_IMMEDIATE_DATA          
00001F1E                          1410  
00001F1E  10FC 002C               1411        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001F22  10FC 0020               1412        MOVE.B      #' ',(A0)+
00001F26                          1413  
00001F26  B4BC 00000001           1414        CMP.L       #%001,D2           ;Address register direct is not a valid input for EA destinaton
00001F2C  6700 0452               1415        BEQ         ERROR
00001F30                          1416  
00001F30  6100 01AA               1417        BSR         EA_PARSE_MODE     ;outputting Address register destination
00001F34                          1418  
00001F34  4E75                    1419        RTS                           ;Returning to source
00001F36                          1420  
00001F36                          1421  
00001F36                          1422  *Input: D0 (input Line)
00001F36                          1423  EA_MULS                             ;Parsing EA for MULS function
00001F36                          1424  
00001F36  6100 05C4               1425        BSR         BitMask3to5       ;isolating source address mode
00001F3A  2407                    1426        MOVE.L      D7,D2             ;moving return value to D2
00001F3C                          1427  
00001F3C  6100 05CA               1428        BSR         BitMask0to2       ;isloating source address register
00001F40  2607                    1429        MOVE.L      D7,D3             ;Moving return value to D3
00001F42                          1430  
00001F42  B47C 0001               1431        CMP.W       #%001,D2           ;Address Register direct is not a valid EA Mode for DIVS
00001F46  6700 0438               1432        BEQ         ERROR
00001F4A                          1433  
00001F4A  6100 0190               1434        BSR         EA_PARSE_MODE     ;parsing mode and register for the source   
00001F4E                          1435  
00001F4E  10FC 002C               1436        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001F52  10FC 0020               1437        MOVE.B      #' ',(A0)+
00001F56                          1438  
00001F56  6100 0578               1439        BSR         BitMask9to11      ;isloating destination address register
00001F5A                          1440  
00001F5A  2607                    1441        MOVE.L      D7,D3             ;Moving return value to D3
00001F5C  6100 01CA               1442        BSR         EA_PARSE_Dn       ;parsing data register direct for the destination     
00001F60                          1443  
00001F60  4E75                    1444        RTS                           ;Returning to source
00001F62                          1445  
00001F62                          1446  *Input: D0 (input Line)
00001F62                          1447  EA_DIVS                             ;Parsing EA for DIVS function
00001F62                          1448  
00001F62  6100 0598               1449        BSR         BitMask3to5       ;isolating source address mode
00001F66  2407                    1450        MOVE.L      D7,D2             ;moving return value to D2
00001F68                          1451  
00001F68  6100 059E               1452        BSR         BitMask0to2       ;isloating source address register
00001F6C  2607                    1453        MOVE.L      D7,D3             ;Moving return value to D3
00001F6E                          1454  
00001F6E  B47C 0001               1455        CMP.W       #%001,D2           ;Address Register direct is not a valid EA Mode for DIVS
00001F72  6700 040C               1456        BEQ         ERROR
00001F76                          1457  
00001F76  6100 0164               1458        BSR         EA_PARSE_MODE     ;parsing mode and register for the source   
00001F7A                          1459  
00001F7A  10FC 002C               1460        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001F7E  10FC 0020               1461        MOVE.B      #' ',(A0)+
00001F82                          1462  
00001F82  6100 054C               1463        BSR         BitMask9to11      ;isloating destination address register
00001F86                          1464  
00001F86  2607                    1465        MOVE.L      D7,D3             ;Moving return value to D3
00001F88  6100 019E               1466        BSR         EA_PARSE_Dn       ;parsing data register direct for the destination     
00001F8C                          1467  
00001F8C  4E75                    1468        RTS                           ;Returning to source
00001F8E                          1469  
00001F8E                          1470  *Input: D0 (input Line)
00001F8E                          1471  EA_LS_REGISTER                      ;Parsing EA for LSR/LSL function for register shifts
00001F8E                          1472  
00001F8E  6100 05CA               1473        BSR         BitMask5to5
00001F92  2A07                    1474        MOVE.L      D7,D5             ;storing i/r value in D5
00001F94                          1475  
00001F94  6100 053A               1476        BSR         BitMask9to11      ;isloating source EA source register
00001F98  2607                    1477        MOVE.L      D7,D3             ;Moving return value to D3
00001F9A                          1478  
00001F9A  6100 0352               1479        BSR         EA_PARSE_REGISTER ;parsing the count/register field
00001F9E  2807                    1480        MOVE.L      D7,D4             ;moving result to D4
00001FA0                          1481  
00001FA0  BA7C 0001               1482        CMP.W       #%1,D5             ;if the i/r value is 1 display the data register
00001FA4  6700 000A               1483        BEQ         EA_LS_REGISTER_D
00001FA8                          1484  
00001FA8  BA7C 0000               1485        CMP.W       #%0,D5             ;if the i/r value is 0 display immediate data
00001FAC  6700 000A               1486        BEQ         EA_LS_REGISTER_DIRECT
00001FB0                          1487  
00001FB0                          1488  
00001FB0                          1489  EA_LS_REGISTER_D
00001FB0  10FC 0044               1490        MOVE.B      #'D',(A0)+
00001FB4  6000 000A               1491        BRA         EA_LS_REGISTER_AFTERBREAK
00001FB8                          1492  
00001FB8                          1493  EA_LS_REGISTER_DIRECT
00001FB8  10FC 0023               1494        MOVE.B      #'#',(A0)+
00001FBC  6000 0002               1495        BRA         EA_LS_REGISTER_AFTERBREAK     
00001FC0                          1496  
00001FC0                          1497  EA_LS_REGISTER_AFTERBREAK
00001FC0  10C4                    1498        MOVE.B      D4,(A0)+          ;pushing the register number or immediate data to the stack
00001FC2                          1499  
00001FC2  10FC 002C               1500        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001FC6  10FC 0020               1501        MOVE.B      #' ',(A0)+
00001FCA                          1502   
00001FCA  6100 053C               1503        BSR         BitMask0to2       ;isloating source destination register
00001FCE  2607                    1504        MOVE.L      D7,D3             ;Moving return value to D3
00001FD0                          1505  
00001FD0  6100 0156               1506        BSR         EA_PARSE_Dn       ;displaying the destination data register
00001FD4                          1507  
00001FD4  4E75                    1508        RTS                           ;Returning to source
00001FD6                          1509  
00001FD6                          1510  *Input: D0 (input Line)
00001FD6                          1511  EA_LS_MEMORY                        ;Parsing EA for LSR/LSL function for memory shifts
00001FD6                          1512  
00001FD6  6100 0524               1513        BSR         BitMask3to5       ;isolating destination address mode
00001FDA  2407                    1514        MOVE.L      D7,D2             ;moving return value to D2
00001FDC                          1515  
00001FDC  6100 052A               1516        BSR         BitMask0to2       ;isloating source address register
00001FE0  2607                    1517        MOVE.L      D7,D3             ;Moving return value to D3
00001FE2                          1518  
00001FE2  B47C 0000               1519        CMP.W       #%000,D2          ;Data Register direct is not a valid EA mode
00001FE6  6700 0398               1520        BEQ         ERROR
00001FEA                          1521  
00001FEA  B47C 0001               1522        CMP.W       #%001,D2          ;Address Register direct is not a valid EA Mode
00001FEE  6700 0390               1523        BEQ         ERROR
00001FF2                          1524  
00001FF2  B47C 0007               1525        CMP.W       #%111,D2          ;Immediate Data is not a valid EA mode
00001FF6  6700 0368               1526        BEQ         EA_BlOCK_IMMEDIATE
00001FFA                          1527  
00001FFA  6100 00E0               1528        BSR         EA_PARSE_MODE     ;parsing mode and register for the source   
00001FFE                          1529  
00001FFE  4E75                    1530        RTS                           ;Returning to source
00002000                          1531  
00002000                          1532  *Input: D0 (input Line)
00002000                          1533  EA_AS_REGISTER                      ;Parsing EA for ASR/ASL function for register shifts
00002000                          1534  
00002000  6100 0558               1535        BSR         BitMask5to5
00002004  2A07                    1536        MOVE.L      D7,D5             ;storing i/r value in D5
00002006                          1537  
00002006  6100 04C8               1538        BSR         BitMask9to11      ;isloating source EA source register
0000200A  2607                    1539        MOVE.L      D7,D3             ;Moving return value to D3
0000200C                          1540  
0000200C  6100 02E0               1541        BSR         EA_PARSE_REGISTER ;parsing the count/register field
00002010  2807                    1542        MOVE.L      D7,D4             ;moving result to D4
00002012                          1543  
00002012  BA7C 0001               1544        CMP.W       #%1,D5             ;if the i/r value is 1 display the data register
00002016  6700 000A               1545        BEQ         EA_AS_REGISTER_D
0000201A                          1546  
0000201A  BA7C 0000               1547        CMP.W       #%0,D5             ;if the i/r value is 0 display immediate data
0000201E  6700 000A               1548        BEQ         EA_AS_REGISTER_DIRECT
00002022                          1549  
00002022                          1550  
00002022                          1551  EA_AS_REGISTER_D
00002022  10FC 0044               1552        MOVE.B      #'D',(A0)+
00002026  6000 0006               1553        BRA         EA_AS_REGISTER_AFTERBREAK
0000202A                          1554  
0000202A                          1555  EA_AS_REGISTER_DIRECT
0000202A  10FC 0023               1556        MOVE.B      #'#',(A0)+
0000202E                          1557  
0000202E                          1558  EA_AS_REGISTER_AFTERBREAK
0000202E  10C4                    1559        MOVE.B      D4,(A0)+          ;pushing the register number or immediate data to the stack
00002030                          1560  
00002030  10FC 002C               1561        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00002034  10FC 0020               1562        MOVE.B      #' ',(A0)+
00002038                          1563   
00002038  6100 04CE               1564        BSR         BitMask0to2       ;isloating source destination register
0000203C  2607                    1565        MOVE.L      D7,D3             ;Moving return value to D3
0000203E                          1566  
0000203E  6100 00E8               1567        BSR         EA_PARSE_Dn       ;displaying the destination data register
00002042                          1568  
00002042  4E75                    1569        RTS                           ;Returning to source
00002044                          1570  
00002044                          1571  *Input: D0 (input Line)
00002044                          1572  EA_AS_MEMORY                        ;Parsing EA for ASR/ASL function for memory shifts
00002044                          1573  
00002044  6100 04B6               1574        BSR         BitMask3to5       ;isolating destination address mode
00002048  2407                    1575        MOVE.L      D7,D2             ;moving return value to D2
0000204A                          1576  
0000204A  6100 04BC               1577        BSR         BitMask0to2       ;isloating source address register
0000204E  2607                    1578        MOVE.L      D7,D3             ;Moving return value to D3
00002050                          1579  
00002050  B47C 0000               1580        CMP.W       #%000,D2          ;Data Register direct is not a valid EA mode
00002054  6700 032A               1581        BEQ         ERROR
00002058                          1582  
00002058  B47C 0001               1583        CMP.W       #%001,D2          ;Address Register direct is not a valid EA Mode
0000205C  6700 0322               1584        BEQ         ERROR
00002060                          1585  
00002060  B47C 0007               1586        CMP.W       #%111,D2          ;Immediate Data is not a valid EA mode
00002064  6700 02FA               1587        BEQ         EA_BlOCK_IMMEDIATE
00002068                          1588  
00002068  6100 0072               1589        BSR         EA_PARSE_MODE     ;parsing mode and register for the source   
0000206C                          1590  
0000206C  4E75                    1591        RTS                           ;Returning to source
0000206E                          1592  
0000206E                          1593  
0000206E                          1594  *Input: D0 (input Line)
0000206E                          1595  EA_RO_REGISTER                      ;Parsing EA for ROR/ROL function for register shifts
0000206E                          1596  
0000206E  6100 04EA               1597        BSR         BitMask5to5
00002072  2A07                    1598        MOVE.L      D7,D5             ;storing i/r value in D5
00002074                          1599  
00002074  6100 045A               1600        BSR         BitMask9to11      ;isloating source EA source register
00002078  2607                    1601        MOVE.L      D7,D3             ;Moving return value to D3
0000207A                          1602  
0000207A  6100 0272               1603        BSR         EA_PARSE_REGISTER ;parsing the count/register field
0000207E  2807                    1604        MOVE.L      D7,D4             ;moving result to D4
00002080                          1605  
00002080  BA7C 0001               1606        CMP.W       #%1,D5             ;if the i/r value is 1 display the data register
00002084  6700 000A               1607        BEQ         EA_RO_REGISTER_D
00002088                          1608  
00002088  BA7C 0000               1609        CMP.W       #%0,D5             ;if the i/r value is 0 display immediate data
0000208C  6700 000A               1610        BEQ         EA_RO_REGISTER_DIRECT
00002090                          1611  
00002090                          1612  EA_RO_REGISTER_D
00002090  10FC 0044               1613        MOVE.B      #'D',(A0)+
00002094  6000 0006               1614        BRA         EA_RO_REGISTER_AFTERBREAK
00002098                          1615  
00002098                          1616  EA_RO_REGISTER_DIRECT
00002098  10FC 0023               1617        MOVE.B      #'#',(A0)+
0000209C                          1618  
0000209C                          1619  EA_RO_REGISTER_AFTERBREAK
0000209C  10C4                    1620        MOVE.B      D4,(A0)+          ;pushing the register number or immediate data to the stack
0000209E                          1621  
0000209E  10FC 002C               1622        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
000020A2  10FC 0020               1623        MOVE.B      #' ',(A0)+
000020A6                          1624   
000020A6  6100 0460               1625        BSR         BitMask0to2       ;isloating source destination register
000020AA  2607                    1626        MOVE.L      D7,D3             ;Moving return value to D3
000020AC                          1627  
000020AC  6100 007A               1628        BSR         EA_PARSE_Dn       ;displaying the destination data register
000020B0                          1629  
000020B0  4E75                    1630        RTS                           ;Returning to source
000020B2                          1631  
000020B2                          1632  *Input: D0 (input Line)
000020B2                          1633  EA_RO_MEMORY                        ;Parsing EA for ROR/ROL function for memory shifts
000020B2                          1634  
000020B2  6100 0448               1635        BSR         BitMask3to5       ;isolating destination address mode
000020B6  2407                    1636        MOVE.L      D7,D2             ;moving return value to D2
000020B8                          1637  
000020B8  6100 044E               1638        BSR         BitMask0to2       ;isloating source address register
000020BC  2607                    1639        MOVE.L      D7,D3             ;Moving return value to D3
000020BE                          1640  
000020BE  B47C 0000               1641        CMP.W       #%000,D2          ;Data Register direct is not a valid EA mode
000020C2  6700 02BC               1642        BEQ         ERROR
000020C6                          1643  
000020C6  B47C 0001               1644        CMP.W       #%001,D2          ;Address Register direct is not a valid EA Mode
000020CA  6700 02B4               1645        BEQ         ERROR
000020CE                          1646  
000020CE  B47C 0007               1647        CMP.W       #%111,D2          ;Immediate Data is not a valid EA mode
000020D2  6700 028C               1648        BEQ         EA_BlOCK_IMMEDIATE
000020D6                          1649  
000020D6  6100 0004               1650        BSR         EA_PARSE_MODE     ;parsing mode and register for the source   
000020DA                          1651  
000020DA  4E75                    1652        RTS                           ;Returning to source
000020DC                          1653  
000020DC                          1654  
000020DC                          1655  *Finds correct function to parse the EA Mode 
000020DC                          1656  *Input: D2 (EA Mode)
000020DC                          1657  *Input: D3 (EA Register Number)
000020DC                          1658  EA_PARSE_MODE                       
000020DC  B47C 0000               1659        CMP.W       #%000,D2
000020E0  6700 0046               1660        BEQ         EA_PARSE_Dn
000020E4                          1661  
000020E4  B47C 0001               1662        CMP.W       #%001,D2
000020E8  6700 004A               1663        BEQ         EA_PARSE_An
000020EC                          1664  
000020EC  B47C 0002               1665        CMP.W       #%010,D2
000020F0  6700 004E               1666        BEQ         EA_PARSE_INDIRECT_An
000020F4                          1667  
000020F4  B47C 0003               1668        CMP.W       #%011,D2
000020F8  6700 005A               1669        BEQ         EA_PARSE_INDIRECT_INCREMENT_An
000020FC                          1670  
000020FC  B47C 0004               1671        CMP.W       #%100,D2
00002100  6700 006A               1672        BEQ         EA_PARSE_INDIRECT_DECREMENT_An
00002104                          1673  
00002104  B47C 0007               1674        CMP.W       #%111,D2
00002108  6700 0004               1675        BEQ         EA_ADDITIONAL_DATA
0000210C                          1676  
0000210C  4E75                    1677        RTS
0000210E                          1678  
0000210E                          1679  EA_ADDITIONAL_DATA
0000210E  B67C 0000               1680        CMP.W       #%000,D3
00002112  6700 008C               1681        BEQ         EA_PARSE_ABSOLUTE_WORD_ADDRESS
00002116                          1682  
00002116  B67C 0001               1683        CMP.W       #%001,D3
0000211A  6700 0072               1684        BEQ         EA_PARSE_ABSOLUTE_LONG_ADDRESS
0000211E                          1685  
0000211E  B67C 0004               1686        CMP.W       #%100,D3
00002122  6700 0060               1687        BEQ         EA_PARSE_IMMEDIATE_DATA
00002126                          1688  
00002126  4E75                    1689        RTS
00002128                          1690  
00002128                          1691  *These functions are called when the EA Mode matches.
00002128                          1692  *They store the human ouput code to the A0 register, then increment it.
00002128                          1693  *Then return to where they were called from.
00002128                          1694  
00002128                          1695  
00002128                          1696  *Input: D3 (Register Address number)
00002128                          1697  *Uses:  D7
00002128                          1698  *Output: A0
00002128                          1699  EA_PARSE_Dn
00002128  6100 01C4               1700        BSR         EA_PARSE_REGISTER
0000212C  10FC 0044               1701        MOVE.B      #'D',(A0)+
00002130  10C7                    1702        MOVE.B      D7,(A0)+
00002132  4E75                    1703        RTS
00002134                          1704  
00002134                          1705  EA_PARSE_An
00002134  6100 01B8               1706        BSR         EA_PARSE_REGISTER
00002138  10FC 0041               1707        MOVE.B      #'A',(A0)+
0000213C  10C7                    1708        MOVE.B      D7,(A0)+
0000213E  4E75                    1709        RTS
00002140                          1710  
00002140                          1711  EA_PARSE_INDIRECT_An
00002140  6100 01AC               1712        BSR         EA_PARSE_REGISTER
00002144  10FC 0028               1713        MOVE.B      #'(',(A0)+
00002148  10FC 0041               1714        MOVE.B      #'A',(A0)+
0000214C  10C7                    1715        MOVE.B      D7,(A0)+
0000214E  10FC 0029               1716        MOVE.B      #')',(A0)+
00002152  4E75                    1717        RTS
00002154                          1718  
00002154                          1719  EA_PARSE_INDIRECT_INCREMENT_An
00002154  6100 0198               1720        BSR         EA_PARSE_REGISTER
00002158  10FC 0028               1721        MOVE.B      #'(',(A0)+
0000215C  10FC 0041               1722        MOVE.B      #'A',(A0)+
00002160  10C7                    1723        MOVE.B      D7,(A0)+
00002162  10FC 0029               1724        MOVE.B      #')',(A0)+
00002166  10FC 002B               1725        MOVE.B      #'+',(A0)+
0000216A  4E75                    1726        RTS
0000216C                          1727  
0000216C                          1728  EA_PARSE_INDIRECT_DECREMENT_An
0000216C  6100 0180               1729        BSR         EA_PARSE_REGISTER
00002170  10FC 002D               1730        MOVE.B      #'-',(A0)+
00002174  10FC 0028               1731        MOVE.B      #'(',(A0)+
00002178  10FC 0041               1732        MOVE.B      #'A',(A0)+
0000217C  10C7                    1733        MOVE.B      D7,(A0)+
0000217E  10FC 0029               1734        MOVE.B      #')',(A0)+
00002182  4E75                    1735        RTS
00002184                          1736  
00002184                          1737  EA_PARSE_IMMEDIATE_DATA
00002184  10FC 0023               1738        MOVE.B     #'#',(A0)+
00002188  6100 0028               1739        BSR        IO_GET_WORD
0000218C  4E75                    1740        RTS
0000218E                          1741  
0000218E                          1742  EA_PARSE_ABSOLUTE_LONG_ADDRESS
0000218E  10FC 0024               1743        MOVE.B     #'$',(A0)+
00002192  6100 001E               1744        BSR        IO_GET_WORD
00002196  10FC 002E               1745        MOVE.B     #'.',(A0)+
0000219A  10FC 004C               1746        MOVE.B     #'L',(A0)+
0000219E  4E75                    1747        RTS
000021A0                          1748        
000021A0                          1749  EA_PARSE_ABSOLUTE_WORD_ADDRESS
000021A0  10FC 0024               1750        MOVE.B     #'$',(A0)+
000021A4  6100 000C               1751        BSR        IO_GET_WORD
000021A8  10FC 002E               1752        MOVE.B     #'.',(A0)+
000021AC  10FC 0057               1753        MOVE.B     #'W',(A0)+
000021B0  4E75                    1754        RTS
000021B2                          1755  
000021B2                          1756  
000021B2                          1757  IO_GET_WORD
000021B2  3F00                    1758        MOVE.W  D0,-(sp)        *Saves D0
000021B4  3F01                    1759        MOVE.W  D1,-(sp)        *Saves D1
000021B6  3F02                    1760        MOVE.W  D2,-(sp)        *Saves D2
000021B8  3F03                    1761        MOVE.W  D3,-(sp)        *Saves D3
000021BA  3F04                    1762        MOVE.W  D4,-(sp)        *Saves D4
000021BC                          1763  
000021BC  544D                    1764        ADDQ.W  #byte,A5        *Incrementing A5 to get the next word section
000021BE  3415                    1765        MOVE.W  (A5),D2         *Gets the data of where the pointer is at
000021C0  544D                    1766        ADDQ.W  #byte,A5        *Incrementing the pointer one word
000021C2  6100 000E               1767        BSR     n2asciiSTACK    *Branching to n2asciiSTACK to push the word to the stack
000021C6                          1768  
000021C6  381F                    1769        MOVE.W  (sp)+,D4        *Restores D4
000021C8  361F                    1770        MOVE.W  (sp)+,D3        *Restores D3
000021CA  341F                    1771        MOVE.W  (sp)+,D2        *Restores D2
000021CC  321F                    1772        MOVE.W  (sp)+,D1        *Restores D1
000021CE  301F                    1773        MOVE.W  (sp)+,D0        *Restores D0
000021D0  4E75                    1774        RTS
000021D2                          1775  
000021D2                          1776  
000021D2                          1777  *Modified version of the n2ascii function that pushes to the A0 stack instead of outputting to console
000021D2  183C 000C               1778  n2asciiSTACK      MOVE.B  #12,D4          *Sets up D4 as counter.
000021D6  3602                    1779  n2asciiSTACK2     MOVE.W  D2,D3           *Moves to D3 to work on there 
000021D8  E86B                    1780                    LSR.W   D4,D3           
000021DA  0243 000F               1781                    ANDI.W  #$000F,D3       *Masks to check last nibble
000021DE  B63C 0000               1782                    CMP.B   #$0,D3          *checks if D3 is equal to 0
000021E2  6700 007E               1783                    BEQ     push0
000021E6  B63C 0001               1784                    CMP.B   #$1,D3          *checks if D3 is equal to 1
000021EA  6700 007E               1785                    BEQ     push1
000021EE  B63C 0002               1786                    CMP.B   #$2,D3          *checks if D3 is equal to 2
000021F2  6700 007E               1787                    BEQ     push2
000021F6  B63C 0003               1788                    CMP.B   #$3,D3          *checks if D3 is equal to 3
000021FA  6700 007E               1789                    BEQ     push3
000021FE  B63C 0004               1790                    CMP.B   #$4,D3          *checks if D3 is equal to 4
00002202  6700 007E               1791                    BEQ     push4
00002206  B63C 0005               1792                    CMP.B   #$5,D3          *checks if D3 is equal to 5
0000220A  6700 007E               1793                    BEQ     push5
0000220E  B63C 0006               1794                    CMP.B   #$6,D3          *checks if D3 is equal to 6
00002212  6700 007E               1795                    BEQ     push6
00002216  B63C 0007               1796                    CMP.B   #$7,D3          *checks if D3 is equal to 7
0000221A  6700 007E               1797                    BEQ     push7
0000221E  B63C 0008               1798                    CMP.B   #$8,D3          *checks if D3 is equal to 8
00002222  6700 007E               1799                    BEQ     push8
00002226  B63C 0009               1800                    CMP.B   #$9,D3          *checks if D3 is equal to 9
0000222A  6700 007E               1801                    BEQ     push9
0000222E  B63C 000A               1802                    CMP.B   #$A,D3          *checks if D3 is equal to A
00002232  6700 007E               1803                    BEQ     pushA
00002236  B63C 000B               1804                    CMP.B   #$B,D3          *checks if D3 is equal to B
0000223A  6700 007E               1805                    BEQ     pushB
0000223E  B63C 000C               1806                    CMP.B   #$C,D3          *checks if D3 is equal to C
00002242  6700 007E               1807                    BEQ     pushC
00002246  B63C 000D               1808                    CMP.B   #$D,D3          *checks if D3 is equal to D
0000224A  6700 007E               1809                    BEQ     pushD
0000224E  B63C 000E               1810                    CMP.B   #$E,D3          *checks if D3 is equal to E
00002252  6700 007E               1811                    BEQ     pushE
00002256  B63C 000F               1812                    CMP.B   #$F,D3          *Checks if D3 is equal to F
0000225A  6700 007E               1813                    BEQ     pushF
0000225E                          1814  
0000225E  6000 0082               1815                    BRA n2acheckSTACK       *Branching past output if none were equal
00002262  10FC 0030               1816  push0       MOVE.B  #'0',(A0)+
00002266  6000 007A               1817              BRA n2acheckSTACK
0000226A  10FC 0031               1818  push1       MOVE.B  #'1',(A0)+
0000226E  6000 0072               1819              BRA n2acheckSTACK
00002272  10FC 0032               1820  push2       MOVE.B  #'2',(A0)+
00002276  6000 006A               1821              BRA n2acheckSTACK
0000227A  10FC 0033               1822  push3       MOVE.B  #'3',(A0)+
0000227E  6000 0062               1823              BRA n2acheckSTACK
00002282  10FC 0034               1824  push4       MOVE.B  #'4',(A0)+
00002286  6000 005A               1825              BRA n2acheckSTACK
0000228A  10FC 0035               1826  push5       MOVE.B  #'5',(A0)+
0000228E  6000 0052               1827              BRA n2acheckSTACK
00002292  10FC 0036               1828  push6       MOVE.B  #'6',(A0)+
00002296  6000 004A               1829              BRA n2acheckSTACK
0000229A  10FC 0037               1830  push7       MOVE.B  #'7',(A0)+
0000229E  6000 0042               1831              BRA n2acheckSTACK
000022A2  10FC 0038               1832  push8       MOVE.B  #'8',(A0)+
000022A6  6000 003A               1833              BRA n2acheckSTACK
000022AA  10FC 0039               1834  push9       MOVE.B  #'9',(A0)+
000022AE  6000 0032               1835              BRA n2acheckSTACK
000022B2  10FC 0041               1836  pushA       MOVE.B  #'A',(A0)+
000022B6  6000 002A               1837              BRA n2acheckSTACK
000022BA  10FC 0042               1838  pushB       MOVE.B  #'B',(A0)+
000022BE  6000 0022               1839              BRA n2acheckSTACK
000022C2  10FC 0043               1840  pushC       MOVE.B  #'C',(A0)+
000022C6  6000 001A               1841              BRA n2acheckSTACK
000022CA  10FC 0044               1842  pushD       MOVE.B  #'D',(A0)+
000022CE  6000 0012               1843              BRA n2acheckSTACK
000022D2  10FC 0045               1844  pushE       MOVE.B  #'E',(A0)+
000022D6  6000 000A               1845              BRA n2acheckSTACK         
000022DA  10FC 0046               1846  pushF       MOVE.B  #'F',(A0)+
000022DE  6000 0002               1847              BRA n2acheckSTACK
000022E2  5904                    1848  n2acheckSTACK     SUB.B   #4,D4           *Decrements our counter
000022E4  B83C 0000               1849                    CMP.B   #0,D4           *Checks if counter reached 0
000022E8  6C00 FEEC               1850                    BGE     n2asciiSTACK2   *Returns to top of loop to continue        
000022EC  4E75                    1851                    RTS                     *Else return to caller
000022EE                          1852  
000022EE                          1853  
000022EE                          1854  
000022EE                          1855  *Converts a register number to ascii number and stores to D7 
000022EE                          1856  *Input:  D3 (Register Number)
000022EE                          1857  *Output: D7 
000022EE                          1858  EA_PARSE_REGISTER                   
000022EE                          1859  
000022EE  B67C 0000               1860        CMP.W       #%000,D3
000022F2  6700 003C               1861        BEQ         EA_MOVE0
000022F6                          1862  
000022F6  B67C 0001               1863        CMP.W       #%001,D3
000022FA  6700 003A               1864        BEQ         EA_MOVE1
000022FE                          1865  
000022FE  B67C 0002               1866        CMP.W       #%010,D3
00002302  6700 0038               1867        BEQ         EA_MOVE2
00002306                          1868  
00002306  B67C 0003               1869        CMP.W       #%011,D3
0000230A  6700 0036               1870        BEQ         EA_MOVE3
0000230E                          1871  
0000230E  B67C 0004               1872        CMP.W       #%100,D3
00002312  6700 0034               1873        BEQ         EA_MOVE4
00002316                          1874  
00002316  B67C 0005               1875        CMP.W       #%101,D3
0000231A  6700 0032               1876        BEQ         EA_MOVE5
0000231E                          1877  
0000231E  B67C 0006               1878        CMP.W       #%110,D3
00002322  6700 0030               1879        BEQ         EA_MOVE6
00002326                          1880  
00002326  B67C 0007               1881        CMP.W       #%111,D3
0000232A  6700 002E               1882        BEQ         EA_MOVE7
0000232E                          1883  
0000232E  4E75                    1884        RTS
00002330                          1885  
00002330  3E3C 0030               1886  EA_MOVE0    MOVE.W      #'0',D7
00002334  4E75                    1887              RTS
00002336                          1888  
00002336  3E3C 0031               1889  EA_MOVE1    MOVE.W      #'1',D7
0000233A  4E75                    1890              RTS
0000233C                          1891  
0000233C  3E3C 0032               1892  EA_MOVE2    MOVE.W      #'2',D7
00002340  4E75                    1893              RTS
00002342                          1894  
00002342  3E3C 0033               1895  EA_MOVE3    MOVE.W      #'3',D7
00002346  4E75                    1896              RTS
00002348                          1897  
00002348  3E3C 0034               1898  EA_MOVE4    MOVE.W      #'4',D7
0000234C  4E75                    1899              RTS
0000234E                          1900  
0000234E  3E3C 0035               1901  EA_MOVE5    MOVE.W      #'5',D7
00002352  4E75                    1902              RTS
00002354                          1903  
00002354  3E3C 0036               1904  EA_MOVE6    MOVE.W      #'6',D7
00002358  4E75                    1905              RTS
0000235A                          1906  
0000235A  3E3C 0037               1907  EA_MOVE7    MOVE.W      #'7',D7
0000235E  4E75                    1908              RTS
00002360                          1909  
00002360                          1910  EA_BlOCK_IMMEDIATE                  ;Blocks immediate data when it not a valid EA mode
00002360  B67C 0002               1911        CMP.W       #%010,D3          ;Branches to ERROR if the EA mode is immediate dat
00002364  6700 001A               1912        BEQ         ERROR
00002368                          1913  
00002368  4E75                    1914        RTS                           ;If it's not immediate it will just return back
0000236A                          1915  
0000236A                          1916  IO_PRINT_OUTPUT
0000236A  10FC 0000               1917        MOVE.B    #%0,(A0)+           ;Adding terminating null to end of string
0000236E  41F9 0000A000           1918        LEA       OUTPUT_START,A0     ;Reseting A0 back to start of string
00002374  2248                    1919        MOVEA.L   A0,A1               ;Moving to A1 for printing
00002376  4280                    1920        CLR.L     D0                  ;clearing the trap byte
00002378  103C 000D               1921        MOVE.B    #13,D0              ;printing string with new line
0000237C  4E4F                    1922        TRAP      #15
0000237E  4E75                    1923        RTS
00002380                          1924  
00002380                          1925  ERROR
00002380                          1926        *TODO: handle illegal inputs
00002380                          1927  
00002380                          1928  end_search
00002380                          1929  
00002380                          1930      
00002380                          1931  
00002380  FFFF FFFF               1932      SIMHALT             ; halt simulator
00002384                          1933  
00002384                          1934  * Put variables and constants here
00002384                          1935  
00002384= 20                      1936  space       DC.B    $20         *space
00002385  =0000000D               1937  CR          EQU     $0D         *Carriage return
00002385  =0000000A               1938  LF          EQU     $0A         *Line Feed
00002385= 0D 0A 00                1939  newline     DC.B    CR,LF,0     *New Line
00002388  =00000002               1940  byte        EQU     2           *How much to move the search address.
00002388                          1941                                  *2 bytes because we're searching for a word
00002388  =00001000               1942  cur_address EQU     $00001000   *Start of search
00002388  =00001004               1943  test_end    EQU     $00001004   *End of search
00002388                          1944  mydata      REG     D0-D7/A0-A6  *Used for pushing registers to stack
00002388  =00000014               1945  pageLength  EQU     20          *Each page is 20 lines (decimal)
00002388                          1946  
00002388                          1947  *Strings for I/O
00002388= 57 65 6C 63 6F 6D ...   1948  greeting0   DC.B    'Welcome to Zeke Snider and Joseph Sturtevant',39,'s 422 Final Project',0
000023C9= 50 6C 65 61 73 65 ...   1949  greeting1   DC.B    'Please enter a starting address: ',0
000023EB= 50 6C 65 61 73 65 ...   1950  greeting2   DC.B    'Please enter an ending address: ',0
0000240C= 49 6E 76 61 6C 69 ...   1951  invalidStr  DC.B    'Invalid input',0
0000241A= 48 69 74 20 65 6E ...   1952  enterToContinue DC.B    'Hit enter to continue...',0
00002433                          1953  *Old, were used for OP code testing, not used in final project
00002433= 44 41 54 41 20 00       1954  datastring  DC.B    'DATA ',0   *Data string
00002439= 4E 4F 50 00             1955  NOPstring   DC.B    'NOP',0     *NOP string
0000243D= 45 4F 52 00             1956  EORstring   DC.B    'EOR',0     *EOR string
00002441= 4F 52 49 00             1957  ORIstring   DC.B    'ORI',0     *ORI string
00002445= 4F 52 00                1958  ORstring    DC.B    'OR',0      *OR string
00002448= 41 44 44 00             1959  ADDstring   DC.B    'ADD',0     *ADD string
0000244C= 41 44 44 41 00          1960  ADDAstring  DC.B    'ADDA',0     *ADDA string
00002451= 4D 4F 56 45 4D 00       1961  MOVEMstring DC.B    'MOVEM',0   *MOVEM string
00002457= 4D 4F 56 45 41 00       1962  MOVEAstring DC.B    'MOVEA',0   *MOVEA string
0000245D= 4D 4F 56 45 00          1963  MOVEstring  DC.B    'MOVE',0    *MOVE string
00002462= 53 55 42 00             1964  SUBstring   DC.B    'SUB',0     *SUB string
00002466= 53 55 42 00             1965  SUBQstring  DC.B    'SUB',0     *SUBQ string
0000246A= 4D 55 4C 53 00          1966  MULSstring  DC.B    'MULS',0    *MULS string
0000246F= 44 49 56 53 00          1967  DIVSstring  DC.B    'DIVS',0    *DIVS string
00002474= 43 4D 50 00             1968  CMPstring   DC.B    'CMP',0     *CMP string
00002478= 43 4D 50 49 00          1969  CMPIstring  DC.B    'CMPI',0    *CMPI string
0000247D= 4C 53 4C 00             1970  LSLstring   DC.B    'LSL',0     *LSL string
00002481= 4C 53 52 00             1971  LSRstring   DC.B    'LSR',0     *LSR string
00002485= 41 53 4C 00             1972  ASLstring   DC.B    'ASL',0     *ASL string
00002489= 41 53 52 00             1973  ASRstring   DC.B    'ASR',0     *ASR string
0000248D= 52 4F 4C 00             1974  ROLstring   DC.B    'ROL',0     *ROL string
00002491= 52 4F 52 00             1975  RORstring   DC.B    'ROR',0     *ROR string
00002495= 42 43 4C 52 00          1976  BCLRstring  DC.B    'BCLR',0    *BCLR string
0000249A= 42 43 53 00             1977  BCSstring   DC.B    'BCS',0     *BCS string
0000249E= 42 47 45 00             1978  BGEstring   DC.B    'BGE',0     *BGE string
000024A2= 42 4C 54 00             1979  BLTstring   DC.B    'BLT',0     *BLT string
000024A6= 42 56 43 00             1980  BVCstring   DC.B    'BVC',0     *BVC string
000024AA= 42 52 41 00             1981  BRAstring   DC.B    'BRA',0     *BRA string
000024AE= 4A 53 52 00             1982  JSRstring   DC.B    'JSR',0     *JSR string
000024B2= 52 54 53 00             1983  RTSstring   DC.B    'RTS',0     *RTS string
000024B6= 4E 45 47 20 00          1984  NEGstring   DC.B    'NEG ',0     *NEG string
000024BB= 4C 45 41 20 00          1985  LEAstring   DC.B    'LEA ',0    *LEA string
000024C0                          1986  
000024C0                          1987  
000024C0                          1988  
000024C0                          1989  *Bit Masks
000024C0                          1990  
000024C0  =0000F000               1991  BitMask15to12 EQU   $F000       *Mask for first byte
000024C0  =00008BC0               1992  BitMaskMulDivl EQU  %1000101111000000  *Mask for MULS and DIVS Long
000024C0  =0000FFC0               1993  BitMask15to6 EQU    $FFC0       *Mask for showing bits 15 through 6 (BCLR immidiate)
000024C0  =0000FF80               1994  BitMask15to7 EQU    $FF80       *Mask for showing bits 15 through 7 (MOVEM)
000024C0  =0000FF00               1995  BitMask15to8 EQU    $FF00       *Mask for showing first two bytes, 0'ing last 2
000024C0  =0000F1C0               1996  opMask      EQU     $F1C0       *Masks word so first byte and OP mode are visible
000024C0                          1997                                  *The rest of the word are 0's
000024C0  =0000F118               1998  BitMaskShifts EQU   %1111000100011000   *Masks for the shift op codes
000024C0                          1999  
000024C0                          2000  *Masked Op codes
000024C0  =00004E71               2001  nop_code    EQU     $4E71       *Hex for NOP
000024C0  =0000B100               2002  eorb_code   EQU     %1011000100000000   *Binary of EOR.B, masked
000024C0  =0000B140               2003  eorw_code   EQU     %1011000101000000   *Binary of EOR.W, masked
000024C0  =0000B180               2004  eorl_code   EQU     %1011000110000000   *Binary of EOR.L, masked
000024C0  =00000000               2005  ori_code    EQU     $00               *Hex of first two bytes of ORI
000024C0                          2006                                          *last 2 bytes don't matter for compare
000024C0  =00008000               2007  orbDn_code  EQU     %1000000000000000   *Binary of OR.B -> Dn
000024C0  =00008040               2008  orwDn_code  EQU     %1000000001000000   *Binary of OR.W -> Dn
000024C0  =00008080               2009  orlDn_code  EQU     %1000000010000000   *Binary of OR.L -> Dn
000024C0  =00008100               2010  orbEA_code  EQU     %1000000100000000   *Binary of OR.B -> EA
000024C0  =00008140               2011  orwEA_code  EQU     %1000000101000000   *Binary of OR.W -> EA
000024C0  =00008180               2012  orlEA_code  EQU     %1000000110000000   *Binary of OR.L -> EA
000024C0  =0000D000               2013  addbDn_code EQU     %1101000000000000   *Binary of ADD.B -> Dn
000024C0  =0000D040               2014  addwDn_code EQU     %1101000001000000   *Binary of ADD.W -> Dn
000024C0  =0000D080               2015  addlDn_code EQU     %1101000010000000   *Binary of ADD.L -> Dn
000024C0  =0000D100               2016  addbEA_code EQU     %1101000100000000   *Binary of ADD.B -> EA
000024C0  =0000D140               2017  addwEA_code EQU     %1101000101000000   *Binary of ADD.W -> EA
000024C0  =0000D180               2018  addlEA_code EQU     %1101000110000000   *Binary of ADD.L -> EA
000024C0  =0000D0C0               2019  addaw_code  EQU     %1101000011000000   *Binary of ADDA.W
000024C0  =0000D1C0               2020  addal_code  EQU     %1101000111000000   *Binary of ADDA.L
000024C0  =00004880               2021  movemr2m_code EQU   %0100100010000000   *Binary of MOVEM from register to memory
000024C0  =00004C80               2022  movemm2r_code EQU   %0100110010000000   *Binary of MOVEM from memory to register
000024C0  =00003040               2023  moveaw_code EQU     %0011000001000000   *Binary of MOVEA Word
000024C0  =00002040               2024  moveal_code EQU     %0010000001000000   *Binary of MOVEA long
000024C0  =00001000               2025  moveb_code  EQU     %0001000000000000   *Binary of MOVE byte
000024C0  =00003000               2026  movew_code  EQU     %0011000000000000   *Binary of MOVE word
000024C0  =00002000               2027  movel_code  EQU     %0010000000000000   *Binary of Move long
000024C0  =00009000               2028  subbDn_code EQU     %1001000000000000   *Binary of SUB.B -> Dn
000024C0  =00009040               2029  subwDn_code EQU     %1001000001000000   *Binary of SUB.W -> Dn
000024C0  =00009080               2030  sublDn_code EQU     %1001000010000000   *Binary of SUB.L -> Dn
000024C0  =00009100               2031  subbEA_code EQU     %1001000100000000   *Binary of SUB.B -> EA
000024C0  =00009140               2032  subwEA_code EQU     %1001000101000000   *Binary of SUB.W -> EA
000024C0  =00009180               2033  sublEA_code EQU     %1001000110000000   *Binary of SUB.L -> EA
000024C0  =00005100               2034  subqb_code  EQU     %0101000100000000   *Binary of SUBQ byte
000024C0  =00005140               2035  subqw_code  EQU     %0101000101000000   *Binary of SUBQ word
000024C0  =00005180               2036  subql_code  EQU     %0101000110000000   *Binary of SUBQ long
000024C0  =00000800               2037  mulsl_code  EQU     %0000100000000000   *Binary of MULS.L
000024C0  =00000840               2038  divsl_code  EQU     %0000100001000000   *Binary of DIVS.L
000024C0  =0000C1C0               2039  mulsw_code  EQU     %1100000111000000   *Binary of MULS.W
000024C0  =000081C0               2040  divsw_code  EQU     %1000000111000000   *Binary of DIVS.W
000024C0  =0000B000               2041  cmpb_code   EQU     %1011000000000000   *Binary of CMP.B
000024C0  =0000B040               2042  cmpw_code   EQU     %1011000001000000   *Binary of CMP.W
000024C0  =0000B080               2043  cmpl_code   EQU     %1011000010000000   *Binary of CMP.L
000024C0  =00000C00               2044  cmpi_code   EQU     %0000110000000000   *Binary of CMPI
000024C0  =0000E108               2045  lsl_code    EQU     %1110000100001000   *Binary of LSL
000024C0  =0000E008               2046  lsr_code    EQU     %1110000000001000   *Binary of LSR
000024C0  =0000E100               2047  asl_code    EQU     %1110000100000000   *Binary of ASL
000024C0  =0000E000               2048  asr_code    EQU     %1110000000000000   *Binary of ASR
000024C0  =0000E118               2049  rol_code    EQU     %1110000100011000   *Binary of ROL
000024C0  =0000E018               2050  ror_code    EQU     %1110000000011000   *Binary of ROR
000024C0  =00000880               2051  bclri_code  EQU     %0000100010000000   *Binary of BCLR with an immidiate
000024C0  =00000180               2052  bclr_code   EQU     %0000000110000000   *Binary of BCLR
000024C0  =00006500               2053  bcs_code    EQU     %0110010100000000   *Binary of BCS
000024C0  =00006C00               2054  bge_code    EQU     %0110110000000000   *Binary of BGE
000024C0  =00006D00               2055  blt_code    EQU     %0110110100000000   *Binary of BLT
000024C0  =00006800               2056  bvc_code    EQU     %0110100000000000   *Binary of BVC
000024C0  =00006000               2057  bra_code    EQU     %0110000000000000   *Binary of BRA
000024C0  =00004E80               2058  jsr_code    EQU     %0100111010000000   *Binary of JSR
000024C0  =00004E75               2059  rts_code    EQU     %0100111001110101   *Binary of RTS
000024C0  =00004400               2060  neg_code    EQU     %0100010000000000   *Binary of NEG
000024C0  =000041C0               2061  lea_code    EQU     %0100000111000000   *Binary of LEA
000024C0                          2062  *EA EQU's
000024C0                          2063  
000024C0  =0000A000               2064  OUTPUT_START EQU     $0000A000
000024C0                          2065  
000024C0                          2066  *--------------------------------*
000024C0                          2067  *     Written By: Zeke Snider    *
000024C0                          2068  *     CSS 422                    *
000024C0                          2069  *     Fall 2014                  *
000024C0                          2070  *     EA BitMasks                *
000024C0                          2071  *--------------------------------*
000024C0                          2072  
000024C0                          2073  *D6 is used to store the masks. 
000024C0                          2074  *D0 is assumed to be input line
000024C0                          2075  *Data is returned on D7
000024C0                          2076  
000024C0                          2077  *(These variables are flexible and can be changed later)
000024C0                          2078  
000024C0                          2079  
000024C0                          2080  *-----COMMON USE MASKS-----*
000024C0                          2081  
000024C0                          2082  *12-15 often used for OP codes
000024C0                          2083  BitMask12to15 
000024C0  2C3C 0000F000           2084        MOVE.L   #%1111000000000000,D6       ;Storing the mask to D6
000024C6  2E00                    2085        MOVE.L   D0,D7                      ;Copying the input line to D7
000024C8  CE86                    2086        AND.L    D6,D7                      ;ANDING the Data
000024CA  E04F                    2087        LSR      #8,D7                      ;Shifting the irrelavant bits out the right side
000024CC  E84F                    2088        LSR      #4,D7
000024CE  4E75                    2089        RTS
000024D0                          2090  
000024D0                          2091  *9-11 commonly used for register
000024D0                          2092  BitMask9to11 
000024D0  2C3C 00000E00           2093        MOVE.L   #%0000111000000000,D6       ;Storing the mask to D6
000024D6  2E00                    2094        MOVE.L   D0,D7                      ;Copying the input line to D7
000024D8  CE86                    2095        AND.L    D6,D7                      ;ANDING the Data
000024DA  E04F                    2096        LSR      #8,D7                      ;Shifting the irrelavant bits out the right side
000024DC  E24F                    2097        LSR      #1,D7 
000024DE  4E75                    2098        RTS
000024E0                          2099  
000024E0                          2100  
000024E0                          2101  *6-8 commonly used for OPMode, OP code
000024E0                          2102  BitMask6to8 
000024E0  2C3C 000001C0           2103        MOVE.L   #%0000000111000000,D6       ;Storing the mask to D6
000024E6  2E00                    2104        MOVE.L   D0,D7                      ;Copying the input line to D7
000024E8  CE86                    2105        AND.L    D6,D7                      ;ANDING the Data
000024EA  EC4F                    2106        LSR      #6,D7                      ;Shifting the irrelavant bits out the right side
000024EC  4E75                    2107        RTS
000024EE                          2108  
000024EE                          2109  *6-7 commonly used for size codes
000024EE                          2110  BitMask6to7 
000024EE  2C3C 000000C0           2111        MOVE.L   #%0000000011000000,D6       ;Storing the mask to D6
000024F4  2E00                    2112        MOVE.L   D0,D7                      ;Copying the input line to D7
000024F6  CE86                    2113        AND.L    D6,D7                      ;ANDING the Data
000024F8  EC4F                    2114        LSR      #6,D7                      ;Shifting the irrelavant bits out the right side
000024FA  4E75                    2115        RTS
000024FC                          2116  
000024FC                          2117  *3-5 commonly used for EA Mode
000024FC                          2118  BitMask3to5 
000024FC  3C3C 0038               2119        MOVE.W   #%0000000000111000,D6       ;Storing the mask to D6
00002500  2E00                    2120        MOVE.L   D0,D7                      ;Copying the input line to D7
00002502  CE86                    2121        AND.L    D6,D7                      ;ANDING the Data
00002504  E64F                    2122        LSR      #3,D7                      ;Shifting the irrelavant bits out the right side
00002506  4E75                    2123        RTS
00002508                          2124  
00002508                          2125  *0-2 commonly used for EA Register
00002508                          2126  BitMask0to2 
00002508  3C3C 0007               2127        MOVE.W   #%0000000000000111,D6       ;Storing the mask to D6
0000250C  2E00                    2128        MOVE.L   D0,D7                      ;Copying the input line to D7
0000250E  CE86                    2129        AND.L    D6,D7                      ;ANDING the Data
00002510  4E75                    2130        RTS
00002512                          2131  
00002512                          2132  *-----SPECIFIC USE MASKS----*
00002512                          2133  
00002512                          2134  *14-15 used for MOVE OP code
00002512                          2135  BitMask14to15 
00002512  2C3C 0000C000           2136        MOVE.L   #%1100000000000000,D6       ;Storing the mask to D6
00002518  2E00                    2137        MOVE.L   D0,D7                      ;Copying the input line to D7
0000251A  CE86                    2138        AND.L    D6,D7                      ;ANDING the Data
0000251C  E04F                    2139        LSR      #8,D7                     ;Shifting the irrelavant bits out the right side
0000251E  EC4F                    2140        LSR      #6,D7
00002520  4E75                    2141        RTS
00002522                          2142  
00002522                          2143  *12-13 used for MOVE size code
00002522                          2144  BitMask12to13 
00002522  2C3C 00003000           2145        MOVE.L   #%0011000000000000,D6       ;Storing the mask to D6
00002528  2E00                    2146        MOVE.L   D0,D7                      ;Copying the input line to D7
0000252A  CE86                    2147        AND.L    D6,D7                      ;ANDING the Data
0000252C  E04F                    2148        LSR      #8,D7                      ;Shifting the irrelavant bits out the right side
0000252E  E84F                    2149        LSR      #4,D7
00002530  4E75                    2150        RTS
00002532                          2151  
00002532                          2152  *8-15 used for ORI OP Code
00002532                          2153  BitMask8to15 
00002532  2C3C 0000FF00           2154        MOVE.L   #%1111111100000000,D6       ;Storing the mask to D6
00002538  2E00                    2155        MOVE.L   D0,D7                      ;Copying the input line to D7
0000253A  CE86                    2156        AND.L    D6,D7                      ;ANDING the Data
0000253C  E04F                    2157        LSR      #8,D7                      ;Shifting the irrelavant bits out the right side
0000253E  4E75                    2158        RTS
00002540                          2159  
00002540                          2160  *7-15 used for MOVEM OP Code
00002540                          2161  BitMask7to15 
00002540  2C3C 0000FF80           2162        MOVE.L   #%1111111110000000,D6       ;Storing the mask to D6
00002546  2E00                    2163        MOVE.L   D0,D7                      ;Copying the input line to D7
00002548  CE86                    2164        AND.L    D6,D7                      ;ANDING the Data
0000254A  EE4F                    2165        LSR      #7,D7                      ;Shifting the irrelavant bits out the right side
0000254C  4E75                    2166        RTS
0000254E                          2167  
0000254E                          2168  *8,12-15 SUBQ OP Code
0000254E                          2169  BitMaskSubQ 
0000254E  2C3C 0000F100           2170        MOVE.L   #%1111000100000000,D6       ;Storing the mask to D6
00002554  2E00                    2171        MOVE.L   D0,D7                      ;Copying the input line to D7
00002556  CE86                    2172        AND.L    D6,D7                      ;ANDING the Data
00002558  4E75                    2173        RTS
0000255A                          2174  
0000255A                          2175  
0000255A                          2176  *5 used for LSR/LSL i/r
0000255A                          2177  BitMask5to5 
0000255A  7C20                    2178        MOVE.L   #%0000000000100000,D6       ;Storing the mask to D6
0000255C  2E00                    2179        MOVE.L   D0,D7                      ;Copying the input line to D7
0000255E  CE86                    2180        AND.L    D6,D7                      ;ANDING the Data
00002560  EA4F                    2181        LSR      #5,D7                      ;Shifting the irrelavant bits out the right side
00002562  4E75                    2182        RTS
00002564                          2183  
00002564                          2184  
00002564                          2185  
00002564                          2186      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDAL_CODE          D1C0
ADDASTRING          244C
ADDAW_CODE          D0C0
ADDBDN_CODE         D000
ADDBEA_CODE         D100
ADDLDN_CODE         D080
ADDLEA_CODE         D180
ADDSTRING           2448
ADDWDN_CODE         D040
ADDWEA_CODE         D140
ASLSTRING           2485
ASL_CODE            E100
ASRSTRING           2489
ASR_CODE            E000
BCLRI_CODE          880
BCLRSTRING          2495
BCLR_CODE           180
BCSSTRING           249A
BCS_CODE            6500
BGESTRING           249E
BGE_CODE            6C00
BITMASK0TO2         2508
BITMASK12TO13       2522
BITMASK12TO15       24C0
BITMASK14TO15       2512
BITMASK15TO12       F000
BITMASK15TO6        FFC0
BITMASK15TO7        FF80
BITMASK15TO8        FF00
BITMASK3TO5         24FC
BITMASK5TO5         255A
BITMASK6TO7         24EE
BITMASK6TO8         24E0
BITMASK7TO15        2540
BITMASK8TO15        2532
BITMASK9TO11        24D0
BITMASKMULDIVL      8BC0
BITMASKSHIFTS       F118
BITMASKSUBQ         254E
BLTSTRING           24A2
BLT_CODE            6D00
BRASTRING           24AA
BRA_CODE            6000
BVCSTRING           24A6
BVC_CODE            6800
BYTE                2
CHECKSIZE           18F4
CMPB_CODE           B000
CMPISTRING          2478
CMPI_CODE           C00
CMPL_CODE           B080
CMPSTRING           2474
CMPW_CODE           B040
COMPARE_ADD         1162
COMPARE_BCC         12E6
COMPARE_BCLR        12DA
COMPARE_BCLRI       12CE
COMPARE_CMP         126A
COMPARE_CMPI        1286
COMPARE_DIVSL       1246
COMPARE_DIVSW       125E
COMPARE_EOR         1146
COMPARE_JSR         1312
COMPARE_LEA         1336
COMPARE_MOVE        11CE
COMPARE_MOVEA       11BA
COMPARE_MOVEM       11A6
COMPARE_MULSL       123A
COMPARE_MULSW       1252
COMPARE_NEG         132A
COMPARE_NOP         10FC
COMPARE_OR          1112
COMPARE_ORI         1108
COMPARE_RTS         131E
COMPARE_SHIFT       1292
COMPARE_SUB         11EA
COMPARE_SUBQ        121E
COMPMASK            19FA
CR                  D
CUR_ADDRESS         1000
DATASTRING          2433
DIVSL_CODE          840
DIVSSTRING          246F
DIVSW_CODE          81C0
EA_ADD              1DF6
EA_ADDA             1C00
EA_ADDITIONAL_DATA  210E
EA_ADD_DESTINATION  1E32
EA_ADD_SOURCE       1E1E
EA_AND              1CD6
EA_ANDI             1D48
EA_AND_DESTINATION  1D1C
EA_AND_SOURCE       1CFE
EA_AS_MEMORY        2044
EA_AS_REGISTER      2000
EA_AS_REGISTER_AFTERBREAK  202E
EA_AS_REGISTER_D    2022
EA_AS_REGISTER_DIRECT  202A
EA_BLOCK_IMMEDIATE  2360
EA_CMP              1EEA
EA_CMPI             1F0E
EA_DIVS             1F62
EA_EOR              1BD2
EA_LS_MEMORY        1FD6
EA_LS_REGISTER      1F8E
EA_LS_REGISTER_AFTERBREAK  1FC0
EA_LS_REGISTER_D    1FB0
EA_LS_REGISTER_DIRECT  1FB8
EA_MOVE             1E94
EA_MOVE0            2330
EA_MOVE1            2336
EA_MOVE2            233C
EA_MOVE3            2342
EA_MOVE4            2348
EA_MOVE5            234E
EA_MOVE6            2354
EA_MOVE7            235A
EA_MOVEA            1EC6
EA_MULS             1F36
EA_NEG              1BAE
EA_OR               1C24
EA_ORI              1C9A
EA_OR_DESTINATION   1C6E
EA_OR_SOURCE        1C50
EA_PARSE_ABSOLUTE_LONG_ADDRESS  218E
EA_PARSE_ABSOLUTE_WORD_ADDRESS  21A0
EA_PARSE_AN         2134
EA_PARSE_DN         2128
EA_PARSE_IMMEDIATE_DATA  2184
EA_PARSE_INDIRECT_AN  2140
EA_PARSE_INDIRECT_DECREMENT_AN  216C
EA_PARSE_INDIRECT_INCREMENT_AN  2154
EA_PARSE_MODE       20DC
EA_PARSE_REGISTER   22EE
EA_RO_MEMORY        20B2
EA_RO_REGISTER      206E
EA_RO_REGISTER_AFTERBREAK  209C
EA_RO_REGISTER_D    2090
EA_RO_REGISTER_DIRECT  2098
EA_SUB              1D72
EA_SUBQ             1E5E
EA_SUBQ_BYTE_CHECK  1E88
EA_SUB_BYTE_CHECK   1DBE
EA_SUB_DESTINATION  1DCA
EA_SUB_SOURCE       1DA0
ENDADD              10C0
ENDBCC              10AC
ENDBCLR             10DC
ENDBCLRI            1090
ENDCMP              10D8
ENDCMPI             10A8
ENDDIVSL            1088
ENDDIVSW            10D4
ENDEOR              10B8
ENDJSR              1094
ENDLEA              10E0
ENDMOVE             10E8
ENDMOVEA            10C4
ENDMOVEM            109C
ENDMULSL            1084
ENDMULSW            10D0
ENDNEG              10B0
ENDNOP              1078
ENDOP               10F6
ENDOR               10BC
ENDORI              10A4
ENDRTS              107C
ENDSHIFT            10EC
ENDSTRTOHEX         1846
ENDSUB              10C8
ENDSUBQ             10CC
END_SEARCH          2380
ENTERSTART          100C
ENTERTOCONTINUE     241A
EORB_CODE           B100
EORL_CODE           B180
EORSTRING           243D
EORW_CODE           B140
ERROR               2380
GETOP               1072
GREETING0           2388
GREETING1           23C9
GREETING2           23EB
INVALIDADDRESS      18BE
INVALIDSTR          240C
IO_GET_WORD         21B2
IO_PRINT_OUTPUT     236A
IS0                 184E
IS1                 1856
IS2                 185C
IS3                 1862
IS4                 1868
IS5                 186E
IS6                 1874
IS7                 187A
IS8                 1880
IS9                 1886
ISA                 188E
ISADD               13D0
ISADDA              13FA
ISASL               160A
ISASR               15E0
ISB                 1896
ISBCLR              1688
ISBCS               16A4
ISBGE               16BC
ISBLT               16D4
ISBRA               1704
ISBVC               16EC
ISC                 189E
ISCMP               1534
ISCMPI              155E
ISD                 18A6
ISDATA              1A4E
ISDIVS              1514
ISE                 18AE
ISEOR               1356
ISF                 18B6
ISJSR               171C
ISLEA               1768
ISLSL               15B6
ISLSR               158C
ISMOVE              146E
ISMOVEA             143C
ISMOVEM             1428
ISMULS              14F4
ISNEG               174C
ISNOP               1342
ISOR                13AA
ISORI               1380
ISROL               165E
ISROR               1634
ISRTS               1734
ISSUB               149C
ISSUBQ              14C6
JSRSTRING           24AE
JSR_CODE            4E80
LEASTRING           24BB
LEA_CODE            41C0
LF                  A
LINECOUNTER         18CE
LOOP                1052
LSLSTRING           247D
LSL_CODE            E108
LSRSTRING           2481
LSR_CODE            E008
MASK15TO12          1A0A
MASK15TO6           1A1A
MASK15TO7           1A12
MASK15TO8           1A02
MASKMULDIVL         1A22
MASKSHIFT           1A2A
MOVEAL_CODE         2040
MOVEASTRING         2457
MOVEAW_CODE         3040
MOVEB_CODE          1000
MOVEL_CODE          2000
MOVEMM2R_CODE       4C80
MOVEMR2M_CODE       4880
MOVEMSTRING         2451
MOVESTRING          245D
MOVEW_CODE          3000
MULSL_CODE          800
MULSSTRING          246A
MULSW_CODE          C1C0
MYDATA              7FFF
N2ACHECK            1AF8
N2ACHECKSTACK       22E2
N2ASCII             1A6C
N2ASCII2            1A70
N2ASCIISTACK        21D2
N2ASCIISTACK2       21D6
NEGSTRING           24B6
NEG_CODE            4400
NEWLINE             2385
NOPSTRING           2439
NOP_CODE            4E71
OPMASK              F1C0
ORBDN_CODE          8000
ORBEA_CODE          8100
ORISTRING           2441
ORI_CODE            0
ORLDN_CODE          8080
ORLEA_CODE          8180
ORSTRING            2445
ORWDN_CODE          8040
ORWEA_CODE          8140
OUTADDRESS          1A32
OUTPUT_START        A000
PAGELENGTH          14
PAUSEPROGRAM        18DA
PAUSERETURN         18D8
PRINT0              1B04
PRINT1              1B0E
PRINT2              1B18
PRINT3              1B22
PRINT4              1B2C
PRINT5              1B36
PRINT6              1B40
PRINT7              1B4A
PRINT8              1B54
PRINT9              1B5E
PRINTA              1B68
PRINTB              1B72
PRINTC              1B7C
PRINTCHAR           1BA4
PRINTD              1B86
PRINTE              1B90
PRINTF              1B9A
PUSH0               2262
PUSH1               226A
PUSH2               2272
PUSH3               227A
PUSH4               2282
PUSH5               228A
PUSH6               2292
PUSH7               229A
PUSH8               22A2
PUSH9               22AA
PUSHA               22B2
PUSHB               22BA
PUSHC               22C2
PUSHD               22CA
PUSHE               22D2
PUSHF               22DA
ROLSTRING           248D
ROL_CODE            E118
RORSTRING           2491
ROR_CODE            E018
RTSSTRING           24B2
RTS_CODE            4E75
SIZE00              1964
SIZE000             1956
SIZE001             199C
SIZE01              1972
SIZE010             19AA
SIZE011             19E2
SIZE10              1980
SIZE100             19B8
SIZE101             19C6
SIZE11              198E
SIZE110             19D4
SIZE111             19EE
SPACE               2384
START               1000
STRTOHEX            1784
STRTOHEXLOOP        1790
SUBBDN_CODE         9000
SUBBEA_CODE         9100
SUBLDN_CODE         9080
SUBLEA_CODE         9180
SUBQB_CODE          5100
SUBQL_CODE          5180
SUBQSTRING          2466
SUBQW_CODE          5140
SUBSTRING           2462
SUBWDN_CODE         9040
SUBWEA_CODE         9140
TEST_END            1004
