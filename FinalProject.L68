00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/8/2014 8:44:49 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :Group 6 68k Decompiler
00000000                             3  * Written by :Zeke Snider and Joseph Sturtevan
00000000                             4  * Date       :12/7/2014
00000000                             5  * Description:Decompiler for CSS 422 Hardware
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  * Put program code here
00001000  43F9 000023E0             10              LEA     greeting0,A1    *Loads greeting into A1
00001006  103C 000D                 11              MOVE.B  #13,D0          *Sets up trap
0000100A  4E4F                      12              TRAP    #15
0000100C  43F9 00002421             13  enterStart  LEA     greeting1,A1    *Loads prompt into A1
00001012  103C 000E                 14              MOVE.B  #14,D0          *Sets up trap
00001016  4E4F                      15              TRAP    #15
00001018  43F9 0000A000             16              LEA     OUTPUT_START,A1 *Puts input into OUTPUT_START location
0000101E  103C 0002                 17              MOVE.B  #2,D0           *Sets up trap to accept input of starting address
00001022  4E4F                      18              TRAP    #15
00001024  6100 079E                 19              BSR     strToHex        *Converts the input to HEX
00001028  2A41                      20              MOVE.L  D1,A5           *Load start address
0000102A  43F9 00002443             21              LEA     greeting2,A1    *Loads prompt into A1
00001030  103C 000E                 22              MOVE.B  #14,D0          *Sets up trap
00001034  4E4F                      23              TRAP    #15
00001036  43F9 0000A000             24              LEA     OUTPUT_START,A1 *Puts input into OUTPUT_START location
0000103C  103C 0002                 25              MOVE.B  #2,D0           *Sets up trap to accept input of endinging address
00001040  4E4F                      26              TRAP    #15
00001042  6100 0780                 27              BSR     strToHex        *Converts the input to HEX
00001046  2C41                      28              MOVE.L  D1,A6           *Load ending address
00001048  BDCD                      29              CMP.L   A5,A6           *Checks to make sure A6 is after A5
0000104A  6F00 08B2                 30              BLE     invalidAddress  *Makes you resubmit addresses if input is invalid
0000104E  1F3C 0000                 31              MOVE.B  #0,-(sp)        *Moves initial line counter onto stack
00001052                            32          
00001052  4280                      33  loop        CLR.L   D0              *Gives fresh D0
00001054  101F                      34              MOVE.B  (sp)+,D0        *Moves line counter into D0 to check
00001056  6100 08B6                 35              BSR     linecounter     *Checks line count to see if we need to pause
0000105A  1F00                      36              MOVE.B  D0,-(sp)        *Moves line counter back to stack
0000105C  3015                      37              MOVE.W  (A5),D0         *Gets the data of where the pointer is at
0000105E  41F9 0000A000             38              LEA     OUTPUT_START,A0 *Sets up output for EA
00001064  6100 000C                 39              BSR     getOP           *Gets the data at add
00001068  544D                      40              ADDQ.W  #byte,A5        *Incrementing the pointer one word
0000106A  BACE                      41              CMPA.W  A6,A5           *Seeing if we're at end of the search area
0000106C  6E00 136A                 42              BGT     end_search      *go to end if we leave search area
00001070  60E0                      43              BRA     loop            *else go back to the beginning of the loop
00001072                            44              
00001072  3400                      45  getOP       MOVE.W  D0,D2           *Moves data to D2 to use
00001074  6000 0086                 46              BRA     compare_NOP     *compares the NOP op code
00001078  6000 02AC                 47  endNOP      BRA     compare_RTS     *Compares the RTS op code
0000107C                            48  endRTS
0000107C  6100 09E4                 49              BSR     maskMulDivL     *Masks to compare to MULS.L and DIVS.L
00001080  6000 01B8                 50              BRA     compare_MULSL   *Compares the MULS.L op code
00001084  6000 01C0                 51  endMULSL    BRA     compare_DIVSL   *Compares the DIVS.L op code
00001088                            52  endDIVSL
00001088  6100 09D0                 53              BSR     mask15to6       *Masks to compare BCLR
0000108C  6000 0240                 54              BRA     compare_BCLRI   *Compare to BCLR with an immidiate
00001090  6000 0288                 55  endBCLRI    BRA     compare_JSR     *Compare to JSR
00001094                            56  endJSR
00001094  6100 09BC                 57              BSR     mask15to7       *Masks to compare to MoveM
00001098  6000 010C                 58              BRA     compare_MOVEM   *Compares to MoveM
0000109C                            59  endMOVEM
0000109C  6100 09A4                 60              BSR     mask15to8       *Masks to the first byte
000010A0  6000 0066                 61              BRA     compare_ORI     *Compares the ORI op codes
000010A4  6000 01E0                 62  endORI      BRA     compare_CMPI    *Compares the CMPI op code
000010A8  6000 023C                 63  endCMPI     BRA     compare_Bcc     *Compares the Bcc op codes
000010AC  6000 0284                 64  endBcc      BRA     compare_NEG     *Compares the NEG op code
000010B0                            65  endNEG
000010B0  6100 0988                 66              BSR     compMask        *Masks D2 to make comparisons easier
000010B4  6000 0090                 67              BRA     compare_EOR     *Compares the EOR op codes
000010B8  6000 0058                 68  endEOR      BRA     compare_OR      *Compares the OR op codes
000010BC  6000 00A4                 69  endOR       BRA     compare_ADD     *Compares the ADD op codes
000010C0  6000 00F8                 70  endADD      BRA     compare_MOVEA   *Compares the MOVEA op codes
000010C4  6000 0124                 71  endMOVEA    BRA     compare_SUB     *Compares the SUB op codes
000010C8  6000 0154                 72  endSUB      BRA     compare_SUBQ    *Compares the SUBQ op codes
000010CC  6000 0184                 73  endSUBQ     BRA     compare_MULSW   *Compares the MULS.W op code
000010D0  6000 018C                 74  endMULSW    BRA     compare_DIVSW   *Compares the DIVS.W op code
000010D4  6000 0194                 75  endDIVSW    BRA     compare_CMP     *Compares the CMP op codes
000010D8  6000 0200                 76  endCMP      BRA     compare_BCLR    *Compares the BCLR without immidate op code
000010DC  6000 0260                 77  endBCLR     BRA     compare_LEA     *Compares the LEA op code
000010E0                            78  endLEA
000010E0  6100 0968                 79              BSR     mask15to12      *Masks D2 to first 4 bits
000010E4  6000 00E8                 80              BRA     compare_MOVE    *Compares the MOVE op codes
000010E8  6000 01A8                 81  endMOVE     BRA     compare_shift   *Compares LSL,LSR, ASL, and ASR
000010EC                            82  endshift
000010EC                            83                                      *if we get here, the operation is unknown
000010EC  3400                      84              MOVE.W  D0,D2           *Restores D2 to default
000010EE  6100 0982                 85              BSR     outaddress      *Data unknown, just print the address
000010F2  6100 099A                 86  printData   BSR     isData          *And then the data
000010F6  6100 12A6                 87  endOP       BSR     IO_PRINT_OUTPUT *Prints EA output
000010FA  4E75                      88  endOP1      RTS                     *Returns to caller
000010FC                            89  
000010FC                            90  *Comparison subroutines, broken up by Operation
000010FC                            91  compare_NOP
000010FC  B47C 4E71                 92              CMP.W   #nop_code,D2    *Compares to NOP
00001100  6700 0248                 93              BEQ     isNOP           *Skips the return if it is NOP
00001104  6000 FF72                 94              BRA     endNOP
00001108                            95  
00001108                            96  compare_ORI
00001108  B47C 0000                 97              CMP.W   #ori_code,D2    *Compares to ORI
0000110C  6700 027A                 98              BEQ     isORI
00001110  6092                      99              BRA     endORI
00001112                           100              
00001112                           101  compare_OR
00001112  B47C 8000                102              CMP.W   #orbDn_code,D2  *Compares to ORI.B -> Dn
00001116  6700 029A                103              BEQ     isOR
0000111A  B47C 8040                104              CMP.W   #orwDn_code,D2  *Compares to ORI.W -> Dn
0000111E  6700 0292                105              BEQ     isOR
00001122  B47C 8080                106              CMP.W   #orlDn_code,D2  *Compares to ORI.L -> Dn
00001126  6700 028A                107              BEQ     isOR
0000112A  B47C 8100                108              CMP.W   #orbEA_code,D2  *Compares to ORI.B -> EA
0000112E  6700 0282                109              BEQ     isOR
00001132  B47C 8140                110              CMP.W   #orwEA_code,D2  *Compares to ORI.W -> EA
00001136  6700 027A                111              BEQ     isOR
0000113A  B47C 8180                112              CMP.W   #orlEA_code,D2  *Compares to ORI.L -> EA
0000113E  6700 0272                113              BEQ     isOR
00001142  6000 FF78                114              BRA     endOR
00001146                           115              
00001146                           116  compare_EOR
00001146  B47C B100                117              CMP.W   #eorb_code,D2   *Compares to EOR.B
0000114A  6700 0212                118              BEQ     isEOR
0000114E  B47C B140                119              CMP.W   #eorw_code,D2   *Compares to EOR.W
00001152  6700 020A                120              BEQ     isEOR
00001156  B47C B180                121              CMP.W   #eorl_code,D2   *Compares to EOR.L
0000115A  6700 0202                122              BEQ     isEOR
0000115E  6000 FF58                123              BRA     endEOR
00001162                           124              
00001162                           125  compare_ADD
00001162  B47C D000                126              CMP.W   #addbDn_code,D2 *Compares to ADD.B -> Dn
00001166  6700 0270                127              BEQ     isADD
0000116A  B47C D040                128              CMP.W   #addwDn_code,D2 *Compares to ADD.W -> Dn
0000116E  6700 0268                129              BEQ     isADD
00001172  B47C D080                130              CMP.W   #addlDn_code,D2 *Compares to ADD.L -> Dn
00001176  6700 0260                131              BEQ     isADD
0000117A  B47C D100                132              CMP.W   #addbEA_code,D2 *Compares to ADD.B -> EA
0000117E  6700 0258                133              BEQ     isADD
00001182  B47C D140                134              CMP.W   #addwEA_code,D2 *Compares to ADD.W -> EA
00001186  6700 0250                135              BEQ     isADD
0000118A  B47C D180                136              CMP.W   #addlEA_code,D2 *Compares to ADD.L -> EA
0000118E  6700 0248                137              BEQ     isADD
00001192  B47C D0C0                138              CMP.W   #addaw_code,D2  *Compares to ADDA.W
00001196  6700 026A                139              BEQ     isADDA
0000119A  B47C D1C0                140              CMP.W   #addal_code,D2  *Compares to ADDA.L
0000119E  6700 0262                141              BEQ     isADDA
000011A2  6000 FF1C                142              BRA     endADD
000011A6                           143  
000011A6                           144  compare_MOVEM
000011A6  B47C 4880                145              CMP.W   #movemr2m_code,D2 *Compares to MOVEM Register to memory
000011AA  6700 0284                146              BEQ     isMOVEM
000011AE  B47C 4C80                147              CMP.W   #movemm2r_code,D2 *Compares to MOVEM memory to register
000011B2  6700 027C                148              BEQ     isMOVEM
000011B6  6000 FEE4                149              BRA     endMOVEM
000011BA                           150  
000011BA                           151  compare_MOVEA
000011BA  B47C 3040                152              CMP.W   #moveaw_code,D2 *Compares to MOVEA word operation
000011BE  6700 0284                153              BEQ     isMOVEA
000011C2  B47C 2040                154              CMP.W   #moveal_code,D2 *Compares to MOVEA long operation
000011C6  6700 027C                155              BEQ     isMOVEA
000011CA  6000 FEF8                156              BRA     endMOVEA
000011CE                           157  
000011CE                           158  compare_MOVE
000011CE  B47C 1000                159              CMP.W   #moveb_code,D2  *Compares to MOVE byte operation
000011D2  6700 02A2                160              BEQ     isMOVE
000011D6  B47C 3000                161              CMP.W   #movew_code,D2  *Compares to MOVE word operation
000011DA  6700 029A                162              BEQ     isMOVE
000011DE  B47C 2000                163              CMP.W   #movel_code,D2  *Compares to MOVE long operation
000011E2  6700 0292                164              BEQ     isMOVE
000011E6  6000 FF00                165              BRA     endMOVE
000011EA                           166  
000011EA                           167  compare_SUB
000011EA  B47C 9000                168              CMP.W   #subbDn_code,D2 *Compares to SUB.B -> Dn
000011EE  6700 02B4                169              BEQ     isSUB
000011F2  B47C 9040                170              CMP.W   #subwDn_code,D2 *Compares to SUB.W -> Dn
000011F6  6700 02AC                171              BEQ     isSUB
000011FA  B47C 9080                172              CMP.W   #sublDn_code,D2 *Compares to SUB.L -> Dn
000011FE  6700 02A4                173              BEQ     isSUB
00001202  B47C 9100                174              CMP.W   #subbEA_code,D2 *Compares to SUB.B -> EA
00001206  6700 029C                175              BEQ     isSUB
0000120A  B47C 9140                176              CMP.W   #subwEA_code,D2 *Compares to SUB.W -> EA
0000120E  6700 0294                177              BEQ     isSUB
00001212  B47C 9180                178              CMP.W   #sublEA_code,D2 *Compares to SUB.L -> EA
00001216  6700 028C                179              BEQ     isSUB
0000121A  6000 FEAC                180              BRA     endSUB
0000121E                           181  
0000121E                           182  compare_SUBQ
0000121E  B47C 5100                183              CMP.W   #subqb_code,D2   *Compares to SUBQ.B
00001222  6700 02AA                184              BEQ     isSUBQ
00001226  B47C 5140                185              CMP.W   #subqw_code,D2   *Compares to SUBQ.W
0000122A  6700 02A2                186              BEQ     isSUBQ
0000122E  B47C 5180                187              CMP.W   #subql_code,D2   *Compares to SUBQ.L
00001232  6700 029A                188              BEQ     isSUBQ
00001236  6000 FE94                189              BRA     endSUBQ
0000123A                           190  
0000123A                           191  compare_MULSL
0000123A  B47C 0800                192              CMP.W   #mulsl_code,D2  *Compares to MULS.L
0000123E  6700 02BC                193              BEQ     isMULS
00001242  6000 FE40                194              BRA     endMULSL
00001246                           195  
00001246                           196  compare_DIVSL
00001246  B47C 0840                197              CMP.W   #divsl_code,D2  *Compares to DIVS.L
0000124A  6700 02D0                198              BEQ     isDIVS
0000124E  6000 FE38                199              BRA     endDIVSL
00001252                           200   
00001252                           201  compare_MULSW
00001252  B47C C1C0                202              CMP.W   #mulsw_code,D2  *Compares to MULS.W
00001256  6700 02A4                203              BEQ     isMULS
0000125A  6000 FE74                204              BRA     endMULSW
0000125E                           205  
0000125E                           206  compare_DIVSW
0000125E  B47C 81C0                207              CMP.W   #divsw_code,D2  *Compares to DIVS.W
00001262  6700 02B8                208              BEQ     isDIVS
00001266  6000 FE6C                209              BRA     endDIVSW
0000126A                           210  
0000126A                           211  compare_CMP
0000126A  B47C B000                212              CMP.W   #cmpb_code,D2   *Compares to CMP.B
0000126E  6700 02CC                213              BEQ     isCMP
00001272  B47C B040                214              CMP.W   #cmpw_code,D2   *Compares to CMP.W
00001276  6700 02C4                215              BEQ     isCMP
0000127A  B47C B080                216              CMP.W   #cmpl_code,D2   *Compares to CMP.L
0000127E  6700 02BC                217              BEQ     isCMP
00001282  6000 FE54                218              BRA     endCMP
00001286                           219  
00001286                           220  compare_CMPI
00001286  B47C 0C00                221              CMP.W   #cmpi_code,D2   *Compares to CMPI
0000128A  6700 02DA                222              BEQ     isCMPI
0000128E  6000 FE18                223              BRA     endCMPI
00001292                           224  
00001292                           225  compare_shift
00001292  6100 07D6                226              BSR     maskShift        *Masks to shift type and direction
00001296  B47C E008                227              CMP.W   #lsr_code,D2    *Compares to LSR
0000129A  6700 02F8                228              BEQ     isLSR
0000129E  B47C E108                229              CMP.W   #lsl_code,D2    *Compares to LSL
000012A2  6700 031A                230              BEQ     isLSL
000012A6  B47C E000                231              CMP.W   #asr_code,D2    *Compares to ASR
000012AA  6700 033C                232              BEQ     isASR
000012AE  B47C E100                233              CMP.W   #asl_code,D2    *Compares to ASL
000012B2  6700 035E                234              BEQ     isASL
000012B6  B47C E018                235              CMP.W   #ror_code,D2    *Compares to ROR
000012BA  6700 0380                236              BEQ     isROR
000012BE  B47C E118                237              CMP.W   #rol_code,D2    *Compares to ROL
000012C2  6700 03A2                238              BEQ     isROL
000012C6  6100 0782                239              BSR     mask15to12      *Returns the 15to12 mask
000012CA  6000 FE20                240              BRA     endshift
000012CE                           241  
000012CE                           242  compare_BCLRI
000012CE  B47C 0880                243              CMP.W   #bclri_code,D2  *Compares to BCLR with an immidiate
000012D2  6700 03BC                244              BEQ     isBCLR
000012D6  6000 FDB8                245              BRA     endBCLRI
000012DA                           246  
000012DA                           247  compare_BCLR
000012DA  B47C 0180                248              CMP.W   #bclr_code,D2   *Compares to BCLR
000012DE  6700 03B0                249              BEQ     isBCLR
000012E2  6000 FDF8                250              BRA     endBCLR
000012E6                           251  
000012E6                           252  compare_Bcc
000012E6  B47C 6500                253              CMP.W   #bcs_code,D2    *Compares to BCS
000012EA  6700 03C0                254              BEQ     isBCS
000012EE  B47C 6C00                255              CMP.W   #bge_code,D2    *Compares to BGE
000012F2  6700 03D0                256              BEQ     isBGE
000012F6  B47C 6D00                257              CMP.W   #blt_code,D2    *Compares to BLT
000012FA  6700 03E0                258              BEQ     isBLT
000012FE  B47C 6800                259              CMP.W   #bvc_code,D2    *Compares to BVC
00001302  6700 03F0                260              BEQ     isBVC
00001306  B47C 6000                261              CMP.W   #bra_code,D2    *Compares to BRA
0000130A  6700 0400                262              BEQ     isBRA
0000130E  B47C 6100                263              CMP.W   #BSR_code,D2    *Compares to BSR
00001312  6700 041C                264              BEQ     isBSR
00001316  6000 FD94                265              BRA     endBcc
0000131A                           266  
0000131A                           267  compare_JSR
0000131A  B47C 4E80                268              CMP.W   #jsr_code,D2    *Compares to JSR
0000131E  6700 042C                269              BEQ     isJSR
00001322  6000 FD70                270              BRA     endJSR
00001326                           271  
00001326                           272  compare_RTS
00001326  B47C 4E75                273              CMP.W   #rts_code,D2    *Compares to RTS
0000132A  6700 0438                274              BEQ     isRTS
0000132E  6000 FD4C                275              BRA     endRTS
00001332                           276  
00001332                           277  compare_NEG
00001332  B47C 4400                278              CMP.W   #neg_code,D2    *Compares to NEG
00001336  6700 0444                279              BEQ     isNEG
0000133A  6000 FD74                280              BRA     endNEG
0000133E                           281  
0000133E                           282  compare_LEA
0000133E  B47C 41C0                283              CMP.W   #lea_code,D2    *Compares to LEA
00001342  6700 0454                284              BEQ     isLEA
00001346  6000 FD98                285              BRA     endLEA
0000134A                           286  
0000134A                           287  *If compare is successful, we go to one of the isX
0000134A  6100 0726                288  isNOP       BSR     outaddress      *prints current address
0000134E  43F9 0000249E            289              LEA     NOPstring,A1    *Loads NOPstring for printing
00001354  103C 000D                290              MOVE.B  #13,D0          *Sets up trap
00001358  4E4F                     291              TRAP    #15
0000135A  6000 FD9A                292              BRA     endOP            
0000135E  6100 0712                293  isEOR       BSR     outaddress      *prints current address
00001362  6100 11E2                294              BSR     BitMask6to8     *Masking size bits
00001366  1607                     295              MOVE.B  D7,D3           *Moving result to D3
00001368  10FC 0045                296              MOVE.B  #'E',(A0)+
0000136C  10FC 004F                297              MOVE.B  #'O',(A0)+
00001370  10FC 0052                298              MOVE.B  #'R',(A0)+
00001374  10FC 002E                299              MOVE.B  #'.',(A0)+
00001378  6100 05BA                300              BSR     checkSize       *Finding size, outputting it, and storing it
0000137C  10FC 0020                301              MOVE.B  #' ',(A0)+
00001380  6100 0884                302              BSR     EA_EOR
00001384  6000 FD70                303              BRA     endOP            
00001388  6100 06E8                304  isORI       BSR     outaddress      *prints current address
0000138C  6100 11C6                305              BSR     BitMask6to7     *Masking size bits
00001390  1607                     306              MOVE.B  D7,D3           *Moving result to D3
00001392  10FC 004F                307              MOVE.B  #'O',(A0)+
00001396  10FC 0052                308              MOVE.B  #'R',(A0)+
0000139A  10FC 0049                309              MOVE.B  #'I',(A0)+
0000139E  10FC 002E                310              MOVE.B  #'.',(A0)+
000013A2  6100 0590                311              BSR     checkSize       *Finding size, outputting it, and storing it
000013A6  10FC 0020                312              MOVE.B  #' ',(A0)+
000013AA  6100 0922                313              BSR     EA_ORI
000013AE  6000 FD46                314              BRA     endOP
000013B2  6100 06BE                315  isOR        BSR     outaddress      *prints current address
000013B6  6100 118E                316              BSR     BitMask6to8     *Masking size bits
000013BA  1607                     317              MOVE.B  D7,D3           *Moving result to D3
000013BC  10FC 004F                318              MOVE.B  #'O',(A0)+
000013C0  10FC 0052                319              MOVE.B  #'R',(A0)+
000013C4  10FC 002E                320              MOVE.B  #'.',(A0)+
000013C8  6100 056A                321              BSR     checkSize       *Finding size, outputting it, and storing it
000013CC  10FC 0020                322              MOVE.B  #' ',(A0)+
000013D0  6100 0886                323              BSR     EA_OR
000013D4  6000 FD20                324              BRA     endOP
000013D8  6100 0698                325  isADD       BSR     outaddress      *prints current address
000013DC  6100 1168                326              BSR     BitMask6to8     *Masking size bits
000013E0  1607                     327              MOVE.B  D7,D3           *Moving result to D3
000013E2  10FC 0041                328              MOVE.B  #'A',(A0)+
000013E6  10FC 0044                329              MOVE.B  #'D',(A0)+
000013EA  10FC 0044                330              MOVE.B  #'D',(A0)+
000013EE  10FC 002E                331              MOVE.B  #'.',(A0)+
000013F2  6100 0540                332              BSR     checkSize       *Finding size, outputting it, and storing it
000013F6  10FC 0020                333              MOVE.B  #' ',(A0)+
000013FA  6100 0A2E                334              BSR     EA_ADD
000013FE  6000 FCF6                335              BRA     endOP
00001402  6100 066E                336  isADDA      BSR     outaddress      *prints current address
00001406  6100 113E                337              BSR     BitMask6to8     *Masking size bits
0000140A  3607                     338              MOVE.W  D7,D3           *Moving result to D3
0000140C  10FC 0041                339              MOVE.B  #'A',(A0)+
00001410  10FC 0044                340              MOVE.B  #'D',(A0)+
00001414  10FC 0044                341              MOVE.B  #'D',(A0)+
00001418  10FC 0041                342              MOVE.B  #'A',(A0)+
0000141C  10FC 002E                343              MOVE.B  #'.',(A0)+
00001420  6100 0512                344              BSR     checkSize       *Finding size, outputting it, and storing it
00001424  10FC 0020                345              MOVE.B  #' ',(A0)+
00001428  6100 080A                346              BSR     EA_ADDA
0000142C  6000 FCC8                347              BRA     endOP
00001430  6100 0640                348  isMOVEM     BSR     outaddress      *prints current address
00001434  43F9 000024B6            349              LEA     MOVEMstring,A1  *Loads MOVEMstring for printing
0000143A  103C 000D                350              MOVE.B  #13,D0          *Sets up trap
0000143E  4E4F                     351              TRAP    #15
00001440  6000 FCB4                352              BRA     endOP
00001444  6100 062C                353  isMOVEA     BSR     outaddress      *prints current address
00001448  6100 113E                354              BSR     BitMask12to13   *Masking size bits
0000144C  3607                     355              MOVE.W  D7,D3           *Moving result to D3
0000144E  10FC 004D                356              MOVE.B  #'M',(A0)+
00001452  10FC 004F                357              MOVE.B  #'O',(A0)+
00001456  10FC 0056                358              MOVE.B  #'V',(A0)+
0000145A  10FC 0045                359              MOVE.B  #'E',(A0)+
0000145E  10FC 0041                360              MOVE.B  #'A',(A0)+
00001462  10FC 002E                361              MOVE.B  #'.',(A0)+
00001466  6100 04CC                362              BSR     checkSize       *Finding size, outputting it, and storing it
0000146A  10FC 0020                363              MOVE.B  #' ',(A0)+
0000146E  6100 0A8A                364              BSR     EA_MOVEA
00001472  6000 FC82                365              BRA     endOP
00001476  6100 05FA                366  isMOVE      BSR     outaddress      *prints current address
0000147A  6100 110C                367              BSR     BitMask12to13   *Masking size bits
0000147E  3607                     368              MOVE.W  D7,D3           *Moving result to D3
00001480  10FC 004D                369              MOVE.B  #'M',(A0)+
00001484  10FC 004F                370              MOVE.B  #'O',(A0)+
00001488  10FC 0056                371              MOVE.B  #'V',(A0)+
0000148C  10FC 0045                372              MOVE.B  #'E',(A0)+
00001490  10FC 002E                373              MOVE.B  #'.',(A0)+
00001494  6100 049E                374              BSR     checkSize       *Finding size, outputting it, and storing it
00001498  10FC 0020                375              MOVE.B  #' ',(A0)+
0000149C  6100 0A2A                376              BSR     EA_MOVE
000014A0  6000 FC54                377              BRA     endOP
000014A4  6100 05CC                378  isSUB       BSR     outaddress      *prints current address
000014A8  6100 109C                379              BSR     BitMask6to8     *Masking size bits
000014AC  1607                     380              MOVE.B  D7,D3           *Moving result to D3
000014AE  10FC 0053                381              MOVE.B  #'S',(A0)+
000014B2  10FC 0055                382              MOVE.B  #'U',(A0)+
000014B6  10FC 0042                383              MOVE.B  #'B',(A0)+
000014BA  10FC 002E                384              MOVE.B  #'.',(A0)+
000014BE  6100 0474                385              BSR     checkSize       *Finding size, outputting it, and storing it
000014C2  10FC 0020                386              MOVE.B  #' ',(A0)+
000014C6  6100 08DE                387              BSR     EA_SUB
000014CA  6000 FC2A                388              BRA     endOP
000014CE  6100 05A2                389  isSUBQ      BSR     outaddress      *prints current address
000014D2  6100 1080                390              BSR     BitMask6to7     *Masking size bits
000014D6  1607                     391              MOVE.B  D7,D3           *Moving result to D3
000014D8  10FC 0053                392              MOVE.B  #'S',(A0)+
000014DC  10FC 0055                393              MOVE.B  #'U',(A0)+
000014E0  10FC 0042                394              MOVE.B  #'B',(A0)+
000014E4  10FC 0051                395              MOVE.B  #'Q',(A0)+
000014E8  10FC 002E                396              MOVE.B  #'.',(A0)+
000014EC  6100 0446                397              BSR     checkSize       *Finding size, outputting it, and storing it
000014F0  10FC 0020                398              MOVE.B  #' ',(A0)+
000014F4  6100 099C                399              BSR     EA_SUBQ
000014F8  6000 FBFC                400              BRA     endOP
000014FC  6100 0574                401  isMULS      BSR     outaddress      *prints current address
00001500  10FC 004D                402              MOVE.B  #'M',(A0)+
00001504  10FC 0055                403              MOVE.B  #'U',(A0)+
00001508  10FC 004C                404              MOVE.B  #'L',(A0)+
0000150C  10FC 0053                405              MOVE.B  #'S',(A0)+
00001510  10FC 0020                406              MOVE.B  #' ',(A0)+
00001514  6100 0A54                407              BSR     EA_MULS
00001518  6000 FBDC                408              BRA     endOP
0000151C  6100 0554                409  isDIVS      BSR     outaddress      *prints current address
00001520  10FC 0044                410              MOVE.B  #'D',(A0)+
00001524  10FC 0049                411              MOVE.B  #'I',(A0)+
00001528  10FC 0056                412              MOVE.B  #'V',(A0)+
0000152C  10FC 0053                413              MOVE.B  #'S',(A0)+
00001530  10FC 0020                414              MOVE.B  #' ',(A0)+
00001534  6100 0A60                415              BSR     EA_DIVS
00001538  6000 FBBC                416              BRA     endOP
0000153C  6100 0534                417  isCMP       BSR     outaddress      *prints current address
00001540  6100 1004                418              BSR     BitMask6to8     *Masking size bits
00001544  3607                     419              MOVE.W  D7,D3           *Moving result to D3
00001546  10FC 0043                420              MOVE.B  #'C',(A0)+
0000154A  10FC 004D                421              MOVE.B  #'M',(A0)+
0000154E  10FC 0050                422              MOVE.B  #'P',(A0)+
00001552  10FC 002E                423              MOVE.B  #'.',(A0)+
00001556  6100 03DC                424              BSR     checkSize      *Finding size, outputting it, and storing it
0000155A  10FC 0020                425              MOVE.B  #' ',(A0)+
0000155E  6100 09BE                426              BSR     EA_CMP
00001562  6000 FB92                427              BRA     endOP
00001566  6100 050A                428  isCMPI      BSR     outaddress      *prints current address
0000156A  6100 0FE8                429              BSR     BitMask6to7     *Masking size bits
0000156E  3607                     430              MOVE.W  D7,D3           *Moving result to D3
00001570  10FC 0043                431              MOVE.B  #'C',(A0)+
00001574  10FC 004D                432              MOVE.B  #'M',(A0)+
00001578  10FC 0050                433              MOVE.B  #'P',(A0)+
0000157C  10FC 0049                434              MOVE.B  #'I',(A0)+
00001580  10FC 002E                435              MOVE.B  #'.',(A0)+
00001584  6100 03AE                436              BSR     checkSize       *Finding size, outputting it, and storing it
00001588  10FC 0020                437              MOVE.B  #' ',(A0)+
0000158C  6100 09B4                438              BSR     EA_CMPI
00001590  6000 FB64                439              BRA     endOP
00001594  6100 04DC                440  isLSR       BSR     outaddress      *prints current address
00001598  6100 0FBA                441              BSR     BitMask6to7     *Masking size bits
0000159C  3607                     442              MOVE.W  D7,D3           *Moving result to D3
0000159E  10FC 004C                443              MOVE.B  #'L',(A0)+
000015A2  10FC 0053                444              MOVE.B  #'S',(A0)+
000015A6  10FC 0052                445              MOVE.B  #'R',(A0)+
000015AA  10FC 002E                446              MOVE.B  #'.',(A0)+
000015AE  6100 0384                447              BSR     checkSize       *Finding size, outputting it, and storing it            
000015B2  10FC 0020                448              MOVE.B  #' ',(A0)+
000015B6  6100 0A0A                449              BSR     EA_LS_REGISTER
000015BA  6000 FB3A                450              BRA     endOP
000015BE  6100 04B2                451  isLSL       BSR     outaddress      *prints current address
000015C2  6100 0F90                452              BSR     BitMask6to7     *Masking size bits
000015C6  3607                     453              MOVE.W  D7,D3           *Moving result to D3
000015C8  10FC 004C                454              MOVE.B  #'L',(A0)+
000015CC  10FC 0053                455              MOVE.B  #'S',(A0)+
000015D0  10FC 004C                456              MOVE.B  #'L',(A0)+
000015D4  10FC 002E                457              MOVE.B  #'.',(A0)+
000015D8  6100 035A                458              BSR     checkSize       *Finding size, outputting it, and storing it
000015DC  10FC 0020                459              MOVE.B  #' ',(A0)+
000015E0  6100 09E0                460              BSR     EA_LS_REGISTER
000015E4  6000 FB10                461              BRA     endOP
000015E8  6100 0488                462  isASR       BSR     outaddress      *prints current address
000015EC  6100 0F66                463              BSR     BitMask6to7     *Masking size bits
000015F0  3607                     464              MOVE.W  D7,D3           *Moving result to D3
000015F2  10FC 0041                465              MOVE.B  #'A',(A0)+
000015F6  10FC 0053                466              MOVE.B  #'S',(A0)+
000015FA  10FC 0052                467              MOVE.B  #'R',(A0)+
000015FE  10FC 002E                468              MOVE.B  #'.',(A0)+
00001602  6100 0330                469              BSR     checkSize       *Finding size, outputting it, and storing it
00001606  10FC 0020                470              MOVE.B  #' ',(A0)+
0000160A  6100 0A28                471              BSR     EA_AS_REGISTER
0000160E  6000 FAE6                472              BRA     endOP 
00001612  6100 045E                473  isASL       BSR     outaddress      *prints current address
00001616  6100 0F3C                474              BSR     BitMask6to7     *Masking size bits
0000161A  3607                     475              MOVE.W  D7,D3           *Moving result to D3
0000161C  10FC 0041                476              MOVE.B  #'A',(A0)+
00001620  10FC 0053                477              MOVE.B  #'S',(A0)+
00001624  10FC 004C                478              MOVE.B  #'L',(A0)+
00001628  10FC 002E                479              MOVE.B  #'.',(A0)+
0000162C  6100 0306                480              BSR     checkSize       *Finding size, outputting it, and storing it
00001630  10FC 0020                481              MOVE.B  #' ',(A0)+
00001634  6100 09FE                482              BSR     EA_AS_REGISTER
00001638  6000 FABC                483              BRA     endOP
0000163C  6100 0434                484  isROR       BSR     outaddress      *prints current address
00001640  6100 0F12                485              BSR     BitMask6to7     *Masking size bits
00001644  3607                     486              MOVE.W  D7,D3           *Moving result to D3
00001646  10FC 0052                487              MOVE.B  #'R',(A0)+
0000164A  10FC 004F                488              MOVE.B  #'O',(A0)+
0000164E  10FC 0052                489              MOVE.B  #'R',(A0)+
00001652  10FC 002E                490              MOVE.B  #'.',(A0)+
00001656  6100 02DC                491              BSR     checkSize       *Finding size, outputting it, and storing it
0000165A  10FC 0020                492              MOVE.B  #' ',(A0)+
0000165E  6100 0A42                493              BSR     EA_RO_REGISTER
00001662  6000 FA92                494              BRA     endOP
00001666  6100 040A                495  isROL       BSR     outaddress      *prints current address
0000166A  6100 0EE8                496              BSR     BitMask6to7     *Masking size bits
0000166E  3607                     497              MOVE.W  D7,D3           *Moving result to D3
00001670  10FC 0052                498              MOVE.B  #'R',(A0)+
00001674  10FC 004F                499              MOVE.B  #'O',(A0)+
00001678  10FC 004C                500              MOVE.B  #'L',(A0)+
0000167C  10FC 002E                501              MOVE.B  #'.',(A0)+
00001680  6100 02B2                502              BSR     checkSize       *Finding size, outputting it, and storing it
00001684  10FC 0020                503              MOVE.B  #' ',(A0)+
00001688  6100 0A18                504              BSR     EA_RO_REGISTER
0000168C  6000 FA68                505              BRA     endOP
00001690  6100 03E0                506  isBCLR      BSR     outaddress      *prints current address
00001694  10FC 0042                507              MOVE.B  #'B',(A0)+
00001698  10FC 0043                508              MOVE.B  #'C',(A0)+
0000169C  10FC 004C                509              MOVE.B  #'L',(A0)+
000016A0  10FC 0052                510              MOVE.B  #'R',(A0)+
000016A4  10FC 0020                511              MOVE.B  #' ',(A0)+
000016A8  6000 FA4C                512              BRA     endOP
000016AC  6100 03C4                513  isBCS       BSR     outaddress      *prints current address
000016B0  10FC 0042                514              MOVE.B  #'B',(A0)+
000016B4  10FC 0043                515              MOVE.B  #'C',(A0)+
000016B8  10FC 0053                516              MOVE.B  #'S',(A0)+
000016BC  10FC 0020                517              MOVE.B  #' ',(A0)+
000016C0  6000 FA34                518              BRA     endOP
000016C4  6100 03AC                519  isBGE       BSR     outaddress      *prints current address
000016C8  10FC 0042                520              MOVE.B  #'B',(A0)+
000016CC  10FC 0047                521              MOVE.B  #'G',(A0)+
000016D0  10FC 0045                522              MOVE.B  #'E',(A0)+
000016D4  10FC 0020                523              MOVE.B  #' ',(A0)+
000016D8  6000 FA1C                524              BRA     endOP
000016DC  6100 0394                525  isBLT       BSR     outaddress      *prints current address
000016E0  10FC 0042                526              MOVE.B  #'B',(A0)+
000016E4  10FC 004C                527              MOVE.B  #'L',(A0)+
000016E8  10FC 0054                528              MOVE.B  #'T',(A0)+
000016EC  10FC 0020                529              MOVE.B  #' ',(A0)+
000016F0  6000 FA04                530              BRA     endOP
000016F4  6100 037C                531  isBVC       BSR     outaddress      *prints current address
000016F8  10FC 0042                532              MOVE.B  #'B',(A0)+
000016FC  10FC 0056                533              MOVE.B  #'V',(A0)+
00001700  10FC 0043                534              MOVE.B  #'C',(A0)+
00001704  10FC 0020                535              MOVE.B  #' ',(A0)+
00001708  6000 F9EC                536              BRA     endOP
0000170C  6100 0364                537  isBRA       BSR     outaddress      *prints current address
00001710  10FC 0042                538              MOVE.B  #'B',(A0)+
00001714  10FC 0052                539              MOVE.B  #'R',(A0)+
00001718  10FC 0041                540              MOVE.B  #'A',(A0)+
0000171C  10FC 0020                541              MOVE.B  #' ',(A0)+
00001720  B03C 0000                542              CMP.B   #$00,D0         *Checks if there's immidiate data
00001724  6600 0006                543              BNE     isBRA1
00001728  6100 008A                544              BSR     calcDisplacement
0000172C  6000 F9C8                545  isBRA1      BRA     endOP
00001730  6100 0340                546  isBSR       BSR     outaddress      *prints currentaddress
00001734  10FC 0042                547              MOVE.B  #'B',(A0)+
00001738  10FC 0053                548              MOVE.B  #'S',(A0)+
0000173C  10FC 0052                549              MOVE.B  #'R',(A0)+
00001740  10FC 0020                550              MOVE.B  #' ',(A0)+
00001744  6100 006E                551              BSR     calcDisplacement
00001748  6000 F9AC                552              BRA     endOP
0000174C  6100 0324                553  isJSR       BSR     outaddress      *prints current address
00001750  10FC 004A                554              MOVE.B  #'J',(A0)+
00001754  10FC 0053                555              MOVE.B  #'S',(A0)+
00001758  10FC 0052                556              MOVE.B  #'R',(A0)+
0000175C  10FC 0020                557              MOVE.B  #' ',(A0)+
00001760  6000 F994                558              BRA     endOP
00001764  6100 030C                559  isRTS       BSR     outaddress      *prints current address
00001768  10FC 0052                560              MOVE.B  #'R',(A0)+
0000176C  10FC 0054                561              MOVE.B  #'T',(A0)+
00001770  10FC 0053                562              MOVE.B  #'S',(A0)+
00001774  10FC 0020                563              MOVE.B  #' ',(A0)+
00001778  6000 F97C                564              BRA     endOP
0000177C                           565  isNEG       
0000177C  6100 02F4                566              BSR     outaddress      *prints current address
00001780  10FC 004E                567              MOVE.B  #'N',(A0)+
00001784  10FC 0045                568              MOVE.B  #'E',(A0)+
00001788  10FC 0047                569              MOVE.B  #'G',(A0)+
0000178C  10FC 0020                570              MOVE.B  #' ',(A0)+
00001790  6100 0450                571              BSR     EA_NEG
00001794  6000 F960                572              BRA     endOP
00001798                           573  
00001798                           574  isLEA 
00001798  6100 02D8                575              BSR     outaddress      *prints current address
0000179C  10FC 004C                576              MOVE.B  #'L', (A0)+
000017A0  10FC 0045                577              MOVE.B  #'E', (A0)+
000017A4  10FC 0041                578              MOVE.B  #'A', (A0)+
000017A8  10FC 0020                579              MOVE.B  #' ', (A0)+
000017AC  544D                     580              ADDQ    #byte,A5
000017AE  544D                     581              ADDQ    #byte,A5         *increments our program counter twice, LEA incomplete
000017B0  6000 F944                582              BRA     endOP
000017B4                           583  
000017B4                           584  calcDisplacement
000017B4  6100 0BFE                585              BSR     IO_PRINT_OUTPUT1 *Prints Data
000017B8  544D                     586              ADDQ    #byte,A5        *increments A5 to get next word
000017BA  3415                     587              MOVE    (A5),D2         *Moves data to be worked on
000017BC  D48D                     588              ADD.L   A5,D2
000017BE  6100 02DA                589              BSR     isData1
000017C2  4E75                     590              RTS
000017C4                           591  *Converts string user input at A1 to HEX
000017C4                           592  *D1 is length of string, D2 is completed HEX, which will be returned to caller in D1
000017C4                           593  strToHex
000017C4  B23C 0000                594              CMP.B   #0,D1           *Compares length of string to 0
000017C8  6F00 00BC                595              BLE     endStrToHex     *Go to return line if string is less than 0
000017CC  E94A                     596              LSL     #4,D2
000017CE  5341                     597              SUB     #1,D1           *Decrements D1
000017D0                           598  strToHexLoop 
000017D0  1619                     599              MOVE.B  (A1)+,D3        *Uses D3 as temp variable
000017D2  B63C 0030                600              CMP.B   #48,D3          *Checks if 0
000017D6  6700 00B6                601              BEQ     is0
000017DA  B63C 0031                602              CMP.B   #49,D3          *Checks if 1
000017DE  6700 00B6                603              BEQ     is1
000017E2  B63C 0032                604              CMP.B   #50,D3          *Checks if 2
000017E6  6700 00B4                605              BEQ     is2
000017EA  B63C 0033                606              CMP.B   #51,D3          *Checks if 3
000017EE  6700 00B2                607              BEQ     is3
000017F2  B63C 0034                608              CMP.B   #52,D3          *Checks if 4
000017F6  6700 00B0                609              BEQ     is4
000017FA  B63C 0035                610              CMP.B   #53,D3          *Checks if 5
000017FE  6700 00AE                611              BEQ     is5
00001802  B63C 0036                612              CMP.B   #54,D3          *Checks if 6
00001806  6700 00AC                613              BEQ     is6
0000180A  B63C 0037                614              CMP.B   #55,D3          *Checks if 7
0000180E  6700 00AA                615              BEQ     is7
00001812  B63C 0038                616              CMP.B   #56,D3          *Checks if 8
00001816  6700 00A8                617              BEQ     is8
0000181A  B63C 0039                618              CMP.B   #57,D3          *Checks if 9
0000181E  6700 00A6                619              BEQ     is9
00001822  B63C 0041                620              CMP.B   #65,D3          *Checks if A
00001826  6700 00A6                621              BEQ     isA
0000182A  B63C 0061                622              CMP.B   #97,D3          *Checks if a
0000182E  6700 009E                623              BEQ     isA
00001832  B63C 0042                624              CMP.B   #66,D3          *Checks if B
00001836  6700 009E                625              BEQ     isB
0000183A  B63C 0062                626              CMP.B   #98,D3          *Checks if b
0000183E  6700 0096                627              BEQ     isB
00001842  B63C 0043                628              CMP.B   #67,D3          *Checks if C
00001846  6700 0096                629              BEQ     isC
0000184A  B63C 0063                630              CMP.B   #99,D3          *Checks if c
0000184E  6700 008E                631              BEQ     isC
00001852  B63C 0044                632              CMP.B   #68,D3          *Checks if D
00001856  6700 008E                633              BEQ     isD
0000185A  B63C 0064                634              CMP.B   #100,D3         *Checks if d
0000185E  6700 0086                635              BEQ     isD
00001862  B63C 0045                636              CMP.B   #69,D3          *Checks if E
00001866  6700 0086                637              BEQ     isE
0000186A  B63C 0065                638              CMP.B   #101,D3         *Checks if e
0000186E  6700 007E                639              BEQ     isE
00001872  B63C 0046                640              CMP.B   #70,D3          *Checks if F
00001876  6700 007E                641              BEQ     isF
0000187A  B63C 0066                642              CMP.B   #102,D3         *Checks if f
0000187E  6700 0076                643              BEQ     isF
00001882  6000 007A                644              BRA     invalidAddress  *Invalid address entered
00001886  2202                     645  endStrToHex MOVE.L  D2,D1           *Moves D2 to D1 for returning
00001888  4282                     646              CLR.L   D2
0000188A  4283                     647              CLR.L   D3              *Clears D2 and D3
0000188C  4E75                     648              RTS
0000188E                           649  
0000188E  0602 0000                650  is0         ADD.B   #$0,D2
00001892  6000 FF30                651              BRA     strToHex
00001896  5202                     652  is1         ADD.B   #$1,D2
00001898  6000 FF2A                653              BRA     strToHex
0000189C  5402                     654  is2         ADD.B   #$2,D2
0000189E  6000 FF24                655              BRA     strToHex
000018A2  5602                     656  is3         ADD.B   #$3,D2
000018A4  6000 FF1E                657              BRA     strToHex
000018A8  5802                     658  is4         ADD.B   #$4,D2
000018AA  6000 FF18                659              BRA     strToHex
000018AE  5A02                     660  is5         ADD.B   #$5,D2
000018B0  6000 FF12                661              BRA     strToHex
000018B4  5C02                     662  is6         ADD.B   #$6,D2
000018B6  6000 FF0C                663              BRA     strToHex
000018BA  5E02                     664  is7         ADD.B   #$7,D2
000018BC  6000 FF06                665              BRA     strToHex
000018C0  5002                     666  is8         ADD.B   #$8,D2
000018C2  6000 FF00                667              BRA     strToHex
000018C6  0602 0009                668  is9         ADD.B   #$9,D2
000018CA  6000 FEF8                669              BRA     strToHex
000018CE  0602 000A                670  isA         ADD.B   #$A,D2
000018D2  6000 FEF0                671              BRA     strToHex
000018D6  0602 000B                672  isB         ADD.B   #$B,D2
000018DA  6000 FEE8                673              BRA     strToHex
000018DE  0602 000C                674  isC         ADD.B   #$C,D2
000018E2  6000 FEE0                675              BRA     strToHex
000018E6  0602 000D                676  isD         ADD.B   #$D,D2
000018EA  6000 FED8                677              BRA     strToHex
000018EE  0602 000E                678  isE         ADD.B   #$E,D2
000018F2  6000 FED0                679              BRA     strToHex
000018F6  0602 000F                680  isF         ADD.B   #$F,D2
000018FA  6000 FEC8                681              BRA     strToHex
000018FE                           682  
000018FE                           683  invalidAddress
000018FE  43F9 00002464            684              LEA     invalidStr,A1   *Loads string
00001904  103C 000D                685              MOVE.B  #13,D0          *Sets up trap
00001908  4E4F                     686              TRAP    #15
0000190A  6000 F700                687              BRA     enterStart
0000190E                           688  
0000190E                           689  *Keeps track of the number of lines on the page
0000190E                           690  lineCounter
0000190E  0C40 0019                691              CMPI.W  #pageLength,D0  *Compares count to pageLength
00001912  6E00 0006                692              BGT     pauseProgram    *Pause program
00001916  5240                     693              ADDQ    #1,D0           *If not at pageLength, increment counter
00001918                           694  pauseReturn 
00001918  4E75                     695              RTS
0000191A                           696  pauseProgram
0000191A  43F9 00002472            697              LEA     enterToContinue,A1  *Loads message into A1
00001920  103C 000E                698              MOVE.B  #14,D0              *Prints message
00001924  4E4F                     699              TRAP    #15
00001926  103C 0004                700              MOVE.B  #4,D0
0000192A  4E4F                     701              TRAP    #15                 *Pauses by waiting for integer input
0000192C  4281                     702              CLR.L   D1                  *Clears input, because we don't really care about it
0000192E  103C 0000                703              MOVE.B  #0,D0               *resets line counter to 0
00001932  60E4                     704              BRA     pauseReturn
00001934                           705  *Input: size bits on D3
00001934                           706  *Prints size to stack
00001934                           707  *Returns size (1=byte, 2=word, 3=long) on D4
00001934                           708  *Returns mode (1=source, 2=destination) on D5
00001934                           709  checkSize
00001934  B67C 0000                710              CMP.W   #%000,D3        *Compares size bits and calls proper function
00001938  6700 005C                711              BEQ     Size000
0000193C                           712  
0000193C  B67C 0000                713              CMP.W   #%00,D3        *Compares size bits and calls proper function
00001940  6700 0062                714              BEQ     Size00
00001944                           715  
00001944  B67C 0001                716              CMP.W   #%01,D3        *Compares size bits and calls proper function
00001948  6700 0068                717              BEQ     Size01    
0000194C                           718  
0000194C  B67C 0002                719              CMP.W   #%10,D3        *Compares size bits and calls proper function
00001950  6700 006E                720              BEQ     Size10    
00001954                           721  
00001954  B67C 0003                722              CMP.W   #%11,D3        *Compares size bits and calls proper function
00001958  6700 0074                723              BEQ     Size11       
0000195C                           724  
0000195C  B67C 0001                725              CMP.W   #%001,D3
00001960  6700 007A                726              BEQ     Size001
00001964                           727  
00001964  B67C 0002                728              CMP.W   #%010,D3
00001968  6700 0080                729              BEQ     Size010
0000196C                           730  
0000196C  B67C 0004                731              CMP.W   #%100,D3
00001970  6700 0086                732              BEQ     Size100
00001974                           733  
00001974  B67C 0005                734              CMP.W   #%101,D3
00001978  6700 008C                735              BEQ     Size101
0000197C                           736  
0000197C  B67C 0006                737              CMP.W   #%110,D3
00001980  6700 0092                738              BEQ     Size110
00001984                           739  
00001984  B67C 0003                740              CMP.W   #%011,D3
00001988  6700 0098                741              BEQ     Size011
0000198C                           742  
0000198C  B67C 0007                743              CMP.W   #%111,D3
00001990  6700 009C                744              BEQ     Size111
00001994                           745  
00001994  4E75                     746              RTS
00001996                           747  
00001996                           748  
00001996  10FC 0042                749  Size000     MOVE.B  #'B',(A0)+      *prints size to stack and moves return data to D4,D5   
0000199A  183C 0001                750              MOVE.B  #1,D4
0000199E  1A3C 0001                751              MOVE.B  #1,D5
000019A2  4E75                     752              RTS
000019A4                           753  
000019A4  10FC 0042                754  Size00      MOVE.B  #'B',(A0)+   
000019A8  183C 0001                755              MOVE.B  #1,D4
000019AC  1A3C 0001                756              MOVE.B  #1,D5
000019B0  4E75                     757              RTS
000019B2                           758  
000019B2  10FC 0057                759  Size01      MOVE.B  #'W',(A0)+   
000019B6  183C 0002                760              MOVE.B  #2,D4
000019BA  1A3C 0001                761              MOVE.B  #1,D5
000019BE  4E75                     762              RTS
000019C0                           763  
000019C0  10FC 004C                764  Size10      MOVE.B  #'L',(A0)+   
000019C4  183C 0003                765              MOVE.B  #3,D4
000019C8  1A3C 0001                766              MOVE.B  #1,D5
000019CC  4E75                     767              RTS
000019CE                           768  
000019CE  10FC 0057                769  Size11      MOVE.B  #'W',(A0)+   
000019D2  183C 0002                770              MOVE.B  #2,D4
000019D6  1A3C 0001                771              MOVE.B  #1,D5
000019DA  4E75                     772              RTS
000019DC                           773  
000019DC                           774  
000019DC  10FC 0057                775  Size001     MOVE.B  #'W',(A0)+
000019E0  183C 0002                776              MOVE.B  #2,D4
000019E4  1A3C 0001                777              MOVE.B  #1,D5
000019E8  4E75                     778              RTS
000019EA                           779  
000019EA  10FC 004C                780  Size010     MOVE.B  #'L',(A0)+
000019EE  183C 0003                781              MOVE.B  #3,D4
000019F2  1A3C 0001                782              MOVE.B  #1,D5
000019F6  4E75                     783              RTS
000019F8                           784  
000019F8  10FC 0042                785  Size100     MOVE.B  #'B',(A0)+
000019FC  183C 0001                786              MOVE.B  #1,D4
00001A00  1A3C 0002                787              MOVE.B  #2,D5
00001A04  4E75                     788              RTS
00001A06                           789  
00001A06  10FC 0057                790  Size101     MOVE.B  #'W',(A0)+
00001A0A  183C 0002                791              MOVE.B  #2,D4
00001A0E  1A3C 0002                792              MOVE.B  #2,D5
00001A12  4E75                     793              RTS
00001A14                           794  
00001A14  10FC 004C                795  Size110     MOVE.B  #'L',(A0)+
00001A18  183C 0003                796              MOVE.B  #3,D4
00001A1C  1A3C 0002                797              MOVE.B  #2,D5
00001A20  4E75                     798              RTS
00001A22                           799  
00001A22  10FC 0057                800  Size011     MOVE.B  #'W',(A0)+
00001A26  183C 0002                801              MOVE.B  #2,D4
00001A2A  1A3C 0001                802              MOVE.B  #1,D5
00001A2E                           803  
00001A2E  10FC 0057                804  Size111     MOVE.B  #'W',(A0)+
00001A32  183C 0003                805              MOVE.B  #3,D4
00001A36  1A3C 0001                806              MOVE.B  #1,D5
00001A3A                           807  
00001A3A                           808  *Masks to make comparisons easier
00001A3A  3400                     809  compMask    MOVE.W  D0,D2           *Gets fresh copy of D0
00001A3C  0242 F1C0                810              ANDI.W  #opMask,D2      *Masks D2 for rest of comparisons
00001A40  4E75                     811              RTS
00001A42  3400                     812  mask15to8   MOVE.W  D0,D2               *Gets fresh copy of D0
00001A44  0242 FF00                813              ANDI.W  #BitMask15to8,D2    *Masks D2 for the first byte
00001A48  4E75                     814              RTS
00001A4A  3400                     815  mask15to12  MOVE.W  D0,D2               *Gets fresh copy of D0
00001A4C  0242 F000                816              ANDI.W  #BitMask15to12,D2   *Masks first bit
00001A50  4E75                     817              RTS
00001A52  3400                     818  mask15to7   MOVE.W  D0,D2               *Gets fresh copy of D0
00001A54  0242 FF80                819              ANDI.W  #BitMask15to7,D2    *Masks D2
00001A58  4E75                     820              RTS
00001A5A  3400                     821  mask15to6   MOVE.W  D0,D2               *Gets fresh copy of D0
00001A5C  0242 FFC0                822              ANDI.W  #BitMask15to6,D2    *Masks D2
00001A60  4E75                     823              RTS
00001A62  3400                     824  maskMulDivl MOVE.W  D0,D2               *Gets fresh copy of D0
00001A64  0242 8BC0                825              ANDI.W  #BitMaskMulDivl,D2  *Masks D2
00001A68  4E75                     826              RTS
00001A6A  3400                     827  maskShift   MOVE.W  D0,D2               *Gets a fresh copy of D0
00001A6C  0242 F118                828              ANDI.W  #BitMaskShifts,D2   *Masks D2
00001A70  4E75                     829              RTS
00001A72                           830              
00001A72                           831  *prints address
00001A72  3F00                     832  outaddress  MOVE.W  D0,-(sp)        *Saves D0
00001A74  3F02                     833              MOVE.W  D2,-(sp)        *Saves D2
00001A76  340D                     834              MOVE.W  A5,D2           *Moves current address to D2
00001A78  6100 0026                835              BSR     n2ascii         *prints current address
00001A7C  341F                     836              MOVE.W  (sp)+,D2        *Loads D2
00001A7E  1239 000023DC            837              MOVE.B  space,D1        *Loads ascii space in D1
00001A84  103C 0006                838              MOVE.B  #6,D0           *Sets up trap
00001A88  4E4F                     839              TRAP    #15
00001A8A  301F                     840              MOVE.W  (sp)+,D0        *Loads D0
00001A8C  4E75                     841              RTS
00001A8E                           842              
00001A8E                           843  *prints word 'DATA '            
00001A8E  43F9 00002498            844  isData      LEA     datastring,A1   *Loads datastring for printing
00001A94  103C 000E                845              MOVE.B  #14,D0          *Sets up Trap
00001A98  4E4F                     846              TRAP    #15
00001A9A                           847  *prints the data
00001A9A  6100 0004                848  isData1     BSR     n2ascii         *Prints out the data
00001A9E                           849  *            LEA     newline,A1      *Sets up trap for new line
00001A9E                           850  *            MOVE.B  #14,D0
00001A9E                           851  *            TRAP    #15
00001A9E  4E75                     852              RTS
00001AA0                           853  **************************************************
00001AA0                           854  *Takes the word hex in D2 and prints it to screen*
00001AA0                           855  **************************************************
00001AA0                           856        
00001AA0  183C 000C                857  n2ascii     MOVE.B  #12,D4          *Sets up D4 as counter.
00001AA4  3602                     858  n2ascii2    MOVE.W  D2,D3           *Moves to D3 to work on there 
00001AA6  E86B                     859              LSR.W   D4,D3           
00001AA8  0243 000F                860              ANDI.W  #$000F,D3       *Masks to check last nibble
00001AAC  B63C 0000                861              CMP.B   #$0,D3          *Chekcs if D3 is equal to 0
00001AB0  6700 0086                862              BEQ     print0
00001AB4  B63C 0001                863              CMP.B   #$1,D3          *Chekcs if D3 is equal to 1
00001AB8  6700 0088                864              BEQ     print1
00001ABC  B63C 0002                865              CMP.B   #$2,D3          *Chekcs if D3 is equal to 2
00001AC0  6700 008A                866              BEQ     print2
00001AC4  B63C 0003                867              CMP.B   #$3,D3          *Chekcs if D3 is equal to 3
00001AC8  6700 008C                868              BEQ     print3
00001ACC  B63C 0004                869              CMP.B   #$4,D3          *Chekcs if D3 is equal to 4
00001AD0  6700 008E                870              BEQ     print4
00001AD4  B63C 0005                871              CMP.B   #$5,D3          *Chekcs if D3 is equal to 5
00001AD8  6700 0090                872              BEQ     print5
00001ADC  B63C 0006                873              CMP.B   #$6,D3          *Chekcs if D3 is equal to 6
00001AE0  6700 0092                874              BEQ     print6
00001AE4  B63C 0007                875              CMP.B   #$7,D3          *Chekcs if D3 is equal to 7
00001AE8  6700 0094                876              BEQ     print7
00001AEC  B63C 0008                877              CMP.B   #$8,D3          *Chekcs if D3 is equal to 8
00001AF0  6700 0096                878              BEQ     print8
00001AF4  B63C 0009                879              CMP.B   #$9,D3          *Chekcs if D3 is equal to 9
00001AF8  6700 0098                880              BEQ     print9
00001AFC  B63C 000A                881              CMP.B   #$A,D3          *Chekcs if D3 is equal to A
00001B00  6700 009A                882              BEQ     printA
00001B04  B63C 000B                883              CMP.B   #$B,D3          *Chekcs if D3 is equal to B
00001B08  6700 009C                884              BEQ     printB
00001B0C  B63C 000C                885              CMP.B   #$C,D3          *Chekcs if D3 is equal to C
00001B10  6700 009E                886              BEQ     printC
00001B14  B63C 000D                887              CMP.B   #$D,D3          *Chekcs if D3 is equal to D
00001B18  6700 00A0                888              BEQ     printD
00001B1C  B63C 000E                889              CMP.B   #$E,D3          *Chekcs if D3 is equal to E
00001B20  6700 00A2                890              BEQ     printE
00001B24  B63C 000F                891              CMP.B   #$F,D3          *Checks if D3 is equal to F
00001B28  6700 00A4                892              BEQ     printF
00001B2C  5904                     893  n2acheck    SUB.B   #4,D4           *Decrements our counter
00001B2E  B83C 0000                894              CMP.B   #0,D4           *Checks if counter reached 0
00001B32  6C00 FF70                895              BGE     n2ascii2        *Returns to top of loop to continue        
00001B36  4E75                     896              RTS                     *Else return to caller
00001B38                           897  
00001B38  4281                     898  print0      CLR.L   D1              *Clears D1
00001B3A  123C 0030                899              MOVE.B  #$30,D1         *Sets D1 as ascii 0
00001B3E  6000 0098                900              BRA     printchar       *prints the character
00001B42  4281                     901  print1      CLR.L   D1              *Clears D1
00001B44  123C 0031                902              MOVE.B  #$31,D1         *Sets D1 as ascii 1
00001B48  6000 008E                903              BRA     printchar       *prints the character
00001B4C  4281                     904  print2      CLR.L   D1              *Clears D1
00001B4E  123C 0032                905              MOVE.B  #$32,D1         *Sets D1 as ascii 2
00001B52  6000 0084                906              BRA     printchar       *prints the character
00001B56  4281                     907  print3      CLR.L   D1              *Clears D1
00001B58  123C 0033                908              MOVE.B  #$33,D1         *Sets D1 as ascii 3
00001B5C  6000 007A                909              BRA     printchar       *prints the character
00001B60  4281                     910  print4      CLR.L   D1              *Clears D1
00001B62  123C 0034                911              MOVE.B  #$34,D1         *Sets D1 as ascii 4
00001B66  6000 0070                912              BRA     printchar       *prints the character
00001B6A  4281                     913  print5      CLR.L   D1              *Clears D1
00001B6C  123C 0035                914              MOVE.B  #$35,D1         *Sets D1 as ascii 5
00001B70  6000 0066                915              BRA     printchar       *prints the character
00001B74  4281                     916  print6      CLR.L   D1              *Clears D1
00001B76  123C 0036                917              MOVE.B  #$36,D1         *Sets D1 as ascii 6
00001B7A  6000 005C                918              BRA     printchar       *prints the character
00001B7E  4281                     919  print7      CLR.L   D1              *Clears D1
00001B80  123C 0037                920              MOVE.B  #$37,D1         *Sets D1 as ascii 7
00001B84  6000 0052                921              BRA     printchar       *prints the character
00001B88  4281                     922  print8      CLR.L   D1              *Clears D1
00001B8A  123C 0038                923              MOVE.B  #$38,D1         *Sets D1 as ascii 8
00001B8E  6000 0048                924              BRA     printchar       *prints the character
00001B92  4281                     925  print9      CLR.L   D1              *Clears D1
00001B94  123C 0039                926              MOVE.B  #$39,D1         *Sets D1 as ascii 9
00001B98  6000 003E                927              BRA     printchar       *prints the character
00001B9C  4281                     928  printA      CLR.L   D1              *Clears D1
00001B9E  123C 0041                929              MOVE.B  #$41,D1         *Sets D1 as ascii A
00001BA2  6000 0034                930              BRA     printchar       *prints the character
00001BA6  4281                     931  printB      CLR.L   D1              *Clears D1
00001BA8  123C 0042                932              MOVE.B  #$42,D1         *Sets D1 as ascii B
00001BAC  6000 002A                933              BRA     printchar       *prints the character
00001BB0  4281                     934  printC      CLR.L   D1              *Clears D1
00001BB2  123C 0043                935              MOVE.B  #$43,D1         *Sets D1 as ascii C
00001BB6  6000 0020                936              BRA     printchar       *prints the character
00001BBA  4281                     937  printD      CLR.L   D1              *Clears D1
00001BBC  123C 0044                938              MOVE.B  #$44,D1         *Sets D1 as ascii D
00001BC0  6000 0016                939              BRA     printchar       *prints the character
00001BC4  4281                     940  printE      CLR.L   D1              *Clears D1
00001BC6  123C 0045                941              MOVE.B  #$45,D1         *Sets D1 as ascii E
00001BCA  6000 000C                942              BRA     printchar       *prints the character         
00001BCE  4281                     943  printF      CLR.L   D1              *Clears D1
00001BD0  123C 0046                944              MOVE.B  #$46,D1         *Sets D1 as ascii F
00001BD4  6000 0002                945              BRA     printchar       *prints the character
00001BD8  103C 0006                946  printchar   MOVE.B  #6,D0           *Sets up Trap
00001BDC  4E4F                     947              TRAP    #15
00001BDE  6000 FF4C                948              BRA     n2acheck        *returns to n2ascii
00001BE2                           949  
00001BE2                           950  *EA FUNCTIONS:
00001BE2                           951  *D0 is assumed to be input line
00001BE2                           952  *Using D2 to store Addressing Mode
00001BE2                           953  *Using D3 to store Register
00001BE2                           954  *Using D7 to store return values
00001BE2                           955  
00001BE2                           956  *Input: D0 (Input Line)
00001BE2                           957  EA_NEG                              ;Parsing EA for NEG function
00001BE2                           958  
00001BE2  6100 097E                959        BSR         BitMask3to5       ;isolating destination address mode
00001BE6  2407                     960        MOVE.L      D7,D2             ;moving return value to D2
00001BE8                           961  
00001BE8  6100 0984                962        BSR         BitMask0to2       ;isloating destination address register
00001BEC  2607                     963        MOVE.L      D7,D3             ;Moving return value to D3
00001BEE                           964  
00001BEE  B4BC 00000001            965        CMP.L       #%001,D2           ;Address register direct is not a valid input for NEG
00001BF4  6700 07D4                966        BEQ         ERROR
00001BF8                           967  
00001BF8  B47C 0007                968        CMP.W       #%111,D2          ;Immediate Data is not a valid EA mode
00001BFC  6700 0796                969        BEQ         EA_BlOCK_IMMEDIATE
00001C00                           970  
00001C00  6100 050E                971        BSR         EA_PARSE_MODE     ;Calling parse mode function to write data to the stack
00001C04                           972  
00001C04  4E75                     973        RTS                           ;Returning to source
00001C06                           974  
00001C06                           975  *Input: D0 (Input Line)
00001C06                           976  EA_EOR                              ;Parsing EA for EOR function
00001C06  6100 092E                977        BSR         BitMask9to11      ;isolating source register
00001C0A  2607                     978        MOVE.L      D7,D3             ;moving result to D3
00001C0C  6100 054E                979        BSR         EA_PARSE_Dn       ;printing data register to A0 stack
00001C10                           980  
00001C10  10F8 002C                981        MOVE.B      ',',(A0)+         ;pushing ", " to the stack.
00001C14  10F8 0020                982        MOVE.B      ' ',(A0)+
00001C18                           983  
00001C18  6100 0948                984        BSR         BitMask3to5       ;isolating destination address mode
00001C1C  2407                     985        MOVE.L      D7,D2             ;moving return value to D2
00001C1E                           986  
00001C1E  6100 094E                987        BSR         BitMask0to2       ;isloating destination address register
00001C22  2607                     988        MOVE.L      D7,D3             ;Moving return value to D3
00001C24                           989  
00001C24  B4BC 00000001            990        CMP.L       #%001,D2          ;Address register direct is not a valid input for EOR
00001C2A  6700 079E                991        BEQ         ERROR
00001C2E                           992  
00001C2E  6100 04E0                993        BSR         EA_PARSE_MODE     ;Calling parse mode function to write data to the stack
00001C32                           994  
00001C32  4E75                     995        RTS                           ;Returning to source
00001C34                           996  
00001C34                           997  *Input: D0 (Input Line)
00001C34                           998  EA_ADDA                              ;Parsing EA for ADDA function
00001C34                           999  
00001C34                          1000  
00001C34  6100 092C               1001        BSR         BitMask3to5       ;isolating destination address mode
00001C38  2407                    1002        MOVE.L      D7,D2             ;moving return value to D2
00001C3A                          1003  
00001C3A  6100 0932               1004        BSR         BitMask0to2       ;isloating destination address register
00001C3E  2607                    1005        MOVE.L      D7,D3             ;Moving return value to D3
00001C40                          1006  
00001C40  6100 04CE               1007        BSR         EA_PARSE_MODE     ;Calling parse mode function to write data to the stack
00001C44                          1008  
00001C44  10F8 002C               1009        MOVE.B      ',',(A0)+         ;pushing ", " to the stack.
00001C48  10F8 0020               1010        MOVE.B      ' ',(A0)+
00001C4C                          1011  
00001C4C  6100 08E8               1012        BSR         BitMask9to11      ;isolating source register
00001C50  2607                    1013        MOVE.L      D7,D3             ;moving result to D3
00001C52  6100 0514               1014        BSR         EA_PARSE_An       ;printing data register to A0 stack
00001C56                          1015  
00001C56  4E75                    1016        RTS                           ;Returning to source
00001C58                          1017  
00001C58                          1018  
00001C58                          1019  *Input: D0 (input Line)
00001C58                          1020  *Input: D5 (OPMOde type (1 or 2))
00001C58                          1021  EA_OR                               ;Parsing EA for OR function
00001C58  1205                    1022        MOVE.B      D5,D1             ;moving input opmode type to D1
00001C5A  4285                    1023        CLR.L       D5                ;clearing D5
00001C5C                          1024  
00001C5C  6100 08E8               1025        BSR         BitMask6to8       ;isolating register number
00001C60  2A07                    1026        MOVE.L      D7,D5             ;moving return value to D5
00001C62                          1027  
00001C62  6100 08FE               1028        BSR         BitMask3to5       ;isolating destination address mode
00001C66  2407                    1029        MOVE.L      D7,D2             ;moving return value to D2
00001C68                          1030  
00001C68  6100 0904               1031        BSR         BitMask0to2       ;isloating destination address register
00001C6C  2607                    1032        MOVE.L      D7,D3             ;Moving return value to D3
00001C6E                          1033  
00001C6E  B23C 0001               1034        CMP.B       #1,D1             ;if the OPMode is type 1, the EA is the source
00001C72  6700 0010               1035        BEQ         EA_OR_SOURCE      
00001C76                          1036  
00001C76  B23C 0002               1037        CMP.B       #2,D1             ;if the OPMode is type 2, the EA is the destination
00001C7A  6700 0008               1038        BEQ         EA_OR_SOURCE
00001C7E                          1039  
00001C7E  10FC 0000               1040        MOVE.B      #0,(A0)+          ;Terminating character
00001C82                          1041  
00001C82  4E75                    1042        RTS                           ;Returning to source
00001C84                          1043  
00001C84                          1044  *Called if the EA address field is a source operand
00001C84                          1045  EA_OR_SOURCE
00001C84  B4BC 00000001           1046        CMP.L       #%001,D2           ;Address register direct is not a valid input for EA Source
00001C8A  6700 073E               1047        BEQ         ERROR
00001C8E                          1048  
00001C8E  6100 0480               1049        BSR         EA_PARSE_MODE     ;outputing the source EA
00001C92                          1050  
00001C92  10FC 002C               1051        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001C96  10FC 0020               1052        MOVE.B      #' ',(A0)+
00001C9A                          1053  
00001C9A  2605                    1054        MOVE.L      D5,D3             ;Moving register number to D3
00001C9C  6100 04BE               1055        BSR         EA_PARSE_Dn       ;Outputting register
00001CA0                          1056  
00001CA0  4E75                    1057        RTS
00001CA2                          1058  
00001CA2                          1059  *Called if the EA address field is a destinaton operand
00001CA2                          1060  EA_OR_DESTINATION
00001CA2  B4BC 00000000           1061        CMP.L       #%000,D2           ;Data register direct is not a valid input for EA Source
00001CA8  6700 0720               1062        BEQ         ERROR
00001CAC                          1063  
00001CAC  B4BC 00000001           1064        CMP.L       #%001,D2           ;Address register direct is not a valid input for EA Source
00001CB2  6700 0716               1065        BEQ         ERROR
00001CB6                          1066  
00001CB6  2C03                    1067        MOVE.L      D3,D6             ;backing up EA register to D6
00001CB8  2605                    1068        MOVE.L      D5,D3             ;Moving register number to D3
00001CBA  6100 04A0               1069        BSR         EA_PARSE_Dn       ;Outputting register
00001CBE                          1070  
00001CBE  10FC 002C               1071        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001CC2  10FC 0020               1072        MOVE.B      #' ',(A0)+
00001CC6                          1073  
00001CC6  2606                    1074        MOVE.L      D6,D3             ;Moving EA register back
00001CC8  6100 0446               1075        BSR         EA_PARSE_MODE     ;outputing the destination EA
00001CCC                          1076  
00001CCC                          1077  
00001CCC  4E75                    1078        RTS
00001CCE                          1079  
00001CCE                          1080  
00001CCE                          1081  *Input: D0 (Input Line)
00001CCE                          1082  *Input: D1 (immediate data source)
00001CCE                          1083  EA_ORI                              ;Parsing EA for ORI function
00001CCE                          1084  
00001CCE  6100 04E8               1085        BSR         EA_PARSE_IMMEDIATE_DATA  ;displays immediate data
00001CD2                          1086  
00001CD2  10FC 002C               1087        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001CD6  10FC 0020               1088        MOVE.B      #' ',(A0)+
00001CDA                          1089  
00001CDA  6100 0886               1090        BSR         BitMask3to5       ;isolating destination address mode
00001CDE  2407                    1091        MOVE.L      D7,D2             ;moving return value to D2
00001CE0                          1092  
00001CE0  6100 088C               1093        BSR         BitMask0to2       ;isloating destination address register
00001CE4  2607                    1094        MOVE.L      D7,D3             ;Moving return value to D3
00001CE6                          1095  
00001CE6  6100 04D0               1096        BSR         EA_PARSE_IMMEDIATE_DATA  ;parsing immediate data
00001CEA                          1097  
00001CEA  10FC 002C               1098        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001CEE  10FC 0020               1099        MOVE.B      #' ',(A0)+
00001CF2                          1100  
00001CF2  B4BC 00000001           1101        CMP.L       #%001,D2           ;Address register direct is not a valid input for ORI
00001CF8  6700 06D0               1102        BEQ         ERROR
00001CFC                          1103  
00001CFC  B47C 0007               1104        CMP.W       #%111,D2          ;Immediate Data is not a valid EA mode
00001D00  6700 0692               1105        BEQ         EA_BlOCK_IMMEDIATE
00001D04                          1106  
00001D04  6100 040A               1107        BSR         EA_PARSE_MODE     ;Calling parse mode function to write data to the stack
00001D08                          1108  
00001D08  4E75                    1109        RTS                           ;Returning to source
00001D0A                          1110  
00001D0A                          1111  
00001D0A                          1112  *Input: D0 (input Line)
00001D0A                          1113  *Input: D5 (OPMOde type (1 or 2))
00001D0A                          1114  EA_AND                              ;Parsing EA for AND function
00001D0A  1205                    1115        MOVE.B      D5,D1             ;moving input opmode type to D1
00001D0C  4285                    1116        CLR.L       D5                ;clearing D5
00001D0E                          1117  
00001D0E  6100 0826               1118        BSR         BitMask9to11      ;isolating register number
00001D12  2A07                    1119        MOVE.L      D7,D5             ;moving return value to D5
00001D14                          1120  
00001D14  6100 084C               1121        BSR         BitMask3to5       ;isolating destination address mode
00001D18  2407                    1122        MOVE.L      D7,D2             ;moving return value to D2
00001D1A                          1123  
00001D1A  6100 0852               1124        BSR         BitMask0to2       ;isloating destination address register
00001D1E  2607                    1125        MOVE.L      D7,D3             ;Moving return value to D3
00001D20                          1126  
00001D20  B23C 0001               1127        CMP.B       #1,D1             ;if the OPMode is type 1, the EA is the source
00001D24  6700 000C               1128        BEQ         EA_AND_SOURCE      
00001D28                          1129  
00001D28  B23C 0002               1130        CMP.B       #2,D1             ;if the OPMode is type 2, the EA is the destination
00001D2C  6700 0004               1131        BEQ         EA_AND_SOURCE
00001D30                          1132  
00001D30  4E75                    1133        RTS                           ;Returning to source
00001D32                          1134  
00001D32                          1135  *Called if the EA address field is a source operand
00001D32                          1136  EA_AND_SOURCE
00001D32                          1137  
00001D32  B4BC 00000001           1138        CMP.L       #%001,D2           ;Address register direct is not a valid input for EA source
00001D38  6700 0690               1139        BEQ         ERROR
00001D3C                          1140  
00001D3C  6100 03D2               1141        BSR         EA_PARSE_MODE     ;outputing the source EA
00001D40                          1142  
00001D40  10FC 002C               1143        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001D44  10FC 0020               1144        MOVE.B      #' ',(A0)+
00001D48                          1145  
00001D48  2605                    1146        MOVE.L      D5,D3             ;Moving register number to D3
00001D4A  6100 0410               1147        BSR         EA_PARSE_Dn       ;Outputting register
00001D4E                          1148  
00001D4E  4E75                    1149        RTS
00001D50                          1150  
00001D50                          1151  *Called if the EA address field is a destinaton operand
00001D50                          1152  EA_AND_DESTINATION
00001D50  B4BC 00000000           1153        CMP.L       #%000,D2           ;Data register direct is not a valid input for EA destinaton
00001D56  6700 0672               1154        BEQ         ERROR
00001D5A                          1155  
00001D5A  B4BC 00000001           1156        CMP.L       #%001,D2           ;Address register direct is not a valid input for EA destinaton
00001D60  6700 0668               1157        BEQ         ERROR
00001D64                          1158  
00001D64  2C03                    1159        MOVE.L      D3,D6             ;backing up EA register to D6
00001D66  2E05                    1160        MOVE.L      D5,D7             ;Moving register number to D3
00001D68  6100 03F2               1161        BSR         EA_PARSE_Dn       ;Outputting register
00001D6C                          1162  
00001D6C  10FC 002C               1163        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001D70  10FC 0020               1164        MOVE.B      #' ',(A0)+
00001D74                          1165  
00001D74  2E06                    1166        MOVE.L      D6,D7             ;Moving EA register back
00001D76  6100 0398               1167        BSR         EA_PARSE_MODE     ;outputing the destination EA
00001D7A                          1168  
00001D7A                          1169  
00001D7A  4E75                    1170        RTS
00001D7C                          1171  
00001D7C                          1172  EA_ANDI                             ;Parsing EA for ANDI function
00001D7C                          1173  
00001D7C  6100 07E4               1174        BSR         BitMask3to5       ;isolating destination address mode
00001D80  2407                    1175        MOVE.L      D7,D2             ;moving return value to D2
00001D82                          1176  
00001D82  6100 07EA               1177        BSR         BitMask0to2       ;isloating destination address register
00001D86  2607                    1178        MOVE.L      D7,D3             ;Moving return value to D3
00001D88                          1179  
00001D88  6100 042E               1180        BSR         EA_PARSE_IMMEDIATE_DATA          
00001D8C                          1181  
00001D8C  10FC 002C               1182        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001D90  10FC 0020               1183        MOVE.B      #' ',(A0)+
00001D94                          1184  
00001D94  B4BC 00000001           1185        CMP.L       #%001,D2           ;Address register direct is not a valid input for EA destinaton
00001D9A  6700 062E               1186        BEQ         ERROR
00001D9E                          1187  
00001D9E  2E05                    1188        MOVE.L      D5,D7
00001DA0  6100 036E               1189        BSR         EA_PARSE_MODE       ;outputting Address register destination
00001DA4                          1190  
00001DA4  4E75                    1191        RTS                           ;Returning to source
00001DA6                          1192  
00001DA6                          1193  *Input: D0 (input Line)
00001DA6                          1194  *Input: D5 (OPMOde type (1 or 2))
00001DA6                          1195  *Input: D4 (Size (1,2, or 3))
00001DA6                          1196  EA_SUB                              ;Parsing EA for AND function
00001DA6  1205                    1197        MOVE.B      D5,D1             ;moving input opmode type to D1
00001DA8  4285                    1198        CLR.L       D5                ;clearing D5
00001DAA                          1199  
00001DAA  1404                    1200        MOVE.B      D4,D2             ;moving input opmode type to D2
00001DAC  4284                    1201        CLR.L       D4                ;clearing D4
00001DAE                          1202  
00001DAE  2802                    1203        MOVE.L      D2,D4             ;moving isbyte variable to D4
00001DB0                          1204  
00001DB0  6100 0784               1205        BSR         BitMask9to11      ;isolating register number
00001DB4  2A07                    1206        MOVE.L      D7,D5             ;moving return value to D5
00001DB6                          1207  
00001DB6  6100 07AA               1208        BSR         BitMask3to5       ;isolating destination address mode
00001DBA  2407                    1209        MOVE.L      D7,D2             ;moving return value to D2
00001DBC                          1210  
00001DBC  6100 07B0               1211        BSR         BitMask0to2       ;isloating destination address register
00001DC0  2607                    1212        MOVE.L      D7,D3             ;Moving return value to D3
00001DC2                          1213  
00001DC2  B23C 0001               1214        CMP.B       #1,D1             ;if the OPMode is type 1, the EA is the source
00001DC6  6700 FF6A               1215        BEQ         EA_AND_SOURCE      
00001DCA                          1216  
00001DCA  B23C 0002               1217        CMP.B       #2,D1             ;if the OPMode is type 2, the EA is the destination
00001DCE  6700 FF62               1218        BEQ         EA_AND_SOURCE
00001DD2                          1219  
00001DD2  4E75                    1220        RTS                           ;Returning to source
00001DD4                          1221  
00001DD4                          1222  *Called if the EA address field is a source operand
00001DD4                          1223  EA_SUB_SOURCE
00001DD4                          1224  
00001DD4  B4BC 00000000           1225        CMP.L       #%000,D2           ;Address register direct is not a valid input for EA source if byte operation
00001DDA  6700 0016               1226        BEQ         EA_SUB_BYTE_CHECK  ;checking if it is a byte operation. if it is, branch to error
00001DDE                          1227  
00001DDE  6100 0330               1228        BSR         EA_PARSE_MODE     ;outputing the source EA
00001DE2                          1229  
00001DE2  10FC 002C               1230        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001DE6  10FC 0020               1231        MOVE.B      #' ',(A0)+
00001DEA                          1232  
00001DEA  2605                    1233        MOVE.L      D5,D3             ;Moving register number to D3
00001DEC  6100 036E               1234        BSR         EA_PARSE_Dn       ;Outputting register
00001DF0                          1235  
00001DF0  4E75                    1236        RTS
00001DF2                          1237  
00001DF2                          1238  EA_SUB_BYTE_CHECK
00001DF2  B8BC 00000001           1239        CMP.L       #1,D4             ;if it is a byte-operation
00001DF8  6700 05D0               1240        BEQ         ERROR
00001DFC  4E75                    1241        RTS
00001DFE                          1242  
00001DFE                          1243  
00001DFE                          1244  *Called if the EA address field is a destinaton operand
00001DFE                          1245  EA_SUB_DESTINATION
00001DFE  B4BC 00000000           1246        CMP.L       #%000,D2           ;Data register direct is not a valid input for EA destinaton
00001E04  6700 05C4               1247        BEQ         ERROR
00001E08                          1248  
00001E08  B4BC 00000001           1249        CMP.L       #%001,D2           ;Address register direct is not a valid input for EA destinaton
00001E0E  6700 05BA               1250        BEQ         ERROR
00001E12                          1251  
00001E12  2803                    1252        MOVE.L      D3,D4             ;backing up EA register to D4
00001E14  2605                    1253        MOVE.L      D5,D3             ;Moving register number to D3
00001E16  6100 0344               1254        BSR         EA_PARSE_Dn       ;Outputting register
00001E1A                          1255  
00001E1A  10FC 002C               1256        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001E1E  10FC 0020               1257        MOVE.B      #' ',(A0)+
00001E22                          1258  
00001E22  2604                    1259        MOVE.L      D4,D3             ;Moving EA register back
00001E24  6100 02EA               1260        BSR         EA_PARSE_MODE     ;outputing the destination EA
00001E28                          1261  
00001E28                          1262  
00001E28  4E75                    1263        RTS
00001E2A                          1264  
00001E2A                          1265  *Input: D0 (input Line)
00001E2A                          1266  *Input: D5 (OPMOde type (1 or 2))
00001E2A                          1267  EA_ADD                              ;Parsing EA for ADD function
00001E2A  1205                    1268        MOVE.B      D5,D1             ;moving input opmode type to D1
00001E2C  4285                    1269        CLR.L       D5                ;clearing D5
00001E2E                          1270  
00001E2E  6100 0706               1271        BSR         BitMask9to11      ;isolating register number
00001E32  2A07                    1272        MOVE.L      D7,D5             ;moving return value to D5
00001E34                          1273  
00001E34  6100 072C               1274        BSR         BitMask3to5       ;isolating EA address mode
00001E38  2407                    1275        MOVE.L      D7,D2             ;moving return value to D2
00001E3A                          1276  
00001E3A  6100 0732               1277        BSR         BitMask0to2       ;isloating EA address register
00001E3E  2607                    1278        MOVE.L      D7,D3             ;Moving return value to D3
00001E40                          1279  
00001E40  B23C 0001               1280        CMP.B       #1,D1             ;if the OPMode is type 1, the EA is the source
00001E44  6700 000C               1281        BEQ         EA_ADD_SOURCE      
00001E48                          1282  
00001E48  B23C 0002               1283        CMP.B       #2,D1             ;if the OPMode is type 2, the EA is the destination
00001E4C  6700 0004               1284        BEQ         EA_ADD_SOURCE
00001E50                          1285  
00001E50  4E75                    1286        RTS                           ;Returning to source
00001E52                          1287  
00001E52                          1288  *Called if the EA address field is a source operand
00001E52                          1289  EA_ADD_SOURCE
00001E52                          1290  
00001E52  6100 02BC               1291        BSR         EA_PARSE_MODE     ;outputing the source EA
00001E56                          1292  
00001E56  10FC 002C               1293        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001E5A  10FC 0020               1294        MOVE.B      #' ',(A0)+
00001E5E                          1295  
00001E5E  2605                    1296        MOVE.L      D5,D3             ;Moving register number to D3
00001E60  6100 02FA               1297        BSR         EA_PARSE_Dn       ;Outputting register
00001E64                          1298  
00001E64  4E75                    1299        RTS
00001E66                          1300  
00001E66                          1301  *Called if the EA address field is a destinaton operand
00001E66                          1302  EA_ADD_DESTINATION
00001E66  B4BC 00000000           1303        CMP.L       #%000,D2           ;Data register direct is not a valid input for EA destinaton
00001E6C  6700 055C               1304        BEQ         ERROR
00001E70                          1305  
00001E70  B4BC 00000001           1306        CMP.L       #%001,D2           ;Address register direct is not a valid input for EA destinaton
00001E76  6700 0552               1307        BEQ         ERROR
00001E7A                          1308  
00001E7A  2803                    1309        MOVE.L      D3,D4             ;backing up EA address register
00001E7C                          1310  
00001E7C  2605                    1311        MOVE.L      D5,D3             ;Moving register to D3
00001E7E  6100 02DC               1312        BSR         EA_PARSE_Dn       ;Outputting register
00001E82                          1313  
00001E82  10FC 002C               1314        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001E86  10FC 0020               1315        MOVE.B      #' ',(A0)+
00001E8A                          1316  
00001E8A  2604                    1317        MOVE.L      D4,D3             ;moving address register back
00001E8C                          1318  
00001E8C  6100 0282               1319        BSR         EA_PARSE_MODE     ;outputing the destination EA
00001E90  4E75                    1320        RTS
00001E92                          1321  
00001E92                          1322  *Input: D0 (input Line)
00001E92                          1323  *Input: D1 (Isbyte (0 or 1))
00001E92                          1324  EA_SUBQ                             ;Parsing EA for SUBQ function
00001E92                          1325  
00001E92  6100 06CE               1326        BSR         BitMask3to5       ;isolating destination address mode
00001E96  2407                    1327        MOVE.L      D7,D2             ;moving return value to D2
00001E98                          1328  
00001E98  6100 06D4               1329        BSR         BitMask0to2       ;isloating destination address register
00001E9C  2607                    1330        MOVE.L      D7,D3             ;Moving return value to D3
00001E9E                          1331  
00001E9E  6100 0318               1332        BSR         EA_PARSE_IMMEDIATE_DATA          
00001EA2                          1333  
00001EA2  10FC 002C               1334        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001EA6  10FC 0020               1335        MOVE.B      #' ',(A0)+
00001EAA                          1336  
00001EAA  B2BC 00000001           1337        CMP.L       #1,D1              ;Address register direct is not a valid input for EA destinaton
00001EB0  6700 000A               1338        BEQ         EA_SUBQ_BYTE_CHECK ;checking if it's a byte operation. if it is, branch to error.
00001EB4                          1339        
00001EB4  2E05                    1340        MOVE.L      D5,D7
00001EB6  6100 0258               1341        BSR         EA_PARSE_MODE       ;outputting Address register destination
00001EBA                          1342  
00001EBA  4E75                    1343        RTS                           ;Returning to source
00001EBC                          1344  
00001EBC                          1345  EA_SUBQ_BYTE_CHECK
00001EBC  B4BC 00000001           1346        CMP.L       #%001,D2          ;if it is a byte-operation
00001EC2  6700 0506               1347        BEQ         ERROR
00001EC6  4E75                    1348        RTS
00001EC8                          1349  
00001EC8                          1350  *Input: D0 (input Line)
00001EC8                          1351  EA_MOVE                             ;Parsing EA for MOVE function
00001EC8                          1352  
00001EC8  6100 0698               1353        BSR         BitMask3to5       ;isolating source address mode
00001ECC  2407                    1354        MOVE.L      D7,D2             ;moving return value to D2
00001ECE                          1355  
00001ECE  6100 069E               1356        BSR         BitMask0to2       ;isloating source address register
00001ED2  2607                    1357        MOVE.L      D7,D3             ;Moving return value to D3
00001ED4                          1358  
00001ED4  6100 023A               1359        BSR         EA_PARSE_MODE     ;parsing mode and register for the source   
00001ED8                          1360  
00001ED8  10FC 002C               1361        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001EDC  10FC 0020               1362        MOVE.B      #' ',(A0)+
00001EE0                          1363  
00001EE0  6100 0664               1364        BSR         BitMask6to8       ;isolating destination address mode
00001EE4  2407                    1365        MOVE.L      D7,D2             ;moving return value to D2
00001EE6                          1366  
00001EE6  6100 064E               1367        BSR         BitMask9to11       ;isloating destination address register
00001EEA  2607                    1368        MOVE.L      D7,D3             ;Moving return value to D3
00001EEC                          1369  
00001EEC  B47C 0001               1370        CMP.W       #%001,D2           ;Address register direct is not a valid destination mode
00001EF0  6700 04D8               1371        BEQ         ERROR
00001EF4                          1372  
00001EF4  6100 021A               1373        BSR         EA_PARSE_MODE     ;parsing mode and register for the destination     
00001EF8                          1374  
00001EF8  4E75                    1375        RTS                           ;Returning to source
00001EFA                          1376  
00001EFA                          1377  *Input: D0 (input Line)
00001EFA                          1378  EA_MOVEA                            ;Parsing EA for MOVEA function
00001EFA                          1379  
00001EFA  6100 0666               1380        BSR         BitMask3to5       ;isolating source address mode
00001EFE  2407                    1381        MOVE.L      D7,D2             ;moving return value to D2
00001F00                          1382  
00001F00  6100 066C               1383        BSR         BitMask0to2       ;isloating source address register
00001F04  2607                    1384        MOVE.L      D7,D3             ;Moving return value to D3
00001F06                          1385  
00001F06  6100 0208               1386        BSR         EA_PARSE_MODE     ;parsing mode and register for the source   
00001F0A                          1387  
00001F0A  10FC 002C               1388        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001F0E  10FC 0020               1389        MOVE.B      #' ',(A0)+
00001F12                          1390  
00001F12  6100 0622               1391        BSR         BitMask9to11      ;isloating destination address register
00001F16                          1392  
00001F16  2607                    1393        MOVE.L      D7,D3             ;Moving return value to D3
00001F18  6100 024E               1394        BSR         EA_PARSE_An       ;parsing address register direct for the destination     
00001F1C                          1395  
00001F1C  4E75                    1396        RTS                           ;Returning to source
00001F1E                          1397  
00001F1E                          1398  *Input: D0 (input Line)
00001F1E                          1399  EA_CMP                             ;Parsing EA for CMP function
00001F1E                          1400  
00001F1E  6100 0642               1401        BSR         BitMask3to5       ;isolating source address mode
00001F22  2407                    1402        MOVE.L      D7,D2             ;moving return value to D2
00001F24                          1403  
00001F24  6100 0648               1404        BSR         BitMask0to2       ;isloating source address register
00001F28  2607                    1405        MOVE.L      D7,D3             ;Moving return value to D3
00001F2A                          1406  
00001F2A  6100 01E4               1407        BSR         EA_PARSE_MODE     ;parsing mode and register for the source   
00001F2E                          1408  
00001F2E  10FC 002C               1409        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001F32  10FC 0020               1410        MOVE.B      #' ',(A0)+
00001F36                          1411  
00001F36  6100 05FE               1412        BSR         BitMask9to11      ;isloating destination address register
00001F3A                          1413  
00001F3A  2607                    1414        MOVE.L      D7,D3             ;Moving return value to D3
00001F3C  6100 021E               1415        BSR         EA_PARSE_Dn       ;parsing data register direct for the destination     
00001F40                          1416  
00001F40  4E75                    1417        RTS                           ;Returning to source
00001F42                          1418  
00001F42                          1419  
00001F42                          1420  EA_CMPI                             ;Parsing EA for CMPI function
00001F42                          1421  
00001F42  6100 061E               1422        BSR         BitMask3to5       ;isolating destination address mode
00001F46  2407                    1423        MOVE.L      D7,D2             ;moving return value to D2
00001F48                          1424  
00001F48  6100 0624               1425        BSR         BitMask0to2       ;isloating destination address register
00001F4C  2607                    1426        MOVE.L      D7,D3             ;Moving return value to D3
00001F4E                          1427  
00001F4E  6100 0268               1428        BSR         EA_PARSE_IMMEDIATE_DATA          
00001F52                          1429  
00001F52  10FC 002C               1430        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001F56  10FC 0020               1431        MOVE.B      #' ',(A0)+
00001F5A                          1432  
00001F5A  B4BC 00000001           1433        CMP.L       #%001,D2           ;Address register direct is not a valid input for EA destinaton
00001F60  6700 0468               1434        BEQ         ERROR
00001F64                          1435  
00001F64  6100 01AA               1436        BSR         EA_PARSE_MODE     ;outputting Address register destination
00001F68                          1437  
00001F68  4E75                    1438        RTS                           ;Returning to source
00001F6A                          1439  
00001F6A                          1440  
00001F6A                          1441  *Input: D0 (input Line)
00001F6A                          1442  EA_MULS                             ;Parsing EA for MULS function
00001F6A                          1443  
00001F6A  6100 05F6               1444        BSR         BitMask3to5       ;isolating source address mode
00001F6E  2407                    1445        MOVE.L      D7,D2             ;moving return value to D2
00001F70                          1446  
00001F70  6100 05FC               1447        BSR         BitMask0to2       ;isloating source address register
00001F74  2607                    1448        MOVE.L      D7,D3             ;Moving return value to D3
00001F76                          1449  
00001F76  B47C 0001               1450        CMP.W       #%001,D2           ;Address Register direct is not a valid EA Mode for DIVS
00001F7A  6700 044E               1451        BEQ         ERROR
00001F7E                          1452  
00001F7E  6100 0190               1453        BSR         EA_PARSE_MODE     ;parsing mode and register for the source   
00001F82                          1454  
00001F82  10FC 002C               1455        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001F86  10FC 0020               1456        MOVE.B      #' ',(A0)+
00001F8A                          1457  
00001F8A  6100 05AA               1458        BSR         BitMask9to11      ;isloating destination address register
00001F8E                          1459  
00001F8E  2607                    1460        MOVE.L      D7,D3             ;Moving return value to D3
00001F90  6100 01CA               1461        BSR         EA_PARSE_Dn       ;parsing data register direct for the destination     
00001F94                          1462  
00001F94  4E75                    1463        RTS                           ;Returning to source
00001F96                          1464  
00001F96                          1465  *Input: D0 (input Line)
00001F96                          1466  EA_DIVS                             ;Parsing EA for DIVS function
00001F96                          1467  
00001F96  6100 05CA               1468        BSR         BitMask3to5       ;isolating source address mode
00001F9A  2407                    1469        MOVE.L      D7,D2             ;moving return value to D2
00001F9C                          1470  
00001F9C  6100 05D0               1471        BSR         BitMask0to2       ;isloating source address register
00001FA0  2607                    1472        MOVE.L      D7,D3             ;Moving return value to D3
00001FA2                          1473  
00001FA2  B47C 0001               1474        CMP.W       #%001,D2           ;Address Register direct is not a valid EA Mode for DIVS
00001FA6  6700 0422               1475        BEQ         ERROR
00001FAA                          1476  
00001FAA  6100 0164               1477        BSR         EA_PARSE_MODE     ;parsing mode and register for the source   
00001FAE                          1478  
00001FAE  10FC 002C               1479        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001FB2  10FC 0020               1480        MOVE.B      #' ',(A0)+
00001FB6                          1481  
00001FB6  6100 057E               1482        BSR         BitMask9to11      ;isloating destination address register
00001FBA                          1483  
00001FBA  2607                    1484        MOVE.L      D7,D3             ;Moving return value to D3
00001FBC  6100 019E               1485        BSR         EA_PARSE_Dn       ;parsing data register direct for the destination     
00001FC0                          1486  
00001FC0  4E75                    1487        RTS                           ;Returning to source
00001FC2                          1488  
00001FC2                          1489  *Input: D0 (input Line)
00001FC2                          1490  EA_LS_REGISTER                      ;Parsing EA for LSR/LSL function for register shifts
00001FC2                          1491  
00001FC2  6100 05FC               1492        BSR         BitMask5to5
00001FC6  2A07                    1493        MOVE.L      D7,D5             ;storing i/r value in D5
00001FC8                          1494  
00001FC8  6100 056C               1495        BSR         BitMask9to11      ;isloating source EA source register
00001FCC  2607                    1496        MOVE.L      D7,D3             ;Moving return value to D3
00001FCE                          1497  
00001FCE  6100 0352               1498        BSR         EA_PARSE_REGISTER ;parsing the count/register field
00001FD2  2807                    1499        MOVE.L      D7,D4             ;moving result to D4
00001FD4                          1500  
00001FD4  BA7C 0001               1501        CMP.W       #%1,D5             ;if the i/r value is 1 display the data register
00001FD8  6700 000A               1502        BEQ         EA_LS_REGISTER_D
00001FDC                          1503  
00001FDC  BA7C 0000               1504        CMP.W       #%0,D5             ;if the i/r value is 0 display immediate data
00001FE0  6700 000A               1505        BEQ         EA_LS_REGISTER_DIRECT
00001FE4                          1506  
00001FE4                          1507  
00001FE4                          1508  EA_LS_REGISTER_D
00001FE4  10FC 0044               1509        MOVE.B      #'D',(A0)+
00001FE8  6000 000A               1510        BRA         EA_LS_REGISTER_AFTERBREAK
00001FEC                          1511  
00001FEC                          1512  EA_LS_REGISTER_DIRECT
00001FEC  10FC 0023               1513        MOVE.B      #'#',(A0)+
00001FF0  6000 0002               1514        BRA         EA_LS_REGISTER_AFTERBREAK     
00001FF4                          1515  
00001FF4                          1516  EA_LS_REGISTER_AFTERBREAK
00001FF4  10C4                    1517        MOVE.B      D4,(A0)+          ;pushing the register number or immediate data to the stack
00001FF6                          1518  
00001FF6  10FC 002C               1519        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00001FFA  10FC 0020               1520        MOVE.B      #' ',(A0)+
00001FFE                          1521   
00001FFE  6100 056E               1522        BSR         BitMask0to2       ;isloating source destination register
00002002  2607                    1523        MOVE.L      D7,D3             ;Moving return value to D3
00002004                          1524  
00002004  6100 0156               1525        BSR         EA_PARSE_Dn       ;displaying the destination data register
00002008                          1526  
00002008  4E75                    1527        RTS                           ;Returning to source
0000200A                          1528  
0000200A                          1529  *Input: D0 (input Line)
0000200A                          1530  EA_LS_MEMORY                        ;Parsing EA for LSR/LSL function for memory shifts
0000200A                          1531  
0000200A  6100 0556               1532        BSR         BitMask3to5       ;isolating destination address mode
0000200E  2407                    1533        MOVE.L      D7,D2             ;moving return value to D2
00002010                          1534  
00002010  6100 055C               1535        BSR         BitMask0to2       ;isloating source address register
00002014  2607                    1536        MOVE.L      D7,D3             ;Moving return value to D3
00002016                          1537  
00002016  B47C 0000               1538        CMP.W       #%000,D2          ;Data Register direct is not a valid EA mode
0000201A  6700 03AE               1539        BEQ         ERROR
0000201E                          1540  
0000201E  B47C 0001               1541        CMP.W       #%001,D2          ;Address Register direct is not a valid EA Mode
00002022  6700 03A6               1542        BEQ         ERROR
00002026                          1543  
00002026  B47C 0007               1544        CMP.W       #%111,D2          ;Immediate Data is not a valid EA mode
0000202A  6700 0368               1545        BEQ         EA_BlOCK_IMMEDIATE
0000202E                          1546  
0000202E  6100 00E0               1547        BSR         EA_PARSE_MODE     ;parsing mode and register for the source   
00002032                          1548  
00002032  4E75                    1549        RTS                           ;Returning to source
00002034                          1550  
00002034                          1551  *Input: D0 (input Line)
00002034                          1552  EA_AS_REGISTER                      ;Parsing EA for ASR/ASL function for register shifts
00002034                          1553  
00002034  6100 058A               1554        BSR         BitMask5to5
00002038  2A07                    1555        MOVE.L      D7,D5             ;storing i/r value in D5
0000203A                          1556  
0000203A  6100 04FA               1557        BSR         BitMask9to11      ;isloating source EA source register
0000203E  2607                    1558        MOVE.L      D7,D3             ;Moving return value to D3
00002040                          1559  
00002040  6100 02E0               1560        BSR         EA_PARSE_REGISTER ;parsing the count/register field
00002044  2807                    1561        MOVE.L      D7,D4             ;moving result to D4
00002046                          1562  
00002046  BA7C 0001               1563        CMP.W       #%1,D5             ;if the i/r value is 1 display the data register
0000204A  6700 000A               1564        BEQ         EA_AS_REGISTER_D
0000204E                          1565  
0000204E  BA7C 0000               1566        CMP.W       #%0,D5             ;if the i/r value is 0 display immediate data
00002052  6700 000A               1567        BEQ         EA_AS_REGISTER_DIRECT
00002056                          1568  
00002056                          1569  
00002056                          1570  EA_AS_REGISTER_D
00002056  10FC 0044               1571        MOVE.B      #'D',(A0)+
0000205A  6000 0006               1572        BRA         EA_AS_REGISTER_AFTERBREAK
0000205E                          1573  
0000205E                          1574  EA_AS_REGISTER_DIRECT
0000205E  10FC 0023               1575        MOVE.B      #'#',(A0)+
00002062                          1576  
00002062                          1577  EA_AS_REGISTER_AFTERBREAK
00002062  10C4                    1578        MOVE.B      D4,(A0)+          ;pushing the register number or immediate data to the stack
00002064                          1579  
00002064  10FC 002C               1580        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
00002068  10FC 0020               1581        MOVE.B      #' ',(A0)+
0000206C                          1582   
0000206C  6100 0500               1583        BSR         BitMask0to2       ;isloating source destination register
00002070  2607                    1584        MOVE.L      D7,D3             ;Moving return value to D3
00002072                          1585  
00002072  6100 00E8               1586        BSR         EA_PARSE_Dn       ;displaying the destination data register
00002076                          1587  
00002076  4E75                    1588        RTS                           ;Returning to source
00002078                          1589  
00002078                          1590  *Input: D0 (input Line)
00002078                          1591  EA_AS_MEMORY                        ;Parsing EA for ASR/ASL function for memory shifts
00002078                          1592  
00002078  6100 04E8               1593        BSR         BitMask3to5       ;isolating destination address mode
0000207C  2407                    1594        MOVE.L      D7,D2             ;moving return value to D2
0000207E                          1595  
0000207E  6100 04EE               1596        BSR         BitMask0to2       ;isloating source address register
00002082  2607                    1597        MOVE.L      D7,D3             ;Moving return value to D3
00002084                          1598  
00002084  B47C 0000               1599        CMP.W       #%000,D2          ;Data Register direct is not a valid EA mode
00002088  6700 0340               1600        BEQ         ERROR
0000208C                          1601  
0000208C  B47C 0001               1602        CMP.W       #%001,D2          ;Address Register direct is not a valid EA Mode
00002090  6700 0338               1603        BEQ         ERROR
00002094                          1604  
00002094  B47C 0007               1605        CMP.W       #%111,D2          ;Immediate Data is not a valid EA mode
00002098  6700 02FA               1606        BEQ         EA_BlOCK_IMMEDIATE
0000209C                          1607  
0000209C  6100 0072               1608        BSR         EA_PARSE_MODE     ;parsing mode and register for the source   
000020A0                          1609  
000020A0  4E75                    1610        RTS                           ;Returning to source
000020A2                          1611  
000020A2                          1612  
000020A2                          1613  *Input: D0 (input Line)
000020A2                          1614  EA_RO_REGISTER                      ;Parsing EA for ROR/ROL function for register shifts
000020A2                          1615  
000020A2  6100 051C               1616        BSR         BitMask5to5
000020A6  2A07                    1617        MOVE.L      D7,D5             ;storing i/r value in D5
000020A8                          1618  
000020A8  6100 048C               1619        BSR         BitMask9to11      ;isloating source EA source register
000020AC  2607                    1620        MOVE.L      D7,D3             ;Moving return value to D3
000020AE                          1621  
000020AE  6100 0272               1622        BSR         EA_PARSE_REGISTER ;parsing the count/register field
000020B2  2807                    1623        MOVE.L      D7,D4             ;moving result to D4
000020B4                          1624  
000020B4  BA7C 0001               1625        CMP.W       #%1,D5             ;if the i/r value is 1 display the data register
000020B8  6700 000A               1626        BEQ         EA_RO_REGISTER_D
000020BC                          1627  
000020BC  BA7C 0000               1628        CMP.W       #%0,D5             ;if the i/r value is 0 display immediate data
000020C0  6700 000A               1629        BEQ         EA_RO_REGISTER_DIRECT
000020C4                          1630  
000020C4                          1631  EA_RO_REGISTER_D
000020C4  10FC 0044               1632        MOVE.B      #'D',(A0)+
000020C8  6000 0006               1633        BRA         EA_RO_REGISTER_AFTERBREAK
000020CC                          1634  
000020CC                          1635  EA_RO_REGISTER_DIRECT
000020CC  10FC 0023               1636        MOVE.B      #'#',(A0)+
000020D0                          1637  
000020D0                          1638  EA_RO_REGISTER_AFTERBREAK
000020D0  10C4                    1639        MOVE.B      D4,(A0)+          ;pushing the register number or immediate data to the stack
000020D2                          1640  
000020D2  10FC 002C               1641        MOVE.B      #',',(A0)+        ;pushing ", " to the stack.
000020D6  10FC 0020               1642        MOVE.B      #' ',(A0)+
000020DA                          1643   
000020DA  6100 0492               1644        BSR         BitMask0to2       ;isloating source destination register
000020DE  2607                    1645        MOVE.L      D7,D3             ;Moving return value to D3
000020E0                          1646  
000020E0  6100 007A               1647        BSR         EA_PARSE_Dn       ;displaying the destination data register
000020E4                          1648  
000020E4  4E75                    1649        RTS                           ;Returning to source
000020E6                          1650  
000020E6                          1651  *Input: D0 (input Line)
000020E6                          1652  EA_RO_MEMORY                        ;Parsing EA for ROR/ROL function for memory shifts
000020E6                          1653  
000020E6  6100 047A               1654        BSR         BitMask3to5       ;isolating destination address mode
000020EA  2407                    1655        MOVE.L      D7,D2             ;moving return value to D2
000020EC                          1656  
000020EC  6100 0480               1657        BSR         BitMask0to2       ;isloating source address register
000020F0  2607                    1658        MOVE.L      D7,D3             ;Moving return value to D3
000020F2                          1659  
000020F2  B47C 0000               1660        CMP.W       #%000,D2          ;Data Register direct is not a valid EA mode
000020F6  6700 02D2               1661        BEQ         ERROR
000020FA                          1662  
000020FA  B47C 0001               1663        CMP.W       #%001,D2          ;Address Register direct is not a valid EA Mode
000020FE  6700 02CA               1664        BEQ         ERROR
00002102                          1665  
00002102  B47C 0007               1666        CMP.W       #%111,D2          ;Immediate Data is not a valid EA mode
00002106  6700 028C               1667        BEQ         EA_BlOCK_IMMEDIATE
0000210A                          1668  
0000210A  6100 0004               1669        BSR         EA_PARSE_MODE     ;parsing mode and register for the source   
0000210E                          1670  
0000210E  4E75                    1671        RTS                           ;Returning to source
00002110                          1672  
00002110                          1673  
00002110                          1674  *Finds correct function to parse the EA Mode 
00002110                          1675  *Input: D2 (EA Mode)
00002110                          1676  *Input: D3 (EA Register Number)
00002110                          1677  EA_PARSE_MODE                       
00002110  B47C 0000               1678        CMP.W       #%000,D2
00002114  6700 0046               1679        BEQ         EA_PARSE_Dn
00002118                          1680  
00002118  B47C 0001               1681        CMP.W       #%001,D2
0000211C  6700 004A               1682        BEQ         EA_PARSE_An
00002120                          1683  
00002120  B47C 0002               1684        CMP.W       #%010,D2
00002124  6700 004E               1685        BEQ         EA_PARSE_INDIRECT_An
00002128                          1686  
00002128  B47C 0003               1687        CMP.W       #%011,D2
0000212C  6700 005A               1688        BEQ         EA_PARSE_INDIRECT_INCREMENT_An
00002130                          1689  
00002130  B47C 0004               1690        CMP.W       #%100,D2
00002134  6700 006A               1691        BEQ         EA_PARSE_INDIRECT_DECREMENT_An
00002138                          1692  
00002138  B47C 0007               1693        CMP.W       #%111,D2
0000213C  6700 0004               1694        BEQ         EA_ADDITIONAL_DATA
00002140                          1695  
00002140  4E75                    1696        RTS
00002142                          1697  
00002142                          1698  EA_ADDITIONAL_DATA
00002142  B67C 0000               1699        CMP.W       #%000,D3
00002146  6700 008C               1700        BEQ         EA_PARSE_ABSOLUTE_WORD_ADDRESS
0000214A                          1701  
0000214A  B67C 0001               1702        CMP.W       #%001,D3
0000214E  6700 0072               1703        BEQ         EA_PARSE_ABSOLUTE_LONG_ADDRESS
00002152                          1704  
00002152  B67C 0004               1705        CMP.W       #%100,D3
00002156  6700 0060               1706        BEQ         EA_PARSE_IMMEDIATE_DATA
0000215A                          1707  
0000215A  4E75                    1708        RTS
0000215C                          1709  
0000215C                          1710  *These functions are called when the EA Mode matches.
0000215C                          1711  *They store the human ouput code to the A0 register, then increment it.
0000215C                          1712  *Then return to where they were called from.
0000215C                          1713  
0000215C                          1714  
0000215C                          1715  *Input: D3 (Register Address number)
0000215C                          1716  *Uses:  D7
0000215C                          1717  *Output: A0
0000215C                          1718  EA_PARSE_Dn
0000215C  6100 01C4               1719        BSR         EA_PARSE_REGISTER
00002160  10FC 0044               1720        MOVE.B      #'D',(A0)+
00002164  10C7                    1721        MOVE.B      D7,(A0)+
00002166  4E75                    1722        RTS
00002168                          1723  
00002168                          1724  EA_PARSE_An
00002168  6100 01B8               1725        BSR         EA_PARSE_REGISTER
0000216C  10FC 0041               1726        MOVE.B      #'A',(A0)+
00002170  10C7                    1727        MOVE.B      D7,(A0)+
00002172  4E75                    1728        RTS
00002174                          1729  
00002174                          1730  EA_PARSE_INDIRECT_An
00002174  6100 01AC               1731        BSR         EA_PARSE_REGISTER
00002178  10FC 0028               1732        MOVE.B      #'(',(A0)+
0000217C  10FC 0041               1733        MOVE.B      #'A',(A0)+
00002180  10C7                    1734        MOVE.B      D7,(A0)+
00002182  10FC 0029               1735        MOVE.B      #')',(A0)+
00002186  4E75                    1736        RTS
00002188                          1737  
00002188                          1738  EA_PARSE_INDIRECT_INCREMENT_An
00002188  6100 0198               1739        BSR         EA_PARSE_REGISTER
0000218C  10FC 0028               1740        MOVE.B      #'(',(A0)+
00002190  10FC 0041               1741        MOVE.B      #'A',(A0)+
00002194  10C7                    1742        MOVE.B      D7,(A0)+
00002196  10FC 0029               1743        MOVE.B      #')',(A0)+
0000219A  10FC 002B               1744        MOVE.B      #'+',(A0)+
0000219E  4E75                    1745        RTS
000021A0                          1746  
000021A0                          1747  EA_PARSE_INDIRECT_DECREMENT_An
000021A0  6100 0180               1748        BSR         EA_PARSE_REGISTER
000021A4  10FC 002D               1749        MOVE.B      #'-',(A0)+
000021A8  10FC 0028               1750        MOVE.B      #'(',(A0)+
000021AC  10FC 0041               1751        MOVE.B      #'A',(A0)+
000021B0  10C7                    1752        MOVE.B      D7,(A0)+
000021B2  10FC 0029               1753        MOVE.B      #')',(A0)+
000021B6  4E75                    1754        RTS
000021B8                          1755  
000021B8                          1756  EA_PARSE_IMMEDIATE_DATA
000021B8  10FC 0023               1757        MOVE.B     #'#',(A0)+
000021BC  6100 0028               1758        BSR        IO_GET_WORD
000021C0  4E75                    1759        RTS
000021C2                          1760  
000021C2                          1761  EA_PARSE_ABSOLUTE_LONG_ADDRESS
000021C2  10FC 0024               1762        MOVE.B     #'$',(A0)+
000021C6  6100 001E               1763        BSR        IO_GET_WORD
000021CA  10FC 002E               1764        MOVE.B     #'.',(A0)+
000021CE  10FC 004C               1765        MOVE.B     #'L',(A0)+
000021D2  4E75                    1766        RTS
000021D4                          1767        
000021D4                          1768  EA_PARSE_ABSOLUTE_WORD_ADDRESS
000021D4  10FC 0024               1769        MOVE.B     #'$',(A0)+
000021D8  6100 000C               1770        BSR        IO_GET_WORD
000021DC  10FC 002E               1771        MOVE.B     #'.',(A0)+
000021E0  10FC 0057               1772        MOVE.B     #'W',(A0)+
000021E4  4E75                    1773        RTS
000021E6                          1774  
000021E6                          1775  
000021E6                          1776  IO_GET_WORD
000021E6  3F00                    1777        MOVE.W  D0,-(sp)        *Saves D0
000021E8  3F01                    1778        MOVE.W  D1,-(sp)        *Saves D1
000021EA  3F02                    1779        MOVE.W  D2,-(sp)        *Saves D2
000021EC  3F03                    1780        MOVE.W  D3,-(sp)        *Saves D3
000021EE  3F04                    1781        MOVE.W  D4,-(sp)        *Saves D4
000021F0                          1782  
000021F0  544D                    1783        ADDQ.W  #byte,A5        *Incrementing A5 to get the next word section
000021F2  3415                    1784        MOVE.W  (A5),D2         *Gets the data of where the pointer is at
000021F4  544D                    1785        ADDQ.W  #byte,A5        *Incrementing the pointer one word
000021F6  6100 000E               1786        BSR     n2asciiSTACK    *Branching to n2asciiSTACK to push the word to the stack
000021FA                          1787  
000021FA  381F                    1788        MOVE.W  (sp)+,D4        *Restores D4
000021FC  361F                    1789        MOVE.W  (sp)+,D3        *Restores D3
000021FE  341F                    1790        MOVE.W  (sp)+,D2        *Restores D2
00002200  321F                    1791        MOVE.W  (sp)+,D1        *Restores D1
00002202  301F                    1792        MOVE.W  (sp)+,D0        *Restores D0
00002204  4E75                    1793        RTS
00002206                          1794  
00002206                          1795  
00002206                          1796  *Modified version of the n2ascii function that pushes to the A0 stack instead of outputting to console
00002206  183C 000C               1797  n2asciiSTACK      MOVE.B  #12,D4          *Sets up D4 as counter.
0000220A  3602                    1798  n2asciiSTACK2     MOVE.W  D2,D3           *Moves to D3 to work on there 
0000220C  E86B                    1799                    LSR.W   D4,D3           
0000220E  0243 000F               1800                    ANDI.W  #$000F,D3       *Masks to check last nibble
00002212  B63C 0000               1801                    CMP.B   #$0,D3          *checks if D3 is equal to 0
00002216  6700 007E               1802                    BEQ     push0
0000221A  B63C 0001               1803                    CMP.B   #$1,D3          *checks if D3 is equal to 1
0000221E  6700 007E               1804                    BEQ     push1
00002222  B63C 0002               1805                    CMP.B   #$2,D3          *checks if D3 is equal to 2
00002226  6700 007E               1806                    BEQ     push2
0000222A  B63C 0003               1807                    CMP.B   #$3,D3          *checks if D3 is equal to 3
0000222E  6700 007E               1808                    BEQ     push3
00002232  B63C 0004               1809                    CMP.B   #$4,D3          *checks if D3 is equal to 4
00002236  6700 007E               1810                    BEQ     push4
0000223A  B63C 0005               1811                    CMP.B   #$5,D3          *checks if D3 is equal to 5
0000223E  6700 007E               1812                    BEQ     push5
00002242  B63C 0006               1813                    CMP.B   #$6,D3          *checks if D3 is equal to 6
00002246  6700 007E               1814                    BEQ     push6
0000224A  B63C 0007               1815                    CMP.B   #$7,D3          *checks if D3 is equal to 7
0000224E  6700 007E               1816                    BEQ     push7
00002252  B63C 0008               1817                    CMP.B   #$8,D3          *checks if D3 is equal to 8
00002256  6700 007E               1818                    BEQ     push8
0000225A  B63C 0009               1819                    CMP.B   #$9,D3          *checks if D3 is equal to 9
0000225E  6700 007E               1820                    BEQ     push9
00002262  B63C 000A               1821                    CMP.B   #$A,D3          *checks if D3 is equal to A
00002266  6700 007E               1822                    BEQ     pushA
0000226A  B63C 000B               1823                    CMP.B   #$B,D3          *checks if D3 is equal to B
0000226E  6700 007E               1824                    BEQ     pushB
00002272  B63C 000C               1825                    CMP.B   #$C,D3          *checks if D3 is equal to C
00002276  6700 007E               1826                    BEQ     pushC
0000227A  B63C 000D               1827                    CMP.B   #$D,D3          *checks if D3 is equal to D
0000227E  6700 007E               1828                    BEQ     pushD
00002282  B63C 000E               1829                    CMP.B   #$E,D3          *checks if D3 is equal to E
00002286  6700 007E               1830                    BEQ     pushE
0000228A  B63C 000F               1831                    CMP.B   #$F,D3          *Checks if D3 is equal to F
0000228E  6700 007E               1832                    BEQ     pushF
00002292                          1833  
00002292  6000 0082               1834                    BRA n2acheckSTACK       *Branching past output if none were equal
00002296  10FC 0030               1835  push0       MOVE.B  #'0',(A0)+
0000229A  6000 007A               1836              BRA n2acheckSTACK
0000229E  10FC 0031               1837  push1       MOVE.B  #'1',(A0)+
000022A2  6000 0072               1838              BRA n2acheckSTACK
000022A6  10FC 0032               1839  push2       MOVE.B  #'2',(A0)+
000022AA  6000 006A               1840              BRA n2acheckSTACK
000022AE  10FC 0033               1841  push3       MOVE.B  #'3',(A0)+
000022B2  6000 0062               1842              BRA n2acheckSTACK
000022B6  10FC 0034               1843  push4       MOVE.B  #'4',(A0)+
000022BA  6000 005A               1844              BRA n2acheckSTACK
000022BE  10FC 0035               1845  push5       MOVE.B  #'5',(A0)+
000022C2  6000 0052               1846              BRA n2acheckSTACK
000022C6  10FC 0036               1847  push6       MOVE.B  #'6',(A0)+
000022CA  6000 004A               1848              BRA n2acheckSTACK
000022CE  10FC 0037               1849  push7       MOVE.B  #'7',(A0)+
000022D2  6000 0042               1850              BRA n2acheckSTACK
000022D6  10FC 0038               1851  push8       MOVE.B  #'8',(A0)+
000022DA  6000 003A               1852              BRA n2acheckSTACK
000022DE  10FC 0039               1853  push9       MOVE.B  #'9',(A0)+
000022E2  6000 0032               1854              BRA n2acheckSTACK
000022E6  10FC 0041               1855  pushA       MOVE.B  #'A',(A0)+
000022EA  6000 002A               1856              BRA n2acheckSTACK
000022EE  10FC 0042               1857  pushB       MOVE.B  #'B',(A0)+
000022F2  6000 0022               1858              BRA n2acheckSTACK
000022F6  10FC 0043               1859  pushC       MOVE.B  #'C',(A0)+
000022FA  6000 001A               1860              BRA n2acheckSTACK
000022FE  10FC 0044               1861  pushD       MOVE.B  #'D',(A0)+
00002302  6000 0012               1862              BRA n2acheckSTACK
00002306  10FC 0045               1863  pushE       MOVE.B  #'E',(A0)+
0000230A  6000 000A               1864              BRA n2acheckSTACK         
0000230E  10FC 0046               1865  pushF       MOVE.B  #'F',(A0)+
00002312  6000 0002               1866              BRA n2acheckSTACK
00002316  5904                    1867  n2acheckSTACK     SUB.B   #4,D4           *Decrements our counter
00002318  B83C 0000               1868                    CMP.B   #0,D4           *Checks if counter reached 0
0000231C  6C00 FEEC               1869                    BGE     n2asciiSTACK2   *Returns to top of loop to continue        
00002320  4E75                    1870                    RTS                     *Else return to caller
00002322                          1871  
00002322                          1872  
00002322                          1873  
00002322                          1874  *Converts a register number to ascii number and stores to D7 
00002322                          1875  *Input:  D3 (Register Number)
00002322                          1876  *Output: D7 
00002322                          1877  EA_PARSE_REGISTER                   
00002322                          1878  
00002322  B67C 0000               1879        CMP.W       #%000,D3
00002326  6700 003C               1880        BEQ         EA_MOVE0
0000232A                          1881  
0000232A  B67C 0001               1882        CMP.W       #%001,D3
0000232E  6700 003A               1883        BEQ         EA_MOVE1
00002332                          1884  
00002332  B67C 0002               1885        CMP.W       #%010,D3
00002336  6700 0038               1886        BEQ         EA_MOVE2
0000233A                          1887  
0000233A  B67C 0003               1888        CMP.W       #%011,D3
0000233E  6700 0036               1889        BEQ         EA_MOVE3
00002342                          1890  
00002342  B67C 0004               1891        CMP.W       #%100,D3
00002346  6700 0034               1892        BEQ         EA_MOVE4
0000234A                          1893  
0000234A  B67C 0005               1894        CMP.W       #%101,D3
0000234E  6700 0032               1895        BEQ         EA_MOVE5
00002352                          1896  
00002352  B67C 0006               1897        CMP.W       #%110,D3
00002356  6700 0030               1898        BEQ         EA_MOVE6
0000235A                          1899  
0000235A  B67C 0007               1900        CMP.W       #%111,D3
0000235E  6700 002E               1901        BEQ         EA_MOVE7
00002362                          1902  
00002362  4E75                    1903        RTS
00002364                          1904  
00002364  3E3C 0030               1905  EA_MOVE0    MOVE.W      #'0',D7
00002368  4E75                    1906              RTS
0000236A                          1907  
0000236A  3E3C 0031               1908  EA_MOVE1    MOVE.W      #'1',D7
0000236E  4E75                    1909              RTS
00002370                          1910  
00002370  3E3C 0032               1911  EA_MOVE2    MOVE.W      #'2',D7
00002374  4E75                    1912              RTS
00002376                          1913  
00002376  3E3C 0033               1914  EA_MOVE3    MOVE.W      #'3',D7
0000237A  4E75                    1915              RTS
0000237C                          1916  
0000237C  3E3C 0034               1917  EA_MOVE4    MOVE.W      #'4',D7
00002380  4E75                    1918              RTS
00002382                          1919  
00002382  3E3C 0035               1920  EA_MOVE5    MOVE.W      #'5',D7
00002386  4E75                    1921              RTS
00002388                          1922  
00002388  3E3C 0036               1923  EA_MOVE6    MOVE.W      #'6',D7
0000238C  4E75                    1924              RTS
0000238E                          1925  
0000238E  3E3C 0037               1926  EA_MOVE7    MOVE.W      #'7',D7
00002392  4E75                    1927              RTS
00002394                          1928  
00002394                          1929  EA_BlOCK_IMMEDIATE                  ;Blocks immediate data when it not a valid EA mode
00002394  B67C 0002               1930        CMP.W       #%010,D3          ;Branches to ERROR if the EA mode is immediate dat
00002398  6700 0030               1931        BEQ         ERROR
0000239C                          1932  
0000239C  4E75                    1933        RTS                           ;If it's not immediate it will just return back
0000239E                          1934  
0000239E                          1935  IO_PRINT_OUTPUT
0000239E  10FC 0000               1936        MOVE.B    #%0,(A0)+           ;Adding terminating null to end of string
000023A2  41F9 0000A000           1937        LEA       OUTPUT_START,A0     ;Reseting A0 back to start of string
000023A8  2248                    1938        MOVEA.L   A0,A1               ;Moving to A1 for printing
000023AA  4280                    1939        CLR.L     D0                  ;clearing the trap byte
000023AC  103C 000D               1940        MOVE.B    #13,D0              ;printing string with new line
000023B0  4E4F                    1941        TRAP      #15
000023B2  4E75                    1942        RTS
000023B4                          1943  
000023B4                          1944  *Prints output without new line
000023B4                          1945  IO_PRINT_OUTPUT1
000023B4  10FC 0000               1946        MOVE.B    #%0,(A0)+           ;Adding terminating null to end of string
000023B8  41F9 0000A000           1947        LEA       OUTPUT_START,A0     ;Reseting A0 back to start of string
000023BE  2248                    1948        MOVEA.L   A0,A1               ;Moving to A1 for printing
000023C0  4280                    1949        CLR.L     D0                  ;clearing the trap byte
000023C2  103C 000E               1950        MOVE.B    #14,D0              ;printing string
000023C6  4E4F                    1951        TRAP      #15
000023C8  4E75                    1952        RTS
000023CA                          1953  
000023CA                          1954  ERROR
000023CA                          1955        *TODO: handle illegal inputs
000023CA  103C 000E               1956        MOVE.B    #14,D0
000023CE  43F9 0000248B           1957        LEA       outputError,A1
000023D4  4E4F                    1958        TRAP      #15
000023D6  4E75                    1959        RTS
000023D8                          1960  
000023D8                          1961  end_search
000023D8                          1962  
000023D8                          1963      
000023D8                          1964  
000023D8  FFFF FFFF               1965      SIMHALT             ; halt simulator
000023DC                          1966  
000023DC                          1967  * Put variables and constants here
000023DC                          1968  
000023DC= 20                      1969  space       DC.B    $20         *space
000023DD  =0000000D               1970  CR          EQU     $0D         *Carriage return
000023DD  =0000000A               1971  LF          EQU     $0A         *Line Feed
000023DD= 0D 0A 00                1972  newline     DC.B    CR,LF,0     *New Line
000023E0  =00000002               1973  byte        EQU     2           *How much to move the search address.
000023E0                          1974                                  *2 bytes because we're searching for a word
000023E0  =00001000               1975  cur_address EQU     $00001000   *Start of search
000023E0  =00001004               1976  test_end    EQU     $00001004   *End of search
000023E0                          1977  mydata      REG     D0-D7/A0-A6  *Used for pushing registers to stack
000023E0  =00000019               1978  pageLength  EQU     25          *Each page is 25 lines (decimal)
000023E0                          1979  
000023E0                          1980  *Strings for I/O
000023E0= 57 65 6C 63 6F 6D ...   1981  greeting0   DC.B    'Welcome to Zeke Snider and Joseph Sturtevant',39,'s 422 Final Project',0
00002421= 50 6C 65 61 73 65 ...   1982  greeting1   DC.B    'Please enter a starting address: ',0
00002443= 50 6C 65 61 73 65 ...   1983  greeting2   DC.B    'Please enter an ending address: ',0
00002464= 49 6E 76 61 6C 69 ...   1984  invalidStr  DC.B    'Invalid input',0
00002472= 48 69 74 20 65 6E ...   1985  enterToContinue DC.B    'Hit enter to continue...',0
0000248B= 2A 49 6E 76 61 6C ...   1986  outputError DC.B    '*Invalid EA*',0
00002498                          1987  *Old, were used for OP code testing, not used in final project
00002498= 44 41 54 41 20 00       1988  datastring  DC.B    'DATA ',0   *Data string
0000249E= 4E 4F 50 00             1989  NOPstring   DC.B    'NOP',0     *NOP string
000024A2= 45 4F 52 00             1990  EORstring   DC.B    'EOR',0     *EOR string
000024A6= 4F 52 49 00             1991  ORIstring   DC.B    'ORI',0     *ORI string
000024AA= 4F 52 00                1992  ORstring    DC.B    'OR',0      *OR string
000024AD= 41 44 44 00             1993  ADDstring   DC.B    'ADD',0     *ADD string
000024B1= 41 44 44 41 00          1994  ADDAstring  DC.B    'ADDA',0     *ADDA string
000024B6= 4D 4F 56 45 4D 00       1995  MOVEMstring DC.B    'MOVEM',0   *MOVEM string
000024BC= 4D 4F 56 45 41 00       1996  MOVEAstring DC.B    'MOVEA',0   *MOVEA string
000024C2= 4D 4F 56 45 00          1997  MOVEstring  DC.B    'MOVE',0    *MOVE string
000024C7= 53 55 42 00             1998  SUBstring   DC.B    'SUB',0     *SUB string
000024CB= 53 55 42 00             1999  SUBQstring  DC.B    'SUB',0     *SUBQ string
000024CF= 4D 55 4C 53 00          2000  MULSstring  DC.B    'MULS',0    *MULS string
000024D4= 44 49 56 53 00          2001  DIVSstring  DC.B    'DIVS',0    *DIVS string
000024D9= 43 4D 50 00             2002  CMPstring   DC.B    'CMP',0     *CMP string
000024DD= 43 4D 50 49 00          2003  CMPIstring  DC.B    'CMPI',0    *CMPI string
000024E2= 4C 53 4C 00             2004  LSLstring   DC.B    'LSL',0     *LSL string
000024E6= 4C 53 52 00             2005  LSRstring   DC.B    'LSR',0     *LSR string
000024EA= 41 53 4C 00             2006  ASLstring   DC.B    'ASL',0     *ASL string
000024EE= 41 53 52 00             2007  ASRstring   DC.B    'ASR',0     *ASR string
000024F2= 52 4F 4C 00             2008  ROLstring   DC.B    'ROL',0     *ROL string
000024F6= 52 4F 52 00             2009  RORstring   DC.B    'ROR',0     *ROR string
000024FA= 42 43 4C 52 00          2010  BCLRstring  DC.B    'BCLR',0    *BCLR string
000024FF= 42 43 53 00             2011  BCSstring   DC.B    'BCS',0     *BCS string
00002503= 42 47 45 00             2012  BGEstring   DC.B    'BGE',0     *BGE string
00002507= 42 4C 54 00             2013  BLTstring   DC.B    'BLT',0     *BLT string
0000250B= 42 56 43 00             2014  BVCstring   DC.B    'BVC',0     *BVC string
0000250F= 42 52 41 00             2015  BRAstring   DC.B    'BRA',0     *BRA string
00002513= 4A 53 52 00             2016  JSRstring   DC.B    'JSR',0     *JSR string
00002517= 52 54 53 00             2017  RTSstring   DC.B    'RTS',0     *RTS string
0000251B= 4E 45 47 20 00          2018  NEGstring   DC.B    'NEG ',0     *NEG string
00002520= 4C 45 41 20 00          2019  LEAstring   DC.B    'LEA ',0    *LEA string
00002525                          2020  
00002525                          2021  
00002525                          2022  
00002525                          2023  *Bit Masks
00002525                          2024  
00002525  =0000F000               2025  BitMask15to12 EQU   $F000       *Mask for first byte
00002525  =00008BC0               2026  BitMaskMulDivl EQU  %1000101111000000  *Mask for MULS and DIVS Long
00002525  =0000FFC0               2027  BitMask15to6 EQU    $FFC0       *Mask for showing bits 15 through 6 (BCLR immidiate)
00002525  =0000FF80               2028  BitMask15to7 EQU    $FF80       *Mask for showing bits 15 through 7 (MOVEM)
00002525  =0000FF00               2029  BitMask15to8 EQU    $FF00       *Mask for showing first two bytes, 0'ing last 2
00002525  =0000F1C0               2030  opMask      EQU     $F1C0       *Masks word so first byte and OP mode are visible
00002525                          2031                                  *The rest of the word are 0's
00002525  =0000F118               2032  BitMaskShifts EQU   %1111000100011000   *Masks for the shift op codes
00002525                          2033  
00002525                          2034  *Masked Op codes
00002525  =00004E71               2035  nop_code    EQU     $4E71       *Hex for NOP
00002525  =0000B100               2036  eorb_code   EQU     %1011000100000000   *Binary of EOR.B, masked
00002525  =0000B140               2037  eorw_code   EQU     %1011000101000000   *Binary of EOR.W, masked
00002525  =0000B180               2038  eorl_code   EQU     %1011000110000000   *Binary of EOR.L, masked
00002525  =00000000               2039  ori_code    EQU     $00               *Hex of first two bytes of ORI
00002525                          2040                                          *last 2 bytes don't matter for compare
00002525  =00008000               2041  orbDn_code  EQU     %1000000000000000   *Binary of OR.B -> Dn
00002525  =00008040               2042  orwDn_code  EQU     %1000000001000000   *Binary of OR.W -> Dn
00002525  =00008080               2043  orlDn_code  EQU     %1000000010000000   *Binary of OR.L -> Dn
00002525  =00008100               2044  orbEA_code  EQU     %1000000100000000   *Binary of OR.B -> EA
00002525  =00008140               2045  orwEA_code  EQU     %1000000101000000   *Binary of OR.W -> EA
00002525  =00008180               2046  orlEA_code  EQU     %1000000110000000   *Binary of OR.L -> EA
00002525  =0000D000               2047  addbDn_code EQU     %1101000000000000   *Binary of ADD.B -> Dn
00002525  =0000D040               2048  addwDn_code EQU     %1101000001000000   *Binary of ADD.W -> Dn
00002525  =0000D080               2049  addlDn_code EQU     %1101000010000000   *Binary of ADD.L -> Dn
00002525  =0000D100               2050  addbEA_code EQU     %1101000100000000   *Binary of ADD.B -> EA
00002525  =0000D140               2051  addwEA_code EQU     %1101000101000000   *Binary of ADD.W -> EA
00002525  =0000D180               2052  addlEA_code EQU     %1101000110000000   *Binary of ADD.L -> EA
00002525  =0000D0C0               2053  addaw_code  EQU     %1101000011000000   *Binary of ADDA.W
00002525  =0000D1C0               2054  addal_code  EQU     %1101000111000000   *Binary of ADDA.L
00002525  =00004880               2055  movemr2m_code EQU   %0100100010000000   *Binary of MOVEM from register to memory
00002525  =00004C80               2056  movemm2r_code EQU   %0100110010000000   *Binary of MOVEM from memory to register
00002525  =00003040               2057  moveaw_code EQU     %0011000001000000   *Binary of MOVEA Word
00002525  =00002040               2058  moveal_code EQU     %0010000001000000   *Binary of MOVEA long
00002525  =00001000               2059  moveb_code  EQU     %0001000000000000   *Binary of MOVE byte
00002525  =00003000               2060  movew_code  EQU     %0011000000000000   *Binary of MOVE word
00002525  =00002000               2061  movel_code  EQU     %0010000000000000   *Binary of Move long
00002525  =00009000               2062  subbDn_code EQU     %1001000000000000   *Binary of SUB.B -> Dn
00002525  =00009040               2063  subwDn_code EQU     %1001000001000000   *Binary of SUB.W -> Dn
00002525  =00009080               2064  sublDn_code EQU     %1001000010000000   *Binary of SUB.L -> Dn
00002525  =00009100               2065  subbEA_code EQU     %1001000100000000   *Binary of SUB.B -> EA
00002525  =00009140               2066  subwEA_code EQU     %1001000101000000   *Binary of SUB.W -> EA
00002525  =00009180               2067  sublEA_code EQU     %1001000110000000   *Binary of SUB.L -> EA
00002525  =00005100               2068  subqb_code  EQU     %0101000100000000   *Binary of SUBQ byte
00002525  =00005140               2069  subqw_code  EQU     %0101000101000000   *Binary of SUBQ word
00002525  =00005180               2070  subql_code  EQU     %0101000110000000   *Binary of SUBQ long
00002525  =00000800               2071  mulsl_code  EQU     %0000100000000000   *Binary of MULS.L
00002525  =00000840               2072  divsl_code  EQU     %0000100001000000   *Binary of DIVS.L
00002525  =0000C1C0               2073  mulsw_code  EQU     %1100000111000000   *Binary of MULS.W
00002525  =000081C0               2074  divsw_code  EQU     %1000000111000000   *Binary of DIVS.W
00002525  =0000B000               2075  cmpb_code   EQU     %1011000000000000   *Binary of CMP.B
00002525  =0000B040               2076  cmpw_code   EQU     %1011000001000000   *Binary of CMP.W
00002525  =0000B080               2077  cmpl_code   EQU     %1011000010000000   *Binary of CMP.L
00002525  =00000C00               2078  cmpi_code   EQU     %0000110000000000   *Binary of CMPI
00002525  =0000E108               2079  lsl_code    EQU     %1110000100001000   *Binary of LSL
00002525  =0000E008               2080  lsr_code    EQU     %1110000000001000   *Binary of LSR
00002525  =0000E100               2081  asl_code    EQU     %1110000100000000   *Binary of ASL
00002525  =0000E000               2082  asr_code    EQU     %1110000000000000   *Binary of ASR
00002525  =0000E118               2083  rol_code    EQU     %1110000100011000   *Binary of ROL
00002525  =0000E018               2084  ror_code    EQU     %1110000000011000   *Binary of ROR
00002525  =00000880               2085  bclri_code  EQU     %0000100010000000   *Binary of BCLR with an immidiate
00002525  =00000180               2086  bclr_code   EQU     %0000000110000000   *Binary of BCLR
00002525  =00006500               2087  bcs_code    EQU     %0110010100000000   *Binary of BCS
00002525  =00006C00               2088  bge_code    EQU     %0110110000000000   *Binary of BGE
00002525  =00006D00               2089  blt_code    EQU     %0110110100000000   *Binary of BLT
00002525  =00006800               2090  bvc_code    EQU     %0110100000000000   *Binary of BVC
00002525  =00006000               2091  bra_code    EQU     %0110000000000000   *Binary of BRA
00002525  =00006100               2092  bsr_code    EQU     %0110000100000000   *Binary of BSR
00002525  =00004E80               2093  jsr_code    EQU     %0100111010000000   *Binary of JSR
00002525  =00004E75               2094  rts_code    EQU     %0100111001110101   *Binary of RTS
00002525  =00004400               2095  neg_code    EQU     %0100010000000000   *Binary of NEG
00002525  =000041C0               2096  lea_code    EQU     %0100000111000000   *Binary of LEA
00002525                          2097  *EA EQU's
00002525                          2098  
00002525  =0000A000               2099  OUTPUT_START EQU     $0000A000
00002525                          2100  
00002525                          2101  *--------------------------------*
00002525                          2102  *     Written By: Zeke Snider    *
00002525                          2103  *     CSS 422                    *
00002525                          2104  *     Fall 2014                  *
00002525                          2105  *     EA BitMasks                *
00002525                          2106  *--------------------------------*
00002525                          2107  
00002525                          2108  *D6 is used to store the masks. 
00002525                          2109  *D0 is assumed to be input line
00002525                          2110  *Data is returned on D7
00002525                          2111  
00002525                          2112  *(These variables are flexible and can be changed later)
00002525                          2113  
00002525                          2114  
00002525                          2115  *-----COMMON USE MASKS-----*
00002525                          2116  
00002525                          2117  *12-15 often used for OP codes
00002525                          2118  BitMask12to15 
00002526  2C3C 0000F000           2119        MOVE.L   #%1111000000000000,D6       ;Storing the mask to D6
0000252C  2E00                    2120        MOVE.L   D0,D7                      ;Copying the input line to D7
0000252E  CE86                    2121        AND.L    D6,D7                      ;ANDING the Data
00002530  E04F                    2122        LSR      #8,D7                      ;Shifting the irrelavant bits out the right side
00002532  E84F                    2123        LSR      #4,D7
00002534  4E75                    2124        RTS
00002536                          2125  
00002536                          2126  *9-11 commonly used for register
00002536                          2127  BitMask9to11 
00002536  2C3C 00000E00           2128        MOVE.L   #%0000111000000000,D6       ;Storing the mask to D6
0000253C  2E00                    2129        MOVE.L   D0,D7                      ;Copying the input line to D7
0000253E  CE86                    2130        AND.L    D6,D7                      ;ANDING the Data
00002540  E04F                    2131        LSR      #8,D7                      ;Shifting the irrelavant bits out the right side
00002542  E24F                    2132        LSR      #1,D7 
00002544  4E75                    2133        RTS
00002546                          2134  
00002546                          2135  
00002546                          2136  *6-8 commonly used for OPMode, OP code
00002546                          2137  BitMask6to8 
00002546  2C3C 000001C0           2138        MOVE.L   #%0000000111000000,D6       ;Storing the mask to D6
0000254C  2E00                    2139        MOVE.L   D0,D7                      ;Copying the input line to D7
0000254E  CE86                    2140        AND.L    D6,D7                      ;ANDING the Data
00002550  EC4F                    2141        LSR      #6,D7                      ;Shifting the irrelavant bits out the right side
00002552  4E75                    2142        RTS
00002554                          2143  
00002554                          2144  *6-7 commonly used for size codes
00002554                          2145  BitMask6to7 
00002554  2C3C 000000C0           2146        MOVE.L   #%0000000011000000,D6       ;Storing the mask to D6
0000255A  2E00                    2147        MOVE.L   D0,D7                      ;Copying the input line to D7
0000255C  CE86                    2148        AND.L    D6,D7                      ;ANDING the Data
0000255E  EC4F                    2149        LSR      #6,D7                      ;Shifting the irrelavant bits out the right side
00002560  4E75                    2150        RTS
00002562                          2151  
00002562                          2152  *3-5 commonly used for EA Mode
00002562                          2153  BitMask3to5 
00002562  3C3C 0038               2154        MOVE.W   #%0000000000111000,D6       ;Storing the mask to D6
00002566  2E00                    2155        MOVE.L   D0,D7                      ;Copying the input line to D7
00002568  CE86                    2156        AND.L    D6,D7                      ;ANDING the Data
0000256A  E64F                    2157        LSR      #3,D7                      ;Shifting the irrelavant bits out the right side
0000256C  4E75                    2158        RTS
0000256E                          2159  
0000256E                          2160  *0-2 commonly used for EA Register
0000256E                          2161  BitMask0to2 
0000256E  3C3C 0007               2162        MOVE.W   #%0000000000000111,D6       ;Storing the mask to D6
00002572  2E00                    2163        MOVE.L   D0,D7                      ;Copying the input line to D7
00002574  CE86                    2164        AND.L    D6,D7                      ;ANDING the Data
00002576  4E75                    2165        RTS
00002578                          2166  
00002578                          2167  *-----SPECIFIC USE MASKS----*
00002578                          2168  
00002578                          2169  *14-15 used for MOVE OP code
00002578                          2170  BitMask14to15 
00002578  2C3C 0000C000           2171        MOVE.L   #%1100000000000000,D6       ;Storing the mask to D6
0000257E  2E00                    2172        MOVE.L   D0,D7                      ;Copying the input line to D7
00002580  CE86                    2173        AND.L    D6,D7                      ;ANDING the Data
00002582  E04F                    2174        LSR      #8,D7                     ;Shifting the irrelavant bits out the right side
00002584  EC4F                    2175        LSR      #6,D7
00002586  4E75                    2176        RTS
00002588                          2177  
00002588                          2178  *12-13 used for MOVE size code
00002588                          2179  BitMask12to13 
00002588  2C3C 00003000           2180        MOVE.L   #%0011000000000000,D6       ;Storing the mask to D6
0000258E  2E00                    2181        MOVE.L   D0,D7                      ;Copying the input line to D7
00002590  CE86                    2182        AND.L    D6,D7                      ;ANDING the Data
00002592  E04F                    2183        LSR      #8,D7                      ;Shifting the irrelavant bits out the right side
00002594  E84F                    2184        LSR      #4,D7
00002596  4E75                    2185        RTS
00002598                          2186  
00002598                          2187  *8-15 used for ORI OP Code
00002598                          2188  BitMask8to15 
00002598  2C3C 0000FF00           2189        MOVE.L   #%1111111100000000,D6       ;Storing the mask to D6
0000259E  2E00                    2190        MOVE.L   D0,D7                      ;Copying the input line to D7
000025A0  CE86                    2191        AND.L    D6,D7                      ;ANDING the Data
000025A2  E04F                    2192        LSR      #8,D7                      ;Shifting the irrelavant bits out the right side
000025A4  4E75                    2193        RTS
000025A6                          2194  
000025A6                          2195  *7-15 used for MOVEM OP Code
000025A6                          2196  BitMask7to15 
000025A6  2C3C 0000FF80           2197        MOVE.L   #%1111111110000000,D6       ;Storing the mask to D6
000025AC  2E00                    2198        MOVE.L   D0,D7                      ;Copying the input line to D7
000025AE  CE86                    2199        AND.L    D6,D7                      ;ANDING the Data
000025B0  EE4F                    2200        LSR      #7,D7                      ;Shifting the irrelavant bits out the right side
000025B2  4E75                    2201        RTS
000025B4                          2202  
000025B4                          2203  *8,12-15 SUBQ OP Code
000025B4                          2204  BitMaskSubQ 
000025B4  2C3C 0000F100           2205        MOVE.L   #%1111000100000000,D6       ;Storing the mask to D6
000025BA  2E00                    2206        MOVE.L   D0,D7                      ;Copying the input line to D7
000025BC  CE86                    2207        AND.L    D6,D7                      ;ANDING the Data
000025BE  4E75                    2208        RTS
000025C0                          2209  
000025C0                          2210  
000025C0                          2211  *5 used for LSR/LSL i/r
000025C0                          2212  BitMask5to5 
000025C0  7C20                    2213        MOVE.L   #%0000000000100000,D6       ;Storing the mask to D6
000025C2  2E00                    2214        MOVE.L   D0,D7                      ;Copying the input line to D7
000025C4  CE86                    2215        AND.L    D6,D7                      ;ANDING the Data
000025C6  EA4F                    2216        LSR      #5,D7                      ;Shifting the irrelavant bits out the right side
000025C8  4E75                    2217        RTS
000025CA                          2218  
000025CA                          2219  
000025CA                          2220  
000025CA                          2221      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDAL_CODE          D1C0
ADDASTRING          24B1
ADDAW_CODE          D0C0
ADDBDN_CODE         D000
ADDBEA_CODE         D100
ADDLDN_CODE         D080
ADDLEA_CODE         D180
ADDSTRING           24AD
ADDWDN_CODE         D040
ADDWEA_CODE         D140
ASLSTRING           24EA
ASL_CODE            E100
ASRSTRING           24EE
ASR_CODE            E000
BCLRI_CODE          880
BCLRSTRING          24FA
BCLR_CODE           180
BCSSTRING           24FF
BCS_CODE            6500
BGESTRING           2503
BGE_CODE            6C00
BITMASK0TO2         256E
BITMASK12TO13       2588
BITMASK12TO15       2525
BITMASK14TO15       2578
BITMASK15TO12       F000
BITMASK15TO6        FFC0
BITMASK15TO7        FF80
BITMASK15TO8        FF00
BITMASK3TO5         2562
BITMASK5TO5         25C0
BITMASK6TO7         2554
BITMASK6TO8         2546
BITMASK7TO15        25A6
BITMASK8TO15        2598
BITMASK9TO11        2536
BITMASKMULDIVL      8BC0
BITMASKSHIFTS       F118
BITMASKSUBQ         25B4
BLTSTRING           2507
BLT_CODE            6D00
BRASTRING           250F
BRA_CODE            6000
BSR_CODE            6100
BVCSTRING           250B
BVC_CODE            6800
BYTE                2
CALCDISPLACEMENT    17B4
CHECKSIZE           1934
CMPB_CODE           B000
CMPISTRING          24DD
CMPI_CODE           C00
CMPL_CODE           B080
CMPSTRING           24D9
CMPW_CODE           B040
COMPARE_ADD         1162
COMPARE_BCC         12E6
COMPARE_BCLR        12DA
COMPARE_BCLRI       12CE
COMPARE_CMP         126A
COMPARE_CMPI        1286
COMPARE_DIVSL       1246
COMPARE_DIVSW       125E
COMPARE_EOR         1146
COMPARE_JSR         131A
COMPARE_LEA         133E
COMPARE_MOVE        11CE
COMPARE_MOVEA       11BA
COMPARE_MOVEM       11A6
COMPARE_MULSL       123A
COMPARE_MULSW       1252
COMPARE_NEG         1332
COMPARE_NOP         10FC
COMPARE_OR          1112
COMPARE_ORI         1108
COMPARE_RTS         1326
COMPARE_SHIFT       1292
COMPARE_SUB         11EA
COMPARE_SUBQ        121E
COMPMASK            1A3A
CR                  D
CUR_ADDRESS         1000
DATASTRING          2498
DIVSL_CODE          840
DIVSSTRING          24D4
DIVSW_CODE          81C0
EA_ADD              1E2A
EA_ADDA             1C34
EA_ADDITIONAL_DATA  2142
EA_ADD_DESTINATION  1E66
EA_ADD_SOURCE       1E52
EA_AND              1D0A
EA_ANDI             1D7C
EA_AND_DESTINATION  1D50
EA_AND_SOURCE       1D32
EA_AS_MEMORY        2078
EA_AS_REGISTER      2034
EA_AS_REGISTER_AFTERBREAK  2062
EA_AS_REGISTER_D    2056
EA_AS_REGISTER_DIRECT  205E
EA_BLOCK_IMMEDIATE  2394
EA_CMP              1F1E
EA_CMPI             1F42
EA_DIVS             1F96
EA_EOR              1C06
EA_LS_MEMORY        200A
EA_LS_REGISTER      1FC2
EA_LS_REGISTER_AFTERBREAK  1FF4
EA_LS_REGISTER_D    1FE4
EA_LS_REGISTER_DIRECT  1FEC
EA_MOVE             1EC8
EA_MOVE0            2364
EA_MOVE1            236A
EA_MOVE2            2370
EA_MOVE3            2376
EA_MOVE4            237C
EA_MOVE5            2382
EA_MOVE6            2388
EA_MOVE7            238E
EA_MOVEA            1EFA
EA_MULS             1F6A
EA_NEG              1BE2
EA_OR               1C58
EA_ORI              1CCE
EA_OR_DESTINATION   1CA2
EA_OR_SOURCE        1C84
EA_PARSE_ABSOLUTE_LONG_ADDRESS  21C2
EA_PARSE_ABSOLUTE_WORD_ADDRESS  21D4
EA_PARSE_AN         2168
EA_PARSE_DN         215C
EA_PARSE_IMMEDIATE_DATA  21B8
EA_PARSE_INDIRECT_AN  2174
EA_PARSE_INDIRECT_DECREMENT_AN  21A0
EA_PARSE_INDIRECT_INCREMENT_AN  2188
EA_PARSE_MODE       2110
EA_PARSE_REGISTER   2322
EA_RO_MEMORY        20E6
EA_RO_REGISTER      20A2
EA_RO_REGISTER_AFTERBREAK  20D0
EA_RO_REGISTER_D    20C4
EA_RO_REGISTER_DIRECT  20CC
EA_SUB              1DA6
EA_SUBQ             1E92
EA_SUBQ_BYTE_CHECK  1EBC
EA_SUB_BYTE_CHECK   1DF2
EA_SUB_DESTINATION  1DFE
EA_SUB_SOURCE       1DD4
ENDADD              10C0
ENDBCC              10AC
ENDBCLR             10DC
ENDBCLRI            1090
ENDCMP              10D8
ENDCMPI             10A8
ENDDIVSL            1088
ENDDIVSW            10D4
ENDEOR              10B8
ENDJSR              1094
ENDLEA              10E0
ENDMOVE             10E8
ENDMOVEA            10C4
ENDMOVEM            109C
ENDMULSL            1084
ENDMULSW            10D0
ENDNEG              10B0
ENDNOP              1078
ENDOP               10F6
ENDOP1              10FA
ENDOR               10BC
ENDORI              10A4
ENDRTS              107C
ENDSHIFT            10EC
ENDSTRTOHEX         1886
ENDSUB              10C8
ENDSUBQ             10CC
END_SEARCH          23D8
ENTERSTART          100C
ENTERTOCONTINUE     2472
EORB_CODE           B100
EORL_CODE           B180
EORSTRING           24A2
EORW_CODE           B140
ERROR               23CA
GETOP               1072
GREETING0           23E0
GREETING1           2421
GREETING2           2443
INVALIDADDRESS      18FE
INVALIDSTR          2464
IO_GET_WORD         21E6
IO_PRINT_OUTPUT     239E
IO_PRINT_OUTPUT1    23B4
IS0                 188E
IS1                 1896
IS2                 189C
IS3                 18A2
IS4                 18A8
IS5                 18AE
IS6                 18B4
IS7                 18BA
IS8                 18C0
IS9                 18C6
ISA                 18CE
ISADD               13D8
ISADDA              1402
ISASL               1612
ISASR               15E8
ISB                 18D6
ISBCLR              1690
ISBCS               16AC
ISBGE               16C4
ISBLT               16DC
ISBRA               170C
ISBRA1              172C
ISBSR               1730
ISBVC               16F4
ISC                 18DE
ISCMP               153C
ISCMPI              1566
ISD                 18E6
ISDATA              1A8E
ISDATA1             1A9A
ISDIVS              151C
ISE                 18EE
ISEOR               135E
ISF                 18F6
ISJSR               174C
ISLEA               1798
ISLSL               15BE
ISLSR               1594
ISMOVE              1476
ISMOVEA             1444
ISMOVEM             1430
ISMULS              14FC
ISNEG               177C
ISNOP               134A
ISOR                13B2
ISORI               1388
ISROL               1666
ISROR               163C
ISRTS               1764
ISSUB               14A4
ISSUBQ              14CE
JSRSTRING           2513
JSR_CODE            4E80
LEASTRING           2520
LEA_CODE            41C0
LF                  A
LINECOUNTER         190E
LOOP                1052
LSLSTRING           24E2
LSL_CODE            E108
LSRSTRING           24E6
LSR_CODE            E008
MASK15TO12          1A4A
MASK15TO6           1A5A
MASK15TO7           1A52
MASK15TO8           1A42
MASKMULDIVL         1A62
MASKSHIFT           1A6A
MOVEAL_CODE         2040
MOVEASTRING         24BC
MOVEAW_CODE         3040
MOVEB_CODE          1000
MOVEL_CODE          2000
MOVEMM2R_CODE       4C80
MOVEMR2M_CODE       4880
MOVEMSTRING         24B6
MOVESTRING          24C2
MOVEW_CODE          3000
MULSL_CODE          800
MULSSTRING          24CF
MULSW_CODE          C1C0
MYDATA              7FFF
N2ACHECK            1B2C
N2ACHECKSTACK       2316
N2ASCII             1AA0
N2ASCII2            1AA4
N2ASCIISTACK        2206
N2ASCIISTACK2       220A
NEGSTRING           251B
NEG_CODE            4400
NEWLINE             23DD
NOPSTRING           249E
NOP_CODE            4E71
OPMASK              F1C0
ORBDN_CODE          8000
ORBEA_CODE          8100
ORISTRING           24A6
ORI_CODE            0
ORLDN_CODE          8080
ORLEA_CODE          8180
ORSTRING            24AA
ORWDN_CODE          8040
ORWEA_CODE          8140
OUTADDRESS          1A72
OUTPUTERROR         248B
OUTPUT_START        A000
PAGELENGTH          19
PAUSEPROGRAM        191A
PAUSERETURN         1918
PRINT0              1B38
PRINT1              1B42
PRINT2              1B4C
PRINT3              1B56
PRINT4              1B60
PRINT5              1B6A
PRINT6              1B74
PRINT7              1B7E
PRINT8              1B88
PRINT9              1B92
PRINTA              1B9C
PRINTB              1BA6
PRINTC              1BB0
PRINTCHAR           1BD8
PRINTD              1BBA
PRINTDATA           10F2
PRINTE              1BC4
PRINTF              1BCE
PUSH0               2296
PUSH1               229E
PUSH2               22A6
PUSH3               22AE
PUSH4               22B6
PUSH5               22BE
PUSH6               22C6
PUSH7               22CE
PUSH8               22D6
PUSH9               22DE
PUSHA               22E6
PUSHB               22EE
PUSHC               22F6
PUSHD               22FE
PUSHE               2306
PUSHF               230E
ROLSTRING           24F2
ROL_CODE            E118
RORSTRING           24F6
ROR_CODE            E018
RTSSTRING           2517
RTS_CODE            4E75
SIZE00              19A4
SIZE000             1996
SIZE001             19DC
SIZE01              19B2
SIZE010             19EA
SIZE011             1A22
SIZE10              19C0
SIZE100             19F8
SIZE101             1A06
SIZE11              19CE
SIZE110             1A14
SIZE111             1A2E
SPACE               23DC
START               1000
STRTOHEX            17C4
STRTOHEXLOOP        17D0
SUBBDN_CODE         9000
SUBBEA_CODE         9100
SUBLDN_CODE         9080
SUBLEA_CODE         9180
SUBQB_CODE          5100
SUBQL_CODE          5180
SUBQSTRING          24CB
SUBQW_CODE          5140
SUBSTRING           24C7
SUBWDN_CODE         9040
SUBWEA_CODE         9140
TEST_END            1004
