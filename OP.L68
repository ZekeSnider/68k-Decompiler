00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 11/26/2014 8:15:13 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :
00000000                             3  * Written by :
00000000                             4  * Date       :
00000000                             5  * Description:
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  *KNOWN ISSUES*
00001000                            10  
00001000                            11  *EOR doesn't increment the word for the immediate, so assumes the next word is a new command
00001000                            12  *Since next word is usually small, the first two bytes are often $00, leading decompiler to
00001000                            13  *think it's another EOR
00001000                            14  * Put program code here
00001000  4E71                      15              NOP                     *Test NOP
00001002  B141                      16              EOR     D0,D1           *Test EOR
00001004  0040 000D                 17              ORI.W   #13,D0          *Test ORI
00001008  8040                      18              OR      D0,D0           *Test OR
0000100A  D1C8                      19              ADDA.L    A0,A0           *Test ADDA
0000100C  D040                      20              ADD     D0,D0           *Test ADD
0000100E  4240                      21              CLR.W   D0              *Clears D0
00001010  4BF9 00001000             22              LEA     cur_address,A5   *Load start address
00001016  4DF9 00001030             23              LEA     test_end,A6     *Load end address
0000101C                            24          
0000101C  3015                      25  loop        MOVE.W  (A5),D0         *Gets the data of where the pointer is at
0000101E  6100 000C                 26              BSR     getOP           *Gets the data at add
00001022  544D                      27              ADDQ.W  #byte,A5        *Incrementing the pointer one word
00001024  BACE                      28              CMPA.W  A6,A5           *Seeing if we're at end of the search area
00001026  6E00 02CA                 29              BGT     end_search      *go to end if we leave search area
0000102A  60F0                      30              BRA     loop            *else go back to the beginning of the loop
0000102C                            31              
0000102C  3400                      32  getOP       MOVE.W  D0,D2           *Moves data to D2 to use
0000102E  B47C 4E71                 33              CMP.W   #nop_code,D2     *Compares to NOP
00001032  6700 00C0                 34              BEQ     isNOP           *Skips the return if it is NOP
00001036                            35              
00001036  6100 013C                 36              BSR     firstByte       *Masks to the first byte
0000103A  6000 001E                 37              BRA     compare_ORI     *Compares the ORI op codes
0000103E  6100 012C                 38  endORI      BSR     compMask        *Masks D2 to make comparisons easier
00001042  6000 0052                 39              BRA     compare_EOR     *Compares the EOR op codes
00001046  6000 001C                 40  endEOR      BRA     compare_OR      *Compares the OR op codes
0000104A  6000 0064                 41  endOR       BRA     compare_ADD     *Compares the ADD op codes
0000104E                            42  endADD
0000104E                            43                                      *if we get here, the operation is unknown
0000104E  3400                      44              MOVE.W  D0,D2           *Restores D2 to default
00001050  6100 0128                 45              BSR     outaddress      *Data unknown, just print the address
00001054  6100 013C                 46              BSR     isData          *And then the data
00001058  4E75                      47  endOP       RTS                     *Returns to caller
0000105A                            48  
0000105A                            49  *Comparison subroutines, broken up by Operation
0000105A                            50  compare_ORI
0000105A  B47C 0000                 51              CMP.W   #ori_code,D2    *Compares to ORI
0000105E  6700 00BC                 52              BEQ     isORI
00001062  60DA                      53              BRA     endORI
00001064                            54              
00001064                            55  compare_OR
00001064  B47C 8000                 56              CMP.W   #orbDn_code,D2  *Compares to ORI.B -> Dn
00001068  6700 00C6                 57              BEQ     isOR
0000106C  B47C 8040                 58              CMP.W   #orwDn_code,D2  *Compares to ORI.W -> Dn
00001070  6700 00BE                 59              BEQ     isOR
00001074  B47C 8080                 60              CMP.W   #orlDn_code,D2  *Compares to ORI.L -> Dn
00001078  6700 00B6                 61              BEQ     isOR
0000107C  B47C 8100                 62              CMP.W   #orbEA_code,D2  *Compares to ORI.B -> EA
00001080  6700 00AE                 63              BEQ     isOR
00001084  B47C 8140                 64              CMP.W   #orwEA_code,D2  *Compares to ORI.W -> EA
00001088  6700 00A6                 65              BEQ     isOR
0000108C  B47C 8180                 66              CMP.W   #orlEA_code,D2  *Compares to ORI.L -> EA
00001090  6700 009E                 67              BEQ     isOR
00001094  60B4                      68              BRA     endOR
00001096                            69              
00001096                            70  compare_EOR
00001096  B47C B100                 71              CMP.W   #eorb_code,D2   *Compares to EOR.B
0000109A  6700 006C                 72              BEQ     isEOR
0000109E  B47C B140                 73              CMP.W   #eorw_code,D2   *Compares to EOR.W
000010A2  6700 0064                 74              BEQ     isEOR
000010A6  B47C B180                 75              CMP.W   #eorl_code,D2   *Compares to EOR.L
000010AA  6700 005C                 76              BEQ     isEOR
000010AE  6096                      77              BRA     endEOR
000010B0                            78              
000010B0                            79  compare_ADD
000010B0  B47C D000                 80              CMP.W   #addbDn_code,D2 *Compares to ADD.B -> Dn
000010B4  6700 008E                 81              BEQ     isADD
000010B8  B47C D040                 82              CMP.W   #addwDn_code,D2 *Compares to ADD.W -> Dn
000010BC  6700 0086                 83              BEQ     isADD
000010C0  B47C D080                 84              CMP.W   #addlDn_code,D2 *Compares to ADD.L -> Dn
000010C4  6700 007E                 85              BEQ     isADD
000010C8  B47C D100                 86              CMP.W   #addbEA_code,D2 *Compares to ADD.B -> EA
000010CC  6700 0076                 87              BEQ     isADD
000010D0  B47C D140                 88              CMP.W   #addwEA_code,D2 *Compares to ADD.W -> EA
000010D4  6700 006E                 89              BEQ     isADD
000010D8  B47C D180                 90              CMP.W   #addlEA_code,D2 *Compares to ADD.L -> EA
000010DC  6700 0066                 91              BEQ     isADD
000010E0  B47C D0C0                 92              CMP.W   #addaw_code,D2  *Compares to ADDA.W
000010E4  6700 0072                 93              BEQ     isADDA
000010E8  B47C D1C0                 94              CMP.W   #addal_code,D2  *Compares to ADDA.L
000010EC  6700 006A                 95              BEQ     isADDA
000010F0  6000 FF5C                 96              BRA     endADD
000010F4                            97  
000010F4  6100 0084                 98  isNOP       BSR     outaddress      *prints current address
000010F8  43F9 00001300             99              LEA     NOPstring,A1    *Loads NOPstring for printing
000010FE  103C 000D                100              MOVE.B  #13,D0          *Sets up trap
00001102  4E4F                     101              TRAP    #15
00001104  6000 FF52                102              BRA     endOP            
00001108  6100 0070                103  isEOR       BSR     outaddress      *prints current address
0000110C  43F9 00001304            104              LEA     EORstring,A1    *Loads EORstring for printing
00001112  103C 000D                105              MOVE.B  #13,D0          *Sets up trap
00001116  4E4F                     106              TRAP    #15
00001118  6000 FF3E                107              BRA     endOP            
0000111C  6100 005C                108  isORI       BSR     outaddress      *prints current address
00001120  43F9 00001308            109              LEA     ORIstring,A1    *Loads ORIstring for printing
00001126  103C 000D                110              MOVE.B  #13,D0          *Sets up trap
0000112A  4E4F                     111              TRAP    #15
0000112C  6000 FF2A                112              BRA     endOP
00001130  6100 0048                113  isOR        BSR     outaddress      *prints current address
00001134  43F9 0000130C            114              LEA     ORstring,A1     *Loads ORstring for printing
0000113A  103C 000D                115              MOVE.B  #13,D0          *Sets up trap
0000113E  4E4F                     116              TRAP    #15
00001140  6000 FF16                117              BRA     endOP
00001144  6100 0034                118  isADD       BSR     outaddress      *prints current address
00001148  43F9 0000130F            119              LEA     ADDstring,A1     *Loads ADDstring for printing
0000114E  103C 000D                120              MOVE.B  #13,D0          *Sets up trap
00001152  4E4F                     121              TRAP    #15
00001154  6000 FF02                122              BRA     endOP
00001158  6100 0020                123  isADDA      BSR     outaddress      *prints current address
0000115C  43F9 00001313            124              LEA     ADDAstring,A1   *Loads ADDstring for printing
00001162  103C 000D                125              MOVE.B  #13,D0          *Sets up trap
00001166  4E4F                     126              TRAP    #15
00001168  6000 FEEE                127              BRA     endOP
0000116C                           128              
0000116C                           129  *Masks to make comparisons easier
0000116C  3400                     130  compMask    MOVE.W  D0,D2           *Gets fresh copy of D0
0000116E  0242 F1C0                131              ANDI.W  #opMask,D2      *Masks D2 for rest of comparisons
00001172  4E75                     132              RTS
00001174  0242 FF00                133  firstByte   ANDI.W  #BitMask15to8,D2   *Masks D2 for the first byte
00001178  4E75                     134              RTS
0000117A                           135              
0000117A                           136  *prints address
0000117A  3F02                     137  outaddress  MOVE.W  D2,-(sp)        *Saves D2
0000117C  340D                     138              MOVE.W  A5,D2           *Moves current address to D2
0000117E  6100 0030                139              BSR     n2ascii         *prints current address
00001182  341F                     140              MOVE.W  (sp)+,D2        *Loads D2
00001184  1239 000012F6            141              MOVE.B  space,D1        *Loads ascii space in D1
0000118A  103C 0006                142              MOVE.B  #6,D0           *Sets up trap
0000118E  4E4F                     143              TRAP    #15
00001190  4E75                     144              RTS
00001192                           145              
00001192                           146  *prints word 'DATA '            
00001192  43F9 000012FA            147  isData      LEA     datastring,A1   *Loads datastring for printing
00001198  103C 000E                148              MOVE.B  #14,D0          *Sets up Trap
0000119C  4E4F                     149              TRAP    #15
0000119E                           150  *prints the data
0000119E  6100 0010                151              BSR     n2ascii         *Prints out the data
000011A2  43F9 000012F7            152              LEA     newline,A1      *Sets up trap for new line
000011A8  103C 000E                153              MOVE.B  #14,D0
000011AC  4E4F                     154              TRAP    #15
000011AE  4E75                     155              RTS
000011B0                           156  **************************************************
000011B0                           157  *Takes the word hex in D2 and prints it to screen*
000011B0                           158  **************************************************
000011B0                           159  
000011B0  183C 000C                160  n2ascii     MOVE.B  #12,D4          *Sets up D4 as counter.
000011B4  3602                     161  n2ascii2    MOVE.W  D2,D3           *Moves to D3 to work on there 
000011B6  E86B                     162              LSR.W   D4,D3           
000011B8  0243 000F                163              ANDI.W  #$000F,D3       *Masks to check last nibble
000011BC  B63C 0000                164              CMP.B   #$0,D3          *Chekcs if D3 is equal to 0
000011C0  6700 0086                165              BEQ     print0
000011C4  B63C 0001                166              CMP.B   #$1,D3          *Chekcs if D3 is equal to 1
000011C8  6700 0088                167              BEQ     print1
000011CC  B63C 0002                168              CMP.B   #$2,D3          *Chekcs if D3 is equal to 2
000011D0  6700 008A                169              BEQ     print2
000011D4  B63C 0003                170              CMP.B   #$3,D3          *Chekcs if D3 is equal to 3
000011D8  6700 008C                171              BEQ     print3
000011DC  B63C 0004                172              CMP.B   #$4,D3          *Chekcs if D3 is equal to 4
000011E0  6700 008E                173              BEQ     print4
000011E4  B63C 0005                174              CMP.B   #$5,D3          *Chekcs if D3 is equal to 5
000011E8  6700 0090                175              BEQ     print5
000011EC  B63C 0006                176              CMP.B   #$6,D3          *Chekcs if D3 is equal to 6
000011F0  6700 0092                177              BEQ     print6
000011F4  B63C 0007                178              CMP.B   #$7,D3          *Chekcs if D3 is equal to 7
000011F8  6700 0094                179              BEQ     print7
000011FC  B63C 0008                180              CMP.B   #$8,D3          *Chekcs if D3 is equal to 8
00001200  6700 0096                181              BEQ     print8
00001204  B63C 0009                182              CMP.B   #$9,D3          *Chekcs if D3 is equal to 9
00001208  6700 0098                183              BEQ     print9
0000120C  B63C 000A                184              CMP.B   #$A,D3          *Chekcs if D3 is equal to A
00001210  6700 009A                185              BEQ     printA
00001214  B63C 000B                186              CMP.B   #$B,D3          *Chekcs if D3 is equal to B
00001218  6700 009C                187              BEQ     printB
0000121C  B63C 000C                188              CMP.B   #$C,D3          *Chekcs if D3 is equal to C
00001220  6700 009E                189              BEQ     printC
00001224  B63C 000D                190              CMP.B   #$D,D3          *Chekcs if D3 is equal to D
00001228  6700 00A0                191              BEQ     printD
0000122C  B63C 000E                192              CMP.B   #$E,D3          *Chekcs if D3 is equal to E
00001230  6700 00A2                193              BEQ     printE
00001234  B63C 000F                194              CMP.B   #$F,D3          *Checks if D3 is equal to F
00001238  6700 00A4                195              BEQ     printF
0000123C  5904                     196  n2acheck    SUB.B   #4,D4           *Decrements our counter
0000123E  B83C 0000                197              CMP.B   #0,D4           *Checks if counter reached 0
00001242  6C00 FF70                198              BGE     n2ascii2        *Returns to top of loop to continue        
00001246  4E75                     199              RTS                     *Else return to caller
00001248                           200  
00001248  4281                     201  print0      CLR.L   D1              *Clears D1
0000124A  123C 0030                202              MOVE.B  #$30,D1         *Sets D1 as ascii 0
0000124E  6000 0098                203              BRA     printchar       *prints the character
00001252  4281                     204  print1      CLR.L   D1              *Clears D1
00001254  123C 0031                205              MOVE.B  #$31,D1         *Sets D1 as ascii 1
00001258  6000 008E                206              BRA     printchar       *prints the character
0000125C  4281                     207  print2      CLR.L   D1              *Clears D1
0000125E  123C 0032                208              MOVE.B  #$32,D1         *Sets D1 as ascii 2
00001262  6000 0084                209              BRA     printchar       *prints the character
00001266  4281                     210  print3      CLR.L   D1              *Clears D1
00001268  123C 0033                211              MOVE.B  #$33,D1         *Sets D1 as ascii 3
0000126C  6000 007A                212              BRA     printchar       *prints the character
00001270  4281                     213  print4      CLR.L   D1              *Clears D1
00001272  123C 0034                214              MOVE.B  #$34,D1         *Sets D1 as ascii 4
00001276  6000 0070                215              BRA     printchar       *prints the character
0000127A  4281                     216  print5      CLR.L   D1              *Clears D1
0000127C  123C 0035                217              MOVE.B  #$35,D1         *Sets D1 as ascii 5
00001280  6000 0066                218              BRA     printchar       *prints the character
00001284  4281                     219  print6      CLR.L   D1              *Clears D1
00001286  123C 0036                220              MOVE.B  #$36,D1         *Sets D1 as ascii 6
0000128A  6000 005C                221              BRA     printchar       *prints the character
0000128E  4281                     222  print7      CLR.L   D1              *Clears D1
00001290  123C 0037                223              MOVE.B  #$37,D1         *Sets D1 as ascii 7
00001294  6000 0052                224              BRA     printchar       *prints the character
00001298  4281                     225  print8      CLR.L   D1              *Clears D1
0000129A  123C 0038                226              MOVE.B  #$38,D1         *Sets D1 as ascii 8
0000129E  6000 0048                227              BRA     printchar       *prints the character
000012A2  4281                     228  print9      CLR.L   D1              *Clears D1
000012A4  123C 0039                229              MOVE.B  #$39,D1         *Sets D1 as ascii 9
000012A8  6000 003E                230              BRA     printchar       *prints the character
000012AC  4281                     231  printA      CLR.L   D1              *Clears D1
000012AE  123C 0041                232              MOVE.B  #$41,D1         *Sets D1 as ascii A
000012B2  6000 0034                233              BRA     printchar       *prints the character
000012B6  4281                     234  printB      CLR.L   D1              *Clears D1
000012B8  123C 0042                235              MOVE.B  #$42,D1         *Sets D1 as ascii B
000012BC  6000 002A                236              BRA     printchar       *prints the character
000012C0  4281                     237  printC      CLR.L   D1              *Clears D1
000012C2  123C 0043                238              MOVE.B  #$43,D1         *Sets D1 as ascii C
000012C6  6000 0020                239              BRA     printchar       *prints the character
000012CA  4281                     240  printD      CLR.L   D1              *Clears D1
000012CC  123C 0044                241              MOVE.B  #$44,D1         *Sets D1 as ascii D
000012D0  6000 0016                242              BRA     printchar       *prints the character
000012D4  4281                     243  printE      CLR.L   D1              *Clears D1
000012D6  123C 0045                244              MOVE.B  #$45,D1         *Sets D1 as ascii E
000012DA  6000 000C                245              BRA     printchar       *prints the character         
000012DE  4281                     246  printF      CLR.L   D1              *Clears D1
000012E0  123C 0046                247              MOVE.B  #$46,D1         *Sets D1 as ascii F
000012E4  6000 0002                248              BRA     printchar       *prints the character
000012E8  103C 0006                249  printchar   MOVE.B  #6,D0           *Sets up Trap
000012EC  4E4F                     250              TRAP    #15
000012EE  6000 FF4C                251              BRA     n2acheck        *returns to n2ascii
000012F2                           252              
000012F2                           253  
000012F2                           254  end_search    
000012F2                           255  
000012F2  FFFF FFFF                256      SIMHALT             ; halt simulator
000012F6                           257  
000012F6                           258  * Put variables and constants here
000012F6                           259  
000012F6= 20                       260  space       DC.B    $20         *space
000012F7  =0000000D                261  CR          EQU     $0D         *Carriage return
000012F7  =0000000A                262  LF          EQU     $0A         *Line Feed
000012F7= 0D 0A 00                 263  newline     DC.B    CR,LF,0     *New Line
000012FA  =00000002                264  byte        EQU     2           *How much to move the search address.
000012FA                           265                                  *2 bytes because we're searching for a word
000012FA  =00001000                266  cur_address EQU     $00001000   *Start of search
000012FA  =00001030                267  test_end    EQU     $00001030   *End of search
000012FA                           268  mydata      REG     D0-D7/A0-A6  *Used for pushing registers to stack
000012FA= 44 41 54 41 20 00        269  datastring  DC.B    'DATA ',0   *Data string
00001300= 4E 4F 50 00              270  NOPstring   DC.B    'NOP',0     *NOP string
00001304= 45 4F 52 00              271  EORstring   DC.B    'EOR',0     *EOR string
00001308= 4F 52 49 00              272  ORIstring   DC.B    'ORI',0     *ORI string
0000130C= 4F 52 00                 273  ORstring    DC.B    'OR',0      *OR string
0000130F= 41 44 44 00              274  ADDstring   DC.B    'ADD',0     *ADD string
00001313= 41 44 44 41 00           275  ADDAstring  DC.B    'ADDA',0     *ADDA string
00001318                           276  
00001318  =00004E71                277  nop_code    EQU     $4E71       *Hex for NOP
00001318  =0000FF00                278  BitMask15to8 EQU     $FF00       *Mask for showing first two bytes, 0'ing last 2
00001318  =0000F1C0                279  opMask      EQU     $F1C0       *Masks word so first byte and OP mode are visible
00001318                           280                                  *The rest of the word are 0's
00001318  =0000B100                281  eorb_code   EQU     %1011000100000000   *Binary of EOR.B, masked
00001318  =0000B140                282  eorw_code   EQU     %1011000101000000   *Binary of EOR.W, masked
00001318  =0000B180                283  eorl_code   EQU     %1011000110000000   *Binary of EOR.L, masked
00001318  =00000000                284  ori_code    EQU     $0000               *Hex of first two bytes of ORI
00001318                           285                                          *last 2 bytes don't matter for compare
00001318  =00008000                286  orbDn_code  EQU     %1000000000000000   *Binary of OR.B -> Dn
00001318  =00008040                287  orwDn_code  EQU     %1000000001000000   *Binary of OR.W -> Dn
00001318  =00008080                288  orlDn_code  EQU     %1000000010000000   *Binary of OR.L -> Dn
00001318  =00008100                289  orbEA_code  EQU     %1000000100000000   *Binary of OR.B -> EA
00001318  =00008140                290  orwEA_code  EQU     %1000000101000000   *Binary of OR.W -> EA
00001318  =00008180                291  orlEA_code  EQU     %1000000110000000   *Binary of OR.L -> EA
00001318  =0000D000                292  addbDn_code EQU     %1101000000000000   *Binary of ADD.B -> Dn
00001318  =0000D040                293  addwDn_code EQU     %1101000001000000   *Binary of ADD.W -> Dn
00001318  =0000D080                294  addlDn_code EQU     %1101000010000000   *Binary of ADD.L -> Dn
00001318  =0000D100                295  addbEA_code EQU     %1101000100000000   *Binary of ADD.B -> EA
00001318  =0000D140                296  addwEA_code EQU     %1101000101000000   *Binary of ADD.W -> EA
00001318  =0000D180                297  addlEA_code EQU     %1101000110000000   *Binary of ADD.L -> EA
00001318  =0000D0C0                298  addaw_code  EQU     %1101000011000000   *Binary of ADDA.W
00001318  =0000D1C0                299  addal_code  EQU     %1101000111000000   *Binary of ADDA.L
00001318                           300  
00001318                           301      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDAL_CODE          D1C0
ADDASTRING          1313
ADDAW_CODE          D0C0
ADDBDN_CODE         D000
ADDBEA_CODE         D100
ADDLDN_CODE         D080
ADDLEA_CODE         D180
ADDSTRING           130F
ADDWDN_CODE         D040
ADDWEA_CODE         D140
BITMASK15TO8        FF00
BYTE                2
COMPARE_ADD         10B0
COMPARE_EOR         1096
COMPARE_OR          1064
COMPARE_ORI         105A
COMPMASK            116C
CR                  D
CUR_ADDRESS         1000
DATASTRING          12FA
ENDADD              104E
ENDEOR              1046
ENDOP               1058
ENDOR               104A
ENDORI              103E
END_SEARCH          12F2
EORB_CODE           B100
EORL_CODE           B180
EORSTRING           1304
EORW_CODE           B140
FIRSTBYTE           1174
GETOP               102C
ISADD               1144
ISADDA              1158
ISDATA              1192
ISEOR               1108
ISNOP               10F4
ISOR                1130
ISORI               111C
LF                  A
LOOP                101C
MYDATA              7FFF
N2ACHECK            123C
N2ASCII             11B0
N2ASCII2            11B4
NEWLINE             12F7
NOPSTRING           1300
NOP_CODE            4E71
OPMASK              F1C0
ORBDN_CODE          8000
ORBEA_CODE          8100
ORISTRING           1308
ORI_CODE            0
ORLDN_CODE          8080
ORLEA_CODE          8180
ORSTRING            130C
ORWDN_CODE          8040
ORWEA_CODE          8140
OUTADDRESS          117A
PRINT0              1248
PRINT1              1252
PRINT2              125C
PRINT3              1266
PRINT4              1270
PRINT5              127A
PRINT6              1284
PRINT7              128E
PRINT8              1298
PRINT9              12A2
PRINTA              12AC
PRINTB              12B6
PRINTC              12C0
PRINTCHAR           12E8
PRINTD              12CA
PRINTE              12D4
PRINTF              12DE
SPACE               12F6
START               1000
TEST_END            1030
